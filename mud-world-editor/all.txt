# scripts/ui/EditorUIManager.gd
class_name EditorUIManager
extends RefCounted

signal request_load_region(filename)
signal request_jump_to_room(id)
signal request_validate
signal snap_toggled(is_on)
signal request_create_connection(src, dir, target, twoway)
signal request_create_region(name, room_data)
signal context_action(action_id)
signal creation_direction_selected(direction)
signal request_jump_to_error(region_file, room_id)
signal tool_changed(mode, data)
signal request_create_db_entry(type) 
signal request_delete_db_entry(type, id)
signal request_select_db_entry(type, id)
signal request_toggle_world_view(enabled)
signal request_auto_layout
signal request_center_view
signal request_copy
signal request_paste
signal request_save_template(room_id)
signal request_context_menu(global_pos, meta)
signal request_delete_room_confirm(room_id, include_reciprocal) # New Signal

enum ToolMode { SELECT, PAINT, STAMP }

var ui_layer: CanvasLayer
var side_panel: SidePanel
var btn_world_view: Button
var footer_container: VBoxContainer

var creator_modal: CreatorModal
var context_menu: PopupMenu
var creation_menu: PopupMenu
var validation_modal: AcceptDialog
var validation_results: Tree

# Search Components
var search_modal: AcceptDialog
var search_input: LineEdit
var search_scroll: ScrollContainer
var search_results_box: VBoxContainer
var search_data_cache: Dictionary = {}
var selected_search_card: PanelContainer = null
var selected_search_meta = null 

# Delete Confirmation
var delete_confirm_modal: ConfirmationDialog
var delete_chk_reciprocal: CheckBox
var _pending_delete_id: String = ""

var status_bar: Panel
var lbl_status_tool: Label
var lbl_status_info: Label
var lbl_status_global: Label
var lbl_status_grid: Label
var lbl_status_zoom: Label
var lbl_status_snap: Label
var btn_center_view: Button

const SIDEPANEL_SCRIPT = preload("res://scripts/ui/SidePanel.gd")

func setup(layer: CanvasLayer):
	ui_layer = layer
	
	side_panel = SIDEPANEL_SCRIPT.new()
	var main_vbox = side_panel.setup()
	_forward_side_panel_signals()
	ui_layer.add_child(side_panel)
	
	_setup_footer(main_vbox)
	_setup_status_bar()
	_setup_modals_and_popups()
	_setup_search_modal()

func _forward_side_panel_signals():
	side_panel.request_load_region.connect(func(f): request_load_region.emit(f))
	side_panel.request_jump_to_room.connect(func(id): request_jump_to_room.emit(id))
	side_panel.snap_toggled.connect(func(b): snap_toggled.emit(b); update_status_snap(b))
	side_panel.request_validate.connect(func(): request_validate.emit())
	side_panel.tool_changed.connect(func(m, d): tool_changed.emit(m, d))
	side_panel.request_create_db_entry.connect(func(t): request_create_db_entry.emit(t))
	side_panel.request_delete_db_entry.connect(func(t, id): request_delete_db_entry.emit(t, id))
	side_panel.request_select_db_entry.connect(func(t, id): request_select_db_entry.emit(t, id))
	side_panel.request_auto_layout.connect(func(): request_auto_layout.emit())
	side_panel.request_create_modal_open.connect(func(): creator_modal.show())
	side_panel.request_context_menu.connect(func(p, m): request_context_menu.emit(p, m))

func _setup_footer(main_vbox: VBoxContainer):
	main_vbox.add_child(HSeparator.new())
	footer_container = VBoxContainer.new()
	main_vbox.add_child(footer_container)
	
	btn_world_view = Button.new()
	btn_world_view.text = "ðŸŒ  WORLD MAP"; btn_world_view.toggle_mode = true
	btn_world_view.custom_minimum_size.y = 40; btn_world_view.alignment = HORIZONTAL_ALIGNMENT_CENTER
	_apply_style(btn_world_view, Color(0.2, 0.2, 0.25))
	
	btn_world_view.toggled.connect(func(b): 
		btn_world_view.text = "ðŸ”™  REGION VIEW" if b else "ðŸŒ  WORLD MAP"
		request_toggle_world_view.emit(b)
		side_panel.update_layout_btn_text(b)
		if b: update_status_info("World Map", 0)
	)
	footer_container.add_child(btn_world_view)
	side_panel.gui_input.connect(_on_panel_gui_input)

func _setup_status_bar():
	status_bar = Panel.new()
	status_bar.anchor_top = 0.96; status_bar.anchor_bottom = 1.0; status_bar.anchor_right = 1.0
	var style = StyleBoxFlat.new(); style.bg_color = Color(0.08, 0.08, 0.1); style.border_width_top = 1; style.border_color = Color(0.3, 0.3, 0.35)
	status_bar.add_theme_stylebox_override("panel", style)
	ui_layer.add_child(status_bar)
	
	var hbox = HBoxContainer.new(); hbox.set_anchors_preset(15); hbox.offset_left = 10; hbox.offset_right = -10
	status_bar.add_child(hbox)
	
	var btn_copy = Button.new(); btn_copy.text = "Copy"; _apply_style(btn_copy)
	btn_copy.pressed.connect(func(): request_copy.emit())
	hbox.add_child(btn_copy)
	
	var btn_paste = Button.new(); btn_paste.text = "Paste"; _apply_style(btn_paste)
	btn_paste.pressed.connect(func(): request_paste.emit())
	hbox.add_child(btn_paste)
	hbox.add_child(VSeparator.new())
	
	lbl_status_tool = Label.new(); lbl_status_tool.text = "TOOL: SELECT"; lbl_status_tool.custom_minimum_size.x = 200; lbl_status_tool.clip_text = true; lbl_status_tool.add_theme_font_size_override("font_size", 12)
	hbox.add_child(lbl_status_tool); hbox.add_child(VSeparator.new())
	
	lbl_status_info = Label.new(); lbl_status_info.text = "No Region Loaded"; lbl_status_info.size_flags_horizontal = 3; lbl_status_info.horizontal_alignment = 1; lbl_status_info.add_theme_color_override("font_color", Color.LIGHT_GRAY); lbl_status_info.add_theme_font_size_override("font_size", 12)
	hbox.add_child(lbl_status_info); hbox.add_child(VSeparator.new())
	
	var btn_search = Button.new(); btn_search.text = "ðŸ”"; _apply_style(btn_search)
	btn_search.pressed.connect(show_search_modal)
	hbox.add_child(btn_search); hbox.add_child(VSeparator.new())
	
	lbl_status_global = Label.new(); lbl_status_global.text = "XY: 0, 0"; lbl_status_global.custom_minimum_size.x = 100; lbl_status_global.add_theme_font_override("font", ThemeDB.get_fallback_font())
	hbox.add_child(lbl_status_global); hbox.add_child(VSeparator.new())
	
	lbl_status_grid = Label.new(); lbl_status_grid.text = "G: 0, 0"; lbl_status_grid.custom_minimum_size.x = 80; lbl_status_grid.add_theme_font_override("font", ThemeDB.get_fallback_font())
	hbox.add_child(lbl_status_grid); hbox.add_child(VSeparator.new())
	
	lbl_status_snap = Label.new(); lbl_status_snap.text = "SNAP: OFF"; lbl_status_snap.custom_minimum_size.x = 80; lbl_status_snap.add_theme_font_size_override("font_size", 12); lbl_status_snap.modulate = Color(1, 1, 1, 0.5)
	hbox.add_child(lbl_status_snap); hbox.add_child(VSeparator.new())
	
	lbl_status_zoom = Label.new(); lbl_status_zoom.text = "100%"; lbl_status_zoom.custom_minimum_size.x = 50; lbl_status_zoom.horizontal_alignment = 2
	hbox.add_child(lbl_status_zoom)
	
	btn_center_view = Button.new(); btn_center_view.text = "âŒ–"; btn_center_view.tooltip_text = "Recenter View (F)"; _apply_style(btn_center_view)
	btn_center_view.pressed.connect(func(): request_center_view.emit()); hbox.add_child(btn_center_view)

func _setup_modals_and_popups():
	creator_modal = CreatorModal.new(); ui_layer.add_child(creator_modal); creator_modal.setup()
	creator_modal.request_create_region.connect(func(n,d): request_create_region.emit(n,d))
	context_menu = PopupMenu.new(); ui_layer.add_child(context_menu); context_menu.id_pressed.connect(func(id): context_action.emit(id))
	creation_menu = PopupMenu.new(); ui_layer.add_child(creation_menu)
	for i in range(12): creation_menu.add_item("", i) 
	
	# Validation Results Modal
	validation_modal = AcceptDialog.new(); validation_modal.title = "World Validation Results"; validation_modal.min_size = Vector2i(800, 500); ui_layer.add_child(validation_modal)
	var ok_btn = validation_modal.get_ok_button(); ok_btn.custom_minimum_size.x = 100; _apply_style(ok_btn)
	var val_bg = PanelContainer.new(); val_bg.set_anchors_preset(Control.PRESET_FULL_RECT)
	var val_style = StyleBoxFlat.new(); val_style.bg_color = Color(0.1, 0.1, 0.12); val_style.set_border_width_all(1); val_style.border_color = Color(0.3, 0.3, 0.35)
	val_bg.add_theme_stylebox_override("panel", val_style)
	validation_modal.add_child(val_bg)
	validation_results = Tree.new(); validation_results.hide_root = true; validation_results.columns = 2
	validation_results.set_column_expand(0, true); validation_results.set_column_expand(1, false); validation_results.set_column_custom_minimum_width(1, 150)
	validation_results.item_activated.connect(_on_validation_item_clicked)
	val_bg.add_child(validation_results)

	# Delete Confirmation Modal
	delete_confirm_modal = ConfirmationDialog.new()
	delete_confirm_modal.title = "Confirm Deletion"
	delete_confirm_modal.min_size = Vector2i(300, 150)
	
	var del_vbox = VBoxContainer.new()
	del_vbox.alignment = BoxContainer.ALIGNMENT_CENTER
	delete_confirm_modal.add_child(del_vbox)
	
	var lbl = Label.new()
	lbl.text = "Are you sure you want to delete this room?"
	lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	del_vbox.add_child(lbl)
	
	delete_chk_reciprocal = CheckBox.new()
	delete_chk_reciprocal.text = "Remove incoming references?"
	delete_chk_reciprocal.button_pressed = true
	delete_chk_reciprocal.tooltip_text = "If checked, doors leading TO this room from neighbors will also be removed."
	del_vbox.add_child(delete_chk_reciprocal)
	
	ui_layer.add_child(delete_confirm_modal)
	delete_confirm_modal.confirmed.connect(func(): request_delete_room_confirm.emit(_pending_delete_id, delete_chk_reciprocal.button_pressed))

func show_delete_room_prompt(id: String):
	_pending_delete_id = id
	delete_confirm_modal.popup_centered()

# --- SEARCH MODAL (VISUAL OVERHAUL) ---

func _setup_search_modal():
	search_modal = AcceptDialog.new()
	search_modal.title = "Global Search"
	search_modal.min_size = Vector2i(600, 500)
	ui_layer.add_child(search_modal)
	
	var main_vb = VBoxContainer.new()
	main_vb.add_theme_constant_override("separation", 12)
	search_modal.add_child(main_vb)
	
	# Header & Input
	var input_panel = PanelContainer.new()
	var ip_style = StyleBoxFlat.new()
	ip_style.bg_color = Color(0.12, 0.12, 0.14)
	ip_style.set_corner_radius_all(4)
	ip_style.content_margin_left = 10; ip_style.content_margin_right = 10
	ip_style.content_margin_top = 10; ip_style.content_margin_bottom = 10
	input_panel.add_theme_stylebox_override("panel", ip_style)
	main_vb.add_child(input_panel)
	
	search_input = LineEdit.new()
	search_input.placeholder_text = "Type to search rooms, NPCs, items..."
	search_input.clear_button_enabled = true
	_apply_style(search_input)
	var si_style = search_input.get_theme_stylebox("normal").duplicate()
	si_style.content_margin_top = 8; si_style.content_margin_bottom = 8
	si_style.bg_color = Color(0.08, 0.08, 0.1)
	search_input.add_theme_stylebox_override("normal", si_style)
	input_panel.add_child(search_input)
	
	# Results Scroll Area
	var scroll_bg = PanelContainer.new()
	scroll_bg.size_flags_vertical = Control.SIZE_EXPAND_FILL
	var sb_style = StyleBoxFlat.new()
	sb_style.bg_color = Color(0.08, 0.08, 0.1)
	sb_style.set_border_width_all(1)
	sb_style.border_color = Color(0.2, 0.2, 0.22)
	sb_style.set_corner_radius_all(4)
	scroll_bg.add_theme_stylebox_override("panel", sb_style)
	main_vb.add_child(scroll_bg)
	
	search_scroll = ScrollContainer.new()
	search_scroll.horizontal_scroll_mode = ScrollContainer.SCROLL_MODE_DISABLED
	scroll_bg.add_child(search_scroll)
	
	# List Content
	search_results_box = VBoxContainer.new()
	search_results_box.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	search_results_box.add_theme_constant_override("separation", 4)
	
	var m = MarginContainer.new() 
	m.add_theme_constant_override("margin_left", 4); m.add_theme_constant_override("margin_right", 4)
	m.add_theme_constant_override("margin_top", 4); m.add_theme_constant_override("margin_bottom", 4)
	m.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	m.add_child(search_results_box)
	search_scroll.add_child(m)

	# Signals
	search_input.text_changed.connect(_on_search_text_changed)
	search_input.text_submitted.connect(func(_t): 
		_on_search_result_clicked()
		if search_results_box.get_child_count() > 0: search_modal.hide() 
	)
	search_modal.confirmed.connect(_confirm_search)

func show_search_modal():
	search_modal.popup_centered()
	search_input.grab_focus()
	search_input.text = ""
	_clear_search_results()

func cache_search_data(world_data: Dictionary, npcs: Dictionary, items: Dictionary):
	search_data_cache.clear()
	search_data_cache["world"] = world_data
	search_data_cache["npcs"] = npcs
	search_data_cache["items"] = items

func _clear_search_results():
	for c in search_results_box.get_children(): c.queue_free()
	selected_search_card = null
	selected_search_meta = null

func _on_search_text_changed(text):
	_clear_search_results()
	if text.length() < 2: return
	
	var term = text.to_lower()
	var world = search_data_cache.get("world", {})
	var count = 0
	const MAX_RESULTS = 50 
	
	# Search Rooms
	for rid in world:
		var r_data = world[rid]
		var region_name = r_data.get("name", rid.capitalize())
		var rooms = r_data.get("rooms", {})
		for room_id in rooms:
			var r_name = rooms[room_id].get("name", "").to_lower()
			if term in room_id.to_lower() or term in r_name:
				_create_search_card(
					rooms[room_id].get("name", "Unnamed"),
					"Room â€¢ %s â€¢ %s" % [region_name, room_id],
					"ðŸ“", Color(0.2, 0.6, 0.8),
					{"type": "room", "region": rid, "id": room_id}
				)
				count += 1
				if count >= MAX_RESULTS: return
	
	# Search NPCs
	var npcs = search_data_cache.get("npcs", {})
	for nid in npcs:
		if term in nid.to_lower() or term in npcs[nid].get("name", "").to_lower():
			_create_search_card(
				npcs[nid].get("name", "Unnamed"),
				"NPC â€¢ " + nid,
				"ðŸ‘¤", Color(0.8, 0.4, 0.4),
				{"type": "db", "kind": "npc", "id": nid}
			)
			count += 1
			if count >= MAX_RESULTS: return

func _create_search_card(title: String, subtitle: String, icon: String, color: Color, meta: Dictionary):
	var pc = PanelContainer.new()
	pc.mouse_filter = Control.MOUSE_FILTER_STOP
	pc.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.15, 0.15, 0.17)
	style.set_border_width_all(1)
	style.border_color = Color(0.25, 0.25, 0.28)
	style.set_corner_radius_all(4)
	style.content_margin_left = 8; style.content_margin_right = 8
	style.content_margin_top = 6; style.content_margin_bottom = 6
	pc.add_theme_stylebox_override("panel", style)
	
	var hb = HBoxContainer.new()
	hb.add_theme_constant_override("separation", 12)
	pc.add_child(hb)
	
	# Icon Box
	var icon_box = PanelContainer.new()
	var ib_style = StyleBoxFlat.new()
	ib_style.bg_color = color.darkened(0.7)
	ib_style.set_border_width_all(1)
	ib_style.border_color = color
	ib_style.set_corner_radius_all(4)
	icon_box.add_theme_stylebox_override("panel", ib_style)
	icon_box.custom_minimum_size = Vector2(32, 32)
	
	var l_icon = Label.new()
	l_icon.text = icon
	l_icon.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	l_icon.vertical_alignment = VERTICAL_ALIGNMENT_CENTER
	icon_box.add_child(l_icon)
	hb.add_child(icon_box)
	
	# Text
	var vb_text = VBoxContainer.new()
	vb_text.alignment = BoxContainer.ALIGNMENT_CENTER
	var l_title = Label.new(); l_title.text = title
	l_title.add_theme_font_size_override("font_size", 14)
	var l_sub = Label.new(); l_sub.text = subtitle
	l_sub.add_theme_font_size_override("font_size", 11)
	l_sub.modulate = Color(0.7, 0.7, 0.75)
	vb_text.add_child(l_title); vb_text.add_child(l_sub)
	hb.add_child(vb_text)
	
	# Store Metadata
	pc.set_meta("search_data", meta)
	
	# Input Handling
	pc.gui_input.connect(func(ev):
		if ev is InputEventMouseButton and ev.button_index == MOUSE_BUTTON_LEFT and ev.pressed:
			_select_search_card(pc)
			if ev.double_click: _confirm_search()
	)
	# Hover visual
	pc.mouse_entered.connect(func(): if pc != selected_search_card: style.bg_color = Color(0.2, 0.2, 0.22))
	pc.mouse_exited.connect(func(): if pc != selected_search_card: style.bg_color = Color(0.15, 0.15, 0.17))
	
	search_results_box.add_child(pc)

func _select_search_card(card: PanelContainer):
	# Deselect old
	if selected_search_card and is_instance_valid(selected_search_card):
		var old_style = selected_search_card.get_theme_stylebox("panel")
		old_style.bg_color = Color(0.15, 0.15, 0.17)
		old_style.border_color = Color(0.25, 0.25, 0.28)
	
	selected_search_card = card
	selected_search_meta = card.get_meta("search_data")
	
	# Select new
	var new_style = card.get_theme_stylebox("panel")
	new_style.bg_color = Color(0.25, 0.25, 0.35)
	new_style.border_color = Color(0.4, 0.6, 1.0)

func _confirm_search():
	if not selected_search_meta and search_results_box.get_child_count() > 0:
		# If nothing selected but we hit enter, select the first one
		_select_search_card(search_results_box.get_child(0))
	
	if selected_search_meta:
		var meta = selected_search_meta
		if meta.type == "room":
			request_jump_to_error.emit(meta.region + ".json", meta.id)
		elif meta.type == "db":
			request_select_db_entry.emit(meta.kind, meta.id)
		search_modal.hide()

func _on_search_result_clicked():
	# Compatibility function for old tree logic if needed, but main flow is _confirm_search
	_confirm_search()

# --- PROXY METHODS ---
func update_db_lists(npcs: Dictionary, items: Dictionary, templates: Dictionary, magic: Dictionary, quests: Dictionary): 
	side_panel.update_db_lists(npcs, items, templates, magic, quests)
func refresh_explorer(h, c, s): side_panel.refresh_explorer(h, c, s) 
func select_room_item(id): side_panel.select_room_item(id)
func update_dirty_visuals(cur, dirty, rooms): side_panel.update_dirty_visuals(cur, dirty, rooms)
func update_layout_btn_text(is_world: bool): side_panel.update_layout_btn_text(is_world)

# --- POPUP/MODAL CONTROLS ---
func show_context_menu(items: Dictionary):
	context_menu.clear(); for l in items: context_menu.add_item(l, items[l])
	context_menu.position = Vector2(ui_layer.get_viewport().get_mouse_position()); context_menu.popup()

func show_creation_menu(position: Vector2): creation_menu.position = position; creation_menu.popup()

func show_validation_results(errors: Array):
	validation_results.clear()
	var root = validation_results.create_item()
	if errors.is_empty():
		var item = validation_results.create_item(root)
		item.set_text(0, "Validation complete. No errors found!")
		item.set_custom_color(0, Color.GREEN)
		validation_modal.size = Vector2i(400, 150)
	else:
		validation_modal.size = Vector2i(600, 400)
		var err_icon = ui_layer.get_theme_icon("error", "EditorIcons")
		var warn_icon = ui_layer.get_theme_icon("warning", "EditorIcons")
		var regions = {}
		for e_str in errors:
			var parts = e_str.split("] ")
			var region_id = parts[0].trim_prefix("[")
			if not regions.has(region_id):
				regions[region_id] = validation_results.create_item(root)
				regions[region_id].set_text(0, "Region: " + region_id.capitalize())
				regions[region_id].set_custom_color(0, Color.GOLD)
			var err_item = validation_results.create_item(regions[region_id])
			var msg = parts[1]
			var room_id = msg.substr(0, msg.find(" "))
			err_item.set_text(0, msg)
			err_item.set_text(1, room_id)
			if "One-way" in msg: err_item.set_icon(0, warn_icon); err_item.set_custom_color(0, Color.ORANGE)
			else: err_item.set_icon(0, err_icon); err_item.set_custom_color(0, Color.SALMON)
			err_item.set_metadata(0, {"file": region_id + ".json", "room": room_id})
	validation_modal.popup_centered()

func _on_validation_item_clicked():
	var item = validation_results.get_selected()
	if item and item.get_metadata(0):
		var data = item.get_metadata(0)
		request_jump_to_error.emit(data.file, data.room)
		validation_modal.hide()

# --- UTILS ---
func is_mouse_over_ui() -> bool:
	var m = ui_layer.get_viewport().get_mouse_position()
	if side_panel.get_global_rect().has_point(m) or status_bar.get_global_rect().has_point(m): return true
	if creator_modal.visible and creator_modal.get_global_rect().has_point(m): return true
	if validation_modal.visible and validation_modal.get_global_rect().has_point(m): return true
	if search_modal.visible and search_modal.get_global_rect().has_point(m): return true
	if delete_confirm_modal.visible and delete_confirm_modal.get_global_rect().has_point(m): return true
	return false

func _on_panel_gui_input(event: InputEvent):
	if event is InputEventMouseButton and event.button_index in [MOUSE_BUTTON_WHEEL_UP, MOUSE_BUTTON_WHEEL_DOWN]:
		ui_layer.get_viewport().set_input_as_handled()

func update_tool_display(mode: int, data: Dictionary):
	side_panel.update_stamp_button_state(mode == ToolMode.STAMP)
	match mode:
		ToolMode.SELECT: lbl_status_tool.text = "TOOL: SELECT"; lbl_status_tool.modulate = Color.WHITE
		ToolMode.PAINT: lbl_status_tool.text = "PAINT [%s=%s]" % [data.key, data.val]; lbl_status_tool.modulate = Color.GREEN
		ToolMode.STAMP:
			var txt = "STAMP [%s]" % data.id
			if data.has("type") and data.type == "room_template": txt = "STAMP TEMPLATE [%s]" % data.id
			lbl_status_tool.text = txt; lbl_status_tool.modulate = Color.CYAN

func update_status_info(region_name: String, room_count: int): lbl_status_info.text = "%s (%d rooms)" % [region_name.capitalize(), room_count] if room_count >= 0 else region_name
func update_status_coords(global_pos: Vector2):
	lbl_status_global.text = "XY: %d, %d" % [int(global_pos.x), int(global_pos.y)]
	lbl_status_grid.text = "G: %d, %d" % [int(round(global_pos.x / 250.0)), int(round(global_pos.y / 250.0))]
func update_status_zoom(zoom_val: Vector2): lbl_status_zoom.text = "Zoom: %d%%" % int(zoom_val.x * 100)
func update_status_snap(enabled: bool): lbl_status_snap.text = "SNAP: ON" if enabled else "SNAP: OFF"; lbl_status_snap.modulate = Color.WHITE if enabled else Color(1, 1, 1, 0.5)

func _apply_style(node: Control, bg_color = Color(0.15, 0.15, 0.18)):
	var s = StyleBoxFlat.new(); s.bg_color = bg_color; s.set_border_width_all(1); s.border_color = Color(0.4, 0.4, 0.45); s.set_corner_radius_all(4); s.content_margin_left = 8; s.content_margin_right = 8
	if node is Button:
		node.add_theme_stylebox_override("normal", s); node.add_theme_stylebox_override("hover", s.duplicate()); node.add_theme_stylebox_override("pressed", s.duplicate())
		node.get_theme_stylebox("hover").bg_color = bg_color.lightened(0.1); node.get_theme_stylebox("pressed").bg_color = bg_color.darkened(0.1)
	elif node is LineEdit:
		var s2 = s.duplicate(); s2.bg_color = Color(0.08,0.08,0.1); node.add_theme_stylebox_override("normal", s2)
# scripts/ui/panels/CreatorModal.gd
class_name CreatorModal
extends Panel

signal request_create_region(name, room_data)

var widgets: Dictionary = {}
var _temp_generated_rooms: Dictionary = {}

# UI Refs
var slider_density: HSlider
var slider_conns: HSlider
var lbl_density_val: Label
var lbl_conns_val: Label
var lbl_p1: Label
var lbl_p2: Label
var lbl_s1: Label
var lbl_s2: Label
var container_dims: Control
var container_density: Control
var slider_p1: HSlider
var slider_p2: HSlider
var lbl_p1_val: Label
var lbl_p2_val: Label

# Update path to match new structure
const PREVIEW_SCRIPT = preload("res://scripts/ui/panels/GeneratorPreview.gd")
var generator_preview: Control

func setup():
	hide()
	anchor_left = 0.22; anchor_right = 0.73
	anchor_top = 0.1; anchor_bottom = 0.9
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.15, 0.15, 0.18)
	style.set_border_width_all(2)
	style.border_color = Color(0.4, 0.6, 1.0)
	add_theme_stylebox_override("panel", style)
	
	var main_hbox = HBoxContainer.new()
	main_hbox.set_anchors_preset(15)
	main_hbox.offset_left = 20; main_hbox.offset_top = 20
	main_hbox.offset_right = -20; main_hbox.offset_bottom = -20
	add_child(main_hbox)
	
	var vbox = VBoxContainer.new()
	vbox.size_flags_horizontal = 3
	vbox.size_flags_stretch_ratio = 0.6
	main_hbox.add_child(vbox)
	
	vbox.add_child(_lbl("1. Settings"))
	widgets.name = LineEdit.new()
	widgets.name.text = "new_region"
	widgets.name.placeholder_text = "Region Filename"
	_apply_style(widgets.name)
	vbox.add_child(widgets.name)
	vbox.add_child(HSeparator.new())
	
	vbox.add_child(_lbl("Algorithm"))
	widgets.algo = OptionButton.new()
	var algos = ["Grid", "Maze", "Hub", "Crescent", "Ring", "Cavern", "Sector", "Highway", "Spiral", "Fractal", "River", "Target", "Empty"]
	for i in range(algos.size()): widgets.algo.add_item(algos[i], i + 1)
	widgets.algo.add_item("Empty", 0)
	_apply_style(widgets.algo)
	vbox.add_child(widgets.algo)
	vbox.add_child(HSeparator.new())
	
	container_dims = VBoxContainer.new(); vbox.add_child(container_dims)
	container_dims.add_child(_lbl("Parameters"))
	var dim_hbox = HBoxContainer.new()
	lbl_p1 = _lbl("Rows:"); dim_hbox.add_child(lbl_p1)
	widgets.p1 = SpinBox.new(); widgets.p1.value = 10; widgets.p1.max_value = 50; _apply_style(widgets.p1)
	dim_hbox.add_child(widgets.p1)
	slider_p1 = HSlider.new(); slider_p1.size_flags_horizontal = 3; slider_p1.visible = false
	lbl_p1_val = _lbl("10"); lbl_p1_val.visible = false
	dim_hbox.add_child(slider_p1); dim_hbox.add_child(lbl_p1_val)
	dim_hbox.add_child(VSeparator.new())
	lbl_p2 = _lbl("Cols:"); dim_hbox.add_child(lbl_p2)
	widgets.p2 = SpinBox.new(); widgets.p2.value = 10; widgets.p2.max_value = 50; _apply_style(widgets.p2)
	dim_hbox.add_child(widgets.p2)
	slider_p2 = HSlider.new(); slider_p2.size_flags_horizontal = 3; slider_p2.visible = false
	lbl_p2_val = _lbl("0"); lbl_p2_val.visible = false
	dim_hbox.add_child(slider_p2); dim_hbox.add_child(lbl_p2_val)
	container_dims.add_child(dim_hbox)
	container_dims.add_child(HSeparator.new())
	
	container_density = VBoxContainer.new(); vbox.add_child(container_density)
	lbl_s1 = _lbl("Room Density"); container_density.add_child(lbl_s1)
	var hb1 = HBoxContainer.new()
	slider_density = HSlider.new(); slider_density.size_flags_horizontal = 3; slider_density.min_value = 0.0; slider_density.max_value = 1.0; slider_density.step = 0.05; slider_density.value = 0.65
	lbl_density_val = _lbl("0.65"); lbl_density_val.custom_minimum_size.x = 40
	slider_density.value_changed.connect(func(v): lbl_density_val.text = str(v))
	hb1.add_child(slider_density); hb1.add_child(lbl_density_val); container_density.add_child(hb1)
	
	lbl_s2 = _lbl("Connection Density"); container_density.add_child(lbl_s2)
	var hb2 = HBoxContainer.new()
	slider_conns = HSlider.new(); slider_conns.size_flags_horizontal = 3; slider_conns.min_value = 0.0; slider_conns.max_value = 1.0; slider_conns.step = 0.05; slider_conns.value = 0.5
	lbl_conns_val = _lbl("0.5"); lbl_conns_val.custom_minimum_size.x = 40
	slider_conns.value_changed.connect(func(v): lbl_conns_val.text = str(v))
	hb2.add_child(slider_conns); hb2.add_child(lbl_conns_val); container_density.add_child(hb2)
	vbox.add_child(HSeparator.new())
	
	widgets.algo.item_selected.connect(func(i): _update_creator_labels(); _update_gen_preview())
	widgets.p1.value_changed.connect(func(v): _update_gen_preview())
	widgets.p2.value_changed.connect(func(v): _update_gen_preview())
	slider_p1.value_changed.connect(func(v): lbl_p1_val.text = str(v); _update_gen_preview())
	slider_p2.value_changed.connect(func(v): lbl_p2_val.text = str(v); _update_gen_preview())
	slider_density.value_changed.connect(func(v): _update_gen_preview())
	slider_conns.value_changed.connect(func(v): _update_gen_preview())
	
	var btn_gen = Button.new(); btn_gen.text = "Roll / Generate Preview"; 
	_apply_style(btn_gen, Color(0.2, 0.2, 0.3))
	btn_gen.pressed.connect(_update_gen_preview)
	vbox.add_child(btn_gen)
	
	var btn_create = Button.new(); btn_create.text = "Accept & Create"; btn_create.size_flags_vertical = 10
	_apply_style(btn_create, Color(0.2, 0.3, 0.2))
	btn_create.pressed.connect(func(): 
		if _temp_generated_rooms.is_empty() and widgets.algo.get_item_id(widgets.algo.selected) != RegionGenerator.Algo.EMPTY:
			_update_gen_preview() 
		request_create_region.emit(widgets.name.text, _temp_generated_rooms)
		hide()
	)
	vbox.add_child(btn_create)
	
	var btn_c = Button.new(); btn_c.text = "Cancel"; 
	btn_c.pressed.connect(func(): hide())
	_apply_style(btn_c)
	vbox.add_child(btn_c)

	var prev_panel = PanelContainer.new()
	prev_panel.size_flags_horizontal = 3
	prev_panel.size_flags_stretch_ratio = 1.5
	var prev_style = StyleBoxFlat.new(); prev_style.bg_color = Color(0.05, 0.05, 0.05); prev_style.set_border_width_all(1); prev_style.border_color = Color(0.3, 0.3, 0.3)
	prev_panel.add_theme_stylebox_override("panel", prev_style)
	main_hbox.add_child(prev_panel)
	
	generator_preview = Control.new()
	generator_preview.set_script(PREVIEW_SCRIPT)
	prev_panel.add_child(generator_preview)
	
	_update_creator_labels()
	visibility_changed.connect(func(): if visible: _update_gen_preview())

func _get_gen_params() -> Dictionary:
	var p1_val = widgets.p1.value if widgets.p1.visible else slider_p1.value
	var p2_val = widgets.p2.value if widgets.p2.visible else slider_p2.value
	return { "rows": int(p1_val), "cols": int(p2_val), "room_density": slider_density.value, "conn_density": slider_conns.value }

func _update_gen_preview():
	var algo = widgets.algo.get_item_id(widgets.algo.selected)
	var params = _get_gen_params()
	_temp_generated_rooms = RegionGenerator.generate(algo, params)
	generator_preview.update_preview(_temp_generated_rooms)

func _update_creator_labels():
	var id = widgets.algo.get_item_id(widgets.algo.selected)
	container_dims.visible = true; container_density.visible = true; lbl_s1.visible = true; slider_density.visible = true; lbl_density_val.visible = true
	widgets.p1.visible = true; slider_p1.visible = false; lbl_p1_val.visible = false
	widgets.p2.visible = true; slider_p2.visible = false; lbl_p2_val.visible = false
	match id:
		RegionGenerator.Algo.GRID:
			lbl_p1.text = "Rows:"; lbl_p2.text = "Cols:"; lbl_s1.text = "Room Density:"; lbl_s2.text = "Connection Density:"
		RegionGenerator.Algo.MAZE:
			lbl_p1.text = "Width:"; lbl_p2.text = "Height:"; lbl_s1.visible = false; slider_density.visible = false; lbl_density_val.visible = false; lbl_s2.text = "Loop Chance (Braiding):"
		RegionGenerator.Algo.HUB:
			lbl_p1.text = "Max Radius:"; lbl_p2.text = "(Unused)"; lbl_s1.text = "Branching %:"; lbl_s2.text = "Webbing (Connect %):"
		RegionGenerator.Algo.CRESCENT:
			widgets.p1.visible = false; slider_p1.visible = true; lbl_p1_val.visible = true
			widgets.p2.visible = false; slider_p2.visible = true; lbl_p2_val.visible = true
			slider_p1.min_value = 5; slider_p1.max_value = 50; slider_p2.min_value = 0; slider_p2.max_value = 360
			lbl_p1.text = "Diameter:"; lbl_p2.text = "Rotation (Deg):"; lbl_s1.text = "Thickness:"; lbl_s2.text = "Connect %:"
		RegionGenerator.Algo.RING:
			lbl_p1.text = "Rings Count:"; lbl_p2.text = "(Unused)"; lbl_s1.visible = false; slider_density.visible = false; lbl_density_val.visible = false; lbl_s2.text = "Gate Density (Bridges):"
		RegionGenerator.Algo.TARGET:
			lbl_p1.text = "Rings Count:"; lbl_p2.text = "(Unused)"; lbl_s1.visible = false; slider_density.visible = false; lbl_density_val.visible = false; lbl_s2.text = "Gate Density (Bridges):"
		RegionGenerator.Algo.CAVERN:
			lbl_p1.text = "Width:"; lbl_p2.text = "Height:"; lbl_s1.text = "Initial Fill:"; lbl_s2.text = "Connect %:"
		RegionGenerator.Algo.SECTOR:
			lbl_p1.text = "Width:"; lbl_p2.text = "Height:"; lbl_s1.text = "Min Room Size:"; lbl_s2.text = "(Unused)"
		RegionGenerator.Algo.HIGHWAY:
			widgets.p2.visible = false; slider_p2.visible = true; lbl_p2_val.visible = true
			slider_p2.min_value = 0; slider_p2.max_value = 360
			lbl_p1.text = "Length:"; lbl_p2.text = "Angle:"; lbl_s1.text = "Town Freq:"; lbl_s2.text = "Winding:"
		RegionGenerator.Algo.SPIRAL:
			lbl_p1.text = "Max Steps:"; lbl_p2.text = "(Unused)"; lbl_s1.text = "Direction (Left/Right):"; lbl_s2.text = "Shortcuts %:"
		RegionGenerator.Algo.FRACTAL:
			lbl_p1.text = "Room Count:"; lbl_p2.text = "Max Branches:"; widgets.p2.max_value = 4; lbl_s1.text = "(Unused)"; lbl_s2.text = "Cross-Connect %:"
		RegionGenerator.Algo.RIVER:
			lbl_p1.text = "Length:"; lbl_p2.text = "Width:"; lbl_s1.text = "(Unused)"; lbl_s2.text = "Weaving/Merging:"
		RegionGenerator.Algo.EMPTY:
			container_dims.visible = false; container_density.visible = false

func _apply_style(node: Control, bg_color = Color(0.15, 0.15, 0.18)):
	var style = StyleBoxFlat.new()
	style.bg_color = bg_color
	style.set_border_width_all(1)
	style.border_color = Color(0.4, 0.4, 0.45)
	style.set_corner_radius_all(4)
	style.content_margin_left = 8
	style.content_margin_right = 8
	style.content_margin_top = 4
	style.content_margin_bottom = 4
	if node is Button:
		node.add_theme_stylebox_override("normal", style)
		node.add_theme_stylebox_override("hover", style.duplicate())
		node.add_theme_stylebox_override("pressed", style.duplicate())
		node.get_theme_stylebox("hover").bg_color = bg_color.lightened(0.1)
		node.get_theme_stylebox("pressed").bg_color = bg_color.darkened(0.1)
	elif node is LineEdit or node is SpinBox:
		style.bg_color = Color(0.08, 0.08, 0.1)
		node.add_theme_stylebox_override("normal", style)

func _lbl(t, c=Color.WHITE): 
	var l = Label.new()
	l.text = t
	l.modulate = c
	return l
# scripts/ui/panels/ExplorerPanel.gd

class_name ExplorerPanel
extends VBoxContainer

signal request_load_region(filename)
signal request_jump_to_room(id)
signal request_create_modal_open
signal request_validate
signal request_auto_layout
signal snap_toggled(enabled)
signal request_context_menu(global_pos, meta)

var search_bar: LineEdit
var explorer_tree: Tree
var snap_checkbox: CheckBox
var expanded_regions: Dictionary = {}
var _is_programmatic_selection: bool = false

func setup():
	# Increase spacing between elements (Search Bar <-> Tree <-> Buttons)
	add_theme_constant_override("separation", 12)
	
	search_bar = LineEdit.new()
	search_bar.placeholder_text = "Filter..."
	_apply_style(search_bar)
	search_bar.text_changed.connect(func(_t): refresh_tree())
	add_child(search_bar)
	
	explorer_tree = Tree.new()
	explorer_tree.size_flags_vertical = SIZE_EXPAND_FILL
	explorer_tree.hide_root = true
	
	# Select the whole row to make clicking easier
	explorer_tree.select_mode = Tree.SELECT_ROW
	explorer_tree.allow_rmb_select = true
	
	explorer_tree.item_selected.connect(_on_tree_select)
	explorer_tree.item_activated.connect(_on_tree_activate)
	explorer_tree.item_collapsed.connect(_on_tree_collapse)
	
	# SWITCH to gui_input for reliable right-click detection
	explorer_tree.gui_input.connect(_on_tree_gui_input)
	
	var tree_style = StyleBoxFlat.new()
	tree_style.bg_color = Color(0.05, 0.05, 0.08)
	explorer_tree.add_theme_stylebox_override("bg", tree_style)
	add_child(explorer_tree)
	
	snap_checkbox = CheckBox.new()
	snap_checkbox.text = "Snap to Grid"
	snap_checkbox.button_pressed = true
	_apply_checkbox_style(snap_checkbox)
	snap_checkbox.toggled.connect(func(b): snap_toggled.emit(b))
	add_child(snap_checkbox)
	
	call_deferred("emit_signal", "snap_toggled", snap_checkbox.button_pressed)
	
	var btn_row = HBoxContainer.new()
	btn_row.add_theme_constant_override("separation", 8)
	var btn_new = Button.new(); btn_new.text="New Region"; btn_new.size_flags_horizontal=3
	btn_new.pressed.connect(func(): request_create_modal_open.emit())
	_apply_style(btn_new)
	btn_row.add_child(btn_new)
	
	var btn_val = Button.new(); btn_val.text="Validate"; btn_val.size_flags_horizontal=3
	btn_val.pressed.connect(func(): request_validate.emit())
	_apply_style(btn_val)
	btn_row.add_child(btn_val)
	add_child(btn_row)
	
	var btn_layout = Button.new(); btn_layout.text="Auto-Arrange Layout"
	_apply_style(btn_layout, Color(0.2, 0.25, 0.3))
	btn_layout.pressed.connect(func(): request_auto_layout.emit())
	add_child(btn_layout)

# --- INPUT HANDLERS ---

func _on_tree_gui_input(event: InputEvent):
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_RIGHT and event.pressed:
			var pos = event.position
			var item = explorer_tree.get_item_at_position(pos)
			if item:
				if not item.is_selected(0):
					_is_programmatic_selection = true
					item.select(0)
					_is_programmatic_selection = false
				
				var meta = item.get_metadata(0)
				request_context_menu.emit(get_global_mouse_position(), meta)
				get_viewport().set_input_as_handled()

# --- PUBLIC API ---

var _current_hierarchy: Dictionary = {}
var _current_filename: String = ""
var _selected_id: String = ""
var _is_reg_dirty: bool = false
var _dirty_rooms: Dictionary = {}

func update_data(hierarchy: Dictionary, current_file: String, selected_id: String):
	_current_hierarchy = hierarchy
	_current_filename = current_file
	_selected_id = selected_id
	refresh_tree()

func update_dirty_visuals(current_file: String, is_reg_dirty: bool, dirty_rooms: Dictionary):
	_current_filename = current_file
	_is_reg_dirty = is_reg_dirty
	_dirty_rooms = dirty_rooms
	refresh_tree()

func update_layout_btn_text(is_world: bool):
	var btn = get_child(get_child_count()-1) as Button
	if btn: btn.text = "Auto-Arrange World" if is_world else "Auto-Arrange Rooms"

func select_room_item(room_id: String):
	_selected_id = room_id
	var root = explorer_tree.get_root()
	if not root: return
	
	for region_item in root.get_children():
		for room_item in region_item.get_children():
			var meta = room_item.get_metadata(0)
			if meta and meta.id == room_id:
				if region_item.collapsed:
					region_item.collapsed = false
				
				_is_programmatic_selection = true
				room_item.select(0)
				_is_programmatic_selection = false
				explorer_tree.scroll_to_item(room_item, true)
				return

# --- INTERNAL LOGIC ---

func refresh_tree():
	explorer_tree.clear()
	var root = explorer_tree.create_item()
	var filter = search_bar.text
	
	var regions = _current_hierarchy.keys()
	regions.sort()
	
	for rid in regions:
		var r_data = _current_hierarchy[rid]
		var match_reg = filter.is_empty() or rid.contains(filter)
		var match_rooms = []
		for r_id in r_data.rooms:
			var r_name = str(r_data.rooms[r_id])
			if match_reg or r_id.contains(filter) or r_name.contains(filter):
				match_rooms.append(r_id)
		
		if not match_reg and match_rooms.is_empty(): continue
		
		match_rooms.sort_custom(func(a, b): 
			var name_a = str(r_data.rooms[a])
			var name_b = str(r_data.rooms[b])
			var name_cmp = name_a.nocasecmp_to(name_b)
			if name_cmp != 0:
				return name_cmp < 0
			return a.nocasecmp_to(b) < 0
		)
		
		var item = explorer_tree.create_item(root)
		
		var display_name = rid.capitalize()
		var is_current = (r_data.filename == _current_filename)
		
		if is_current and _is_reg_dirty:
			item.set_text(0, display_name + " (*)")
			item.set_custom_color(0, Color(1.0, 0.9, 0.6))
		else:
			item.set_text(0, display_name)
			item.set_custom_color(0, Color(0.7, 0.8, 1.0))
			
		item.set_metadata(0, {"type": "region", "file": r_data.filename, "id": rid})
		item.collapsed = not (expanded_regions.get(rid, false) or filter != "")
		
		for r_id in match_rooms:
			var r_item = explorer_tree.create_item(item)
			var r_name = str(r_data.rooms[r_id])
			
			if is_current and _dirty_rooms.has(r_id):
				r_item.set_text(0, r_name + " (*)")
				r_item.set_custom_color(0, Color(1.0, 0.9, 0.6))
			else:
				r_item.set_text(0, r_name)
				if r_id == _selected_id and is_current:
					r_item.set_custom_color(0, Color.GREEN)
			
			r_item.set_tooltip_text(0, r_id)
			r_item.set_metadata(0, {"type": "room", "file": r_data.filename, "id": r_id})

func _on_tree_select():
	if _is_programmatic_selection: return
	var item = explorer_tree.get_selected()
	if not item: return
	var meta = item.get_metadata(0)
	if meta.type == "region": 
		request_load_region.emit(meta.file)
	else: 
		request_load_region.emit(meta.file)
		request_jump_to_room.emit(meta.id)

func _on_tree_activate():
	var item = explorer_tree.get_selected()
	if not item: return
	if item.get_metadata(0).type == "region": 
		item.collapsed = !item.collapsed
		_on_tree_collapse(item)

func _on_tree_collapse(item):
	var meta = item.get_metadata(0)
	if meta.type == "region": expanded_regions[meta.id] = not item.collapsed

func _apply_style(node: Control, bg_color = Color(0.15, 0.15, 0.18)):
	var s = StyleBoxFlat.new(); s.bg_color = bg_color; s.set_border_width_all(1); s.border_color = Color(0.4, 0.4, 0.45); s.set_corner_radius_all(4)
	s.content_margin_left = 8; s.content_margin_right = 8; s.content_margin_top = 4; s.content_margin_bottom = 4
	if node is Button:
		node.add_theme_stylebox_override("normal", s)
		node.add_theme_stylebox_override("hover", s.duplicate())
		node.add_theme_stylebox_override("pressed", s.duplicate())
		node.get_theme_stylebox("hover").bg_color = bg_color.lightened(0.1)
		node.get_theme_stylebox("pressed").bg_color = bg_color.darkened(0.1)
	elif node is LineEdit:
		var s2 = s.duplicate(); s2.bg_color = Color(0.08, 0.08, 0.1); node.add_theme_stylebox_override("normal", s2)

func _apply_checkbox_style(node: CheckBox):
	node.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8))
	node.add_theme_color_override("font_hover_color", Color.WHITE)
	node.add_theme_color_override("font_pressed_color", Color(0.6, 1.0, 0.6))
	node.add_theme_constant_override("hseparation", 8) 
	var s = StyleBoxFlat.new(); s.bg_color = Color(0.15, 0.15, 0.18)
	s.set_border_width_all(1); s.border_color = Color(0.4, 0.4, 0.45); s.set_corner_radius_all(4)
	s.content_margin_left=4; s.content_margin_right=4
	var s_unchecked = s.duplicate(); s_unchecked.bg_color = Color(0.25, 0.1, 0.1)
	var s_checked = s.duplicate(); s_checked.bg_color = Color(0.1, 0.3, 0.15)
	node.add_theme_stylebox_override("normal", s_unchecked)
	node.add_theme_stylebox_override("pressed", s_checked)
	node.add_theme_stylebox_override("hover", s_unchecked.duplicate())
	node.get_theme_stylebox("hover").bg_color = s_unchecked.bg_color.lightened(0.1)
# scripts/ui/panels/GeneratorPreview.gd
extends Control

var current_rooms: Dictionary = {}
# Neutral Beige/Tan
const PREVIEW_COLOR = Color(0.82, 0.78, 0.65) 
const BG_COLOR = Color(0.1, 0.1, 0.15)
# Must match RegionGenerator
const REF_GRID_SIZE = Vector2(250, 250) 

func update_preview(rooms: Dictionary):
	current_rooms = rooms
	queue_redraw()

func _draw():
	draw_rect(get_rect(), BG_COLOR)
	
	# 1. Calculate Bounds
	var min_p = Vector2(INF, INF)
	var max_p = Vector2(-INF, -INF)
	
	if not current_rooms.is_empty():
		for id in current_rooms:
			var r = current_rooms[id]
			var p = _get_pos(r)
			min_p.x = min(min_p.x, p.x)
			min_p.y = min(min_p.y, p.y)
			max_p.x = max(max_p.x, p.x)
			max_p.y = max(max_p.y, p.y)
	else:
		# Default bounds for empty grid
		min_p = Vector2(-500, -500)
		max_p = Vector2(500, 500)

	var content_size = max_p - min_p
	# Force a minimum size to prevent div/0 or massive scaling on single nodes
	content_size.x = max(content_size.x, REF_GRID_SIZE.x)
	content_size.y = max(content_size.y, REF_GRID_SIZE.y)
	
	# 2. Calculate Scale
	var margin = 40.0
	var avail = size - Vector2(margin * 2, margin * 2)
	
	var scale_x = avail.x / content_size.x
	var scale_y = avail.y / content_size.y
	var scale_fac = min(scale_x, scale_y)
	scale_fac = clamp(scale_fac, 0.02, 1.0) 
	
	var grid_center = min_p + (max_p - min_p) / 2.0
	var center_offset = (size / 2.0) - (grid_center * scale_fac)

	# 3. Draw Background Grid Lines (Visual Aid)
	var grid_step = REF_GRID_SIZE * scale_fac
	# Start drawing from center out to cover visible area
	var center_screen = size / 2.0
	var steps_x = int(size.x / grid_step.x) + 2
	var steps_y = int(size.y / grid_step.y) + 2
	var grid_col = Color(1, 1, 1, 0.05)
	
	# Find start point aligned to grid
	var start_x = fmod(center_offset.x, grid_step.x)
	var start_y = fmod(center_offset.y, grid_step.y)
	
	for i in range(steps_x):
		var x = start_x + i * grid_step.x
		draw_line(Vector2(x, 0), Vector2(x, size.y), grid_col)
	for i in range(steps_y):
		var y = start_y + i * grid_step.y
		draw_line(Vector2(0, y), Vector2(size.x, y), grid_col)

	# 4. Draw Connections
	for id in current_rooms:
		var r = current_rooms[id]
		var draw_pos = (_get_pos(r) * scale_fac) + center_offset
		
		if r.has("exits"):
			for dir in r.exits:
				var target_id = r.exits[dir]
				if ":" in target_id or not current_rooms.has(target_id): continue
				
				if dir in ["south", "east", "southeast", "southwest"]:
					var t_r = current_rooms[target_id]
					var t_draw_pos = (_get_pos(t_r) * scale_fac) + center_offset
					draw_line(draw_pos, t_draw_pos, Color.WHITE, 2.0)

	# 5. Draw Nodes
	var node_draw_size = REF_GRID_SIZE * scale_fac * 0.6 
	var square_dim = min(node_draw_size.x, node_draw_size.y)
	var final_size = Vector2(square_dim, square_dim)
	
	for id in current_rooms:
		var r = current_rooms[id]
		var draw_pos = (_get_pos(r) * scale_fac) + center_offset
		var rect = Rect2(draw_pos - final_size/2, final_size)
		draw_rect(rect, PREVIEW_COLOR)

func _get_pos(r: Dictionary) -> Vector2:
	if r["_editor_pos"] is Array:
		return Vector2(r["_editor_pos"][0], r["_editor_pos"][1])
	return r["_editor_pos"]
# scripts/ui/graph/GridLayer.gd
class_name GridLayer
extends Node2D

var camera: Camera2D
var grid_step: int = 32
var grid_color: Color = Color(1, 1, 1, 0.05)
var axis_color: Color = Color(1, 1, 1, 0.1)

func setup(_camera: Camera2D):
	camera = _camera

func _draw():
	# Don't draw if hidden or camera isn't ready
	if not visible or not camera:
		return
		
	var vp_rect = get_viewport_rect()
	var cam_pos = camera.position
	var zm = camera.zoom
	
	# Calculate visible world bounds, expanded slightly to prevent edge popping
	var visible_size = vp_rect.size / zm
	var tl = cam_pos - (visible_size / 2.0) - Vector2(grid_step, grid_step)
	var br = cam_pos + (visible_size / 2.0) + Vector2(grid_step, grid_step)
	
	# Snap start/end to grid
	var start_x = floor(tl.x / grid_step) * grid_step
	var end_x = ceil(br.x / grid_step) * grid_step
	var start_y = floor(tl.y / grid_step) * grid_step
	var end_y = ceil(br.y / grid_step) * grid_step
	
	var points = PackedVector2Array()
	
	# Vertical Lines
	for x in range(start_x, end_x, grid_step):
		if x == 0: continue # Skip axis for special color later
		points.append(Vector2(x, tl.y))
		points.append(Vector2(x, br.y))
		
	# Horizontal Lines
	for y in range(start_y, end_y, grid_step):
		if y == 0: continue # Skip axis
		points.append(Vector2(tl.x, y))
		points.append(Vector2(br.x, y))
		
	# Draw the massive batch of lines
	draw_multiline(points, grid_color)
	
	# Draw Origin Axes if visible
	if start_x <= 0 and end_x >= 0:
		draw_line(Vector2(0, tl.y), Vector2(0, br.y), axis_color, 2.0)
	if start_y <= 0 and end_y >= 0:
		draw_line(Vector2(tl.x, 0), Vector2(br.x, 0), axis_color, 2.0)
# scripts/ui/graph/GraphRenderer.gd
class_name GraphRenderer
extends RefCounted

# Constants for visual tweaking
const LINE_WIDTH = 3.0
const LINE_BORDER_WIDTH = 4.0
const ARROW_SIZE = 14.0
const LABEL_FONT_SIZE = 12
const LABEL_BG_COLOR = Color(0.1, 0.1, 0.1, 0.9)
const LABEL_BORDER_COLOR = Color(0.4, 0.4, 0.4, 1.0)

# Colors
const COL_DEF = Color(0.7, 0.7, 0.7, 1.0)
const COL_TWO_WAY = Color(1.0, 1.0, 1.0, 1.0)
const COL_UP = Color(0.2, 0.8, 1.0, 1.0)
const COL_DOWN = Color(0.8, 0.4, 0.2, 1.0)
const COL_HL = Color(1, 0.8, 0.2, 1.0)
const COL_ONE_WAY = Color(1.0, 0.3, 0.3, 1.0)
const COL_OUTLINE = Color(0.0, 0.0, 0.0, 0.8)

# Specific Direction Colors
const COL_IN_OUT = Color(0.7, 0.4, 0.9, 1.0)
const COL_DIAG = Color(0.4, 0.8, 0.4, 1.0)
const COL_CARDINAL = Color(0.3, 0.6, 0.9, 1.0)

static var label_style: StyleBoxFlat

static func _get_label_style() -> StyleBoxFlat:
	if not label_style:
		label_style = StyleBoxFlat.new()
		label_style.bg_color = LABEL_BG_COLOR
		label_style.set_corner_radius_all(4)
		label_style.set_border_width_all(1)
		label_style.border_color = LABEL_BORDER_COLOR
		label_style.content_margin_left = 6
		label_style.content_margin_right = 6
		label_style.content_margin_top = 2
		label_style.content_margin_bottom = 2
	return label_style

static func draw_graph(canvas: Node2D, nodes: Dictionary, data: Dictionary, selected_id: String, drag_line: Dictionary):
	var font = ThemeDB.get_fallback_font()
	var rooms = data.get("rooms", {})
	var drawn_pairs = {} 
	var style = _get_label_style()

	if drag_line.get("active", false):
		var start = canvas.to_local(drag_line.get("start", Vector2.ZERO))
		var end = canvas.to_local(drag_line.get("end", Vector2.ZERO))
		canvas.draw_line(start, end, Color.BLACK, LINE_WIDTH + 4.0)
		canvas.draw_dashed_line(start, end, Color.LIME_GREEN, LINE_WIDTH, 10.0)

	for rid in nodes:
		if not rooms.has(rid): continue 

		var node = nodes[rid]
		var exits = rooms[rid].get("exits", {})
		
		for dir in exits:
			var target_str = exits[dir]
			var is_external = ":" in target_str
			
			var target_node = null
			if nodes.has(target_str):
				target_node = nodes[target_str]

			var start_global = Vector2.ZERO
			if node.has_method("get_connection_anchor_point"):
				start_global = node.get_connection_anchor_point(dir)
			else:
				start_global = node.global_position
			
			var start = canvas.to_local(start_global)
			var end_global = Vector2.ZERO
			var end = Vector2.ZERO
			
			if target_node:
				var reverse_dir = Constants.INV_DIR_MAP.get(dir.to_lower(), "")
				if target_node.has_method("get_connection_anchor_point") and reverse_dir != "":
					end_global = target_node.get_connection_anchor_point(reverse_dir)
				else:
					end_global = target_node.global_position
				end = canvas.to_local(end_global)

			if target_node:
				var is_two_way = false
				var rev_dir = ""
				
				if not is_external and rooms.has(target_str):
					var target_exits = rooms[target_str].get("exits", {})
					for t_dir in target_exits:
						if target_exits[t_dir] == rid:
							is_two_way = true
							rev_dir = t_dir
							break

				var pair_key = [rid, target_str]
				pair_key.sort()
				if is_two_way and drawn_pairs.has(pair_key):
					continue
				if is_two_way: drawn_pairs[pair_key] = true

				var is_hl = (rid == selected_id or target_str == selected_id)
				
				# Color Selection
				var d_lower = dir.to_lower()
				var line_col = COL_DEF
				
				if d_lower in ["north", "south", "east", "west", "n", "s", "e", "w"]:
					line_col = COL_CARDINAL
				elif d_lower in ["up", "climb"]:
					line_col = COL_UP
				elif d_lower in ["down", "dive"]:
					line_col = COL_DOWN
				elif d_lower in ["in", "out"]:
					line_col = COL_IN_OUT
				else:
					line_col = COL_DIAG
				
				if not is_two_way: line_col = COL_ONE_WAY
				if is_hl: line_col = COL_HL
				
				# Determine if curved
				var is_curved_type = d_lower in ["up", "down", "climb", "dive", "in", "out"]

				if is_curved_type:
					_draw_curve_connection(canvas, start, end, line_col, is_hl, is_two_way, dir, rev_dir, font, style)
				else:
					_draw_straight_connection(canvas, start, end, line_col, is_hl, is_two_way, dir, rev_dir, font, style, is_external)

			else:
				var stub_col = COL_DEF
				var d_l = dir.to_lower()
				if d_l in ["up", "climb"]: stub_col = COL_UP
				elif d_l in ["down", "dive"]: stub_col = COL_DOWN
				elif d_l in ["in", "out"]: stub_col = COL_IN_OUT
				
				canvas.draw_circle(start, 4.0, stub_col)
				var stub_vec = Constants.DIR_VECTORS.get(d_l, Vector2(1,0))
				var stub_end = start + (stub_vec * 35.0)
				canvas.draw_line(start, stub_end, stub_col, LINE_WIDTH)
				_draw_label_rotated(canvas, font, style, (start + stub_end)/2.0, dir.capitalize(), stub_vec.angle())

static func _draw_straight_connection(c: Node2D, from: Vector2, to: Vector2, col: Color, highlight: bool, two_way: bool, dir1: String, dir2: String, font: Font, style: StyleBox, is_external: bool):
	var w = LINE_WIDTH + (2.0 if highlight else 0.0)
	var dir_vec = (to - from).normalized()
	var line_end = to
	
	# Calculate shortened line end for one-way arrows to prevent overlap
	if not two_way:
		# Arrow occupies roughly 1.1 * ARROW_SIZE from the tip backwards
		# (0.6 for center offset + 0.5 for base width + margin)
		var arrow_space = ARROW_SIZE * 1.1
		var dist = from.distance_to(to)
		
		if dist > arrow_space:
			line_end = to - (dir_vec * arrow_space)
		else:
			line_end = from # Too close to draw line
	
	c.draw_line(from, line_end, COL_OUTLINE, w + LINE_BORDER_WIDTH)
	
	if is_external:
		c.draw_dashed_line(from, line_end, col, w, 8.0)
	else:
		c.draw_line(from, line_end, col, w)
	
	var mid = (from + to) / 2.0
	var angle = (to - from).angle()
	
	if not two_way:
		# Draw arrow at the destination (to)
		var arrow_pos = to - (dir_vec * ARROW_SIZE * 0.6)
		_draw_arrow_head(c, arrow_pos, dir_vec, col)
		
		_draw_label_rotated(c, font, style, mid, dir1.capitalize(), angle)
	else:
		# Check flip condition using fuzzy epsilon
		var needs_flip = angle > (PI / 2.0 - 0.001) or angle < (-PI / 2.0 - 0.001)
		var text = ""
		if needs_flip:
			text = "%s â†” %s" % [dir2.capitalize(), dir1.capitalize()]
		else:
			text = "%s â†” %s" % [dir1.capitalize(), dir2.capitalize()]
			
		_draw_label_rotated(c, font, style, mid, text, angle)

static func _draw_curve_connection(c: Node2D, from: Vector2, to: Vector2, col: Color, highlight: bool, two_way: bool, dir1: String, dir2: String, font: Font, style: StyleBox):
	var w = LINE_WIDTH + (2.0 if highlight else 0.0)
	var dist = from.distance_to(to)
	
	var dir_vec = (to - from).normalized()
	var perp = Vector2(-dir_vec.y, dir_vec.x)
	
	var curve_amount = min(dist * 0.5, 120.0)
	if curve_amount < 40.0: curve_amount = 40.0
	
	var control = (from + to) / 2.0 + (perp * curve_amount)
	
	var points = PackedVector2Array()
	var steps = 24
	for i in range(steps + 1):
		var t = float(i) / steps
		points.append(from.bezier_interpolate(control, control, to, t))
	
	c.draw_polyline(points, COL_OUTLINE, w + LINE_BORDER_WIDTH)
	c.draw_polyline(points, col, w)
	
	var mid_curve = from.bezier_interpolate(control, control, to, 0.5)
	
	# Approximate angle at midpoint for text rotation
	var t = 0.5
	var p0 = from; var p1 = control; var p2 = to
	var tangent = (2.0 * (1.0 - t) * (p1 - p0) + 2.0 * t * (p2 - p1)).normalized()
	var angle = tangent.angle()

	if two_way:
		var needs_flip = angle > (PI / 2.0 - 0.001) or angle < (-PI / 2.0 - 0.001)
		var text = ""
		if needs_flip:
			text = "%s â†” %s" % [dir2.capitalize(), dir1.capitalize()]
		else:
			text = "%s â†” %s" % [dir1.capitalize(), dir2.capitalize()]
		
		_draw_label_rotated(c, font, style, mid_curve, text, angle)
	else:
		_draw_label_rotated(c, font, style, mid_curve, dir1.capitalize(), angle)
		_draw_arrow_at_t(c, from, control, to, 0.9, col)

static func _draw_label_rotated(c: Node2D, font: Font, style: StyleBoxFlat, pos: Vector2, text: String, angle: float):
	var final_angle = angle
	
	# Consistency check: Flip if pointing generally Left or Down
	if final_angle > (PI / 2.0 - 0.001) or final_angle < (-PI / 2.0 - 0.001):
		final_angle += PI
	
	c.draw_set_transform(pos, final_angle, Vector2.ONE)
	var txt_size = font.get_string_size(text, HORIZONTAL_ALIGNMENT_CENTER, -1, LABEL_FONT_SIZE)
	var padding = Vector2(12, 4)
	var size = txt_size + padding
	var rect = Rect2(-size/2.0, size)
	
	c.draw_style_box(style, rect)
	var text_pos = Vector2(-txt_size.x / 2.0, txt_size.y * 0.25)
	c.draw_string(font, text_pos, text, HORIZONTAL_ALIGNMENT_CENTER, -1, LABEL_FONT_SIZE, Color.WHITE)
	c.draw_set_transform(Vector2.ZERO, 0.0, Vector2.ONE)

static func _draw_arrow_midpoint(c: Node2D, from: Vector2, to: Vector2, col: Color):
	var mid = (from + to) / 2.0
	var dir = (to - from).normalized()
	_draw_arrow_head(c, mid, dir, col)

static func _draw_arrow_at_t(c: Node2D, start: Vector2, control: Vector2, end: Vector2, t: float, col: Color):
	var p0 = start; var p1 = control; var p2 = end
	var tangent = (2.0 * (1.0 - t) * (p1 - p0) + 2.0 * t * (p2 - p1)).normalized()
	var pos = start.bezier_interpolate(control, control, end, t)
	_draw_arrow_head(c, pos, tangent, col)

static func _draw_arrow_head(c: Node2D, pos: Vector2, dir: Vector2, col: Color):
	var tip = pos + (dir * ARROW_SIZE * 0.5)
	var base = pos - (dir * ARROW_SIZE * 0.5)
	var perp = Vector2(-dir.y, dir.x) * (ARROW_SIZE * 0.5)
	var p1 = base + perp
	var p2 = base - perp
	c.draw_colored_polygon(PackedVector2Array([tip, p1, p2]), COL_OUTLINE)
	var s = 0.8
	var tip_s = pos + (dir * ARROW_SIZE * 0.5 * s)
	var base_s = pos - (dir * ARROW_SIZE * 0.5 * s)
	var perp_s = Vector2(-dir.y, dir.x) * (ARROW_SIZE * 0.5 * s)
	c.draw_colored_polygon(PackedVector2Array([tip_s, base_s + perp_s, base_s - perp_s]), col)
# scripts/ui/inspectors/ConnectionEditor.gd
class_name ConnectionEditor
extends RefCounted

signal connection_created(src, dir, target, twoway)
signal target_selected(target_id) # New signal to report the current target

# Data References
var conn_hierarchy: Dictionary = {}
var conn_src_id: String = ""
var conn_cur_reg_filename: String = ""

# GUI References
var conn_dir_edit: LineEdit
var conn_reg_opt: OptionButton
var conn_room_opt: OptionButton
var conn_twoway: CheckBox
var conn_info_label: RichTextLabel
var region_mgr: RegionManager

func _init(mgr: RegionManager):
	region_mgr = mgr

func build_ui(parent_container: Control, src_id: String, src_name: String, hierarchy: Dictionary, cur_filename: String, target_id: String = "", dir: String = ""):
	conn_src_id = src_id
	conn_hierarchy = hierarchy
	conn_cur_reg_filename = cur_filename
	
	_clear_box(parent_container)
	
	var header = _lbl("NEW CONNECTION", Color.CYAN)
	header.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	parent_container.add_child(header)
	parent_container.add_child(HSeparator.new())
	
	var src_lbl = _lbl("From: " + src_name, Color.GREEN)
	src_lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	parent_container.add_child(src_lbl)
	parent_container.add_child(HSeparator.new())
	
	# --- COMPASS UI ---
	var center_container = CenterContainer.new()
	parent_container.add_child(center_container)
	
	var nav_vbox = VBoxContainer.new()
	nav_vbox.add_theme_constant_override("separation", 8)
	center_container.add_child(nav_vbox)
	
	# 1. Cardinal Directions
	var compass = GridContainer.new()
	compass.columns = 3
	compass.add_theme_constant_override("h_separation", 6)
	compass.add_theme_constant_override("v_separation", 6)
	nav_vbox.add_child(compass)
	
	var compass_map = [
		{"l": "â†–", "v": "northwest"}, {"l": "â†‘", "v": "north"}, {"l": "â†—", "v": "northeast"},
		{"l": "â†", "v": "west"},      {"l": "â€¢", "v": ""},      {"l": "â†’", "v": "east"},
		{"l": "â†™", "v": "southwest"}, {"l": "â†“", "v": "south"}, {"l": "â†˜", "v": "southeast"}
	]
	
	for item in compass_map:
		if item.v == "":
			var lbl = Label.new(); lbl.text = "â€¢"; lbl.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER; lbl.vertical_alignment = VERTICAL_ALIGNMENT_CENTER; lbl.modulate = Color(1, 1, 1, 0.3)
			compass.add_child(lbl)
		else:
			var btn = Button.new(); btn.text = item.l; btn.tooltip_text = item.v.capitalize(); 
			btn.custom_minimum_size = Vector2(40, 40); btn.alignment = HORIZONTAL_ALIGNMENT_CENTER
			_apply_style(btn); btn.add_theme_font_size_override("font_size", 18) 
			btn.pressed.connect(func(): conn_dir_edit.text = item.v; _update_connection_info())
			compass.add_child(btn)
	
	# 2. Vertical Directions
	var vertical_grid = GridContainer.new()
	vertical_grid.columns = 2
	vertical_grid.add_theme_constant_override("h_separation", 8)
	vertical_grid.add_theme_constant_override("v_separation", 8)
	nav_vbox.add_child(vertical_grid)
	
	var verticals = ["up", "down", "in", "out", "climb", "dive"]
	for d in verticals:
		var btn = Button.new(); btn.text = d.capitalize(); 
		btn.custom_minimum_size = Vector2(65, 35); btn.alignment = HORIZONTAL_ALIGNMENT_CENTER
		_apply_style(btn); btn.pressed.connect(func(): conn_dir_edit.text = d; _update_connection_info())
		vertical_grid.add_child(btn)

	# --- MANUAL ENTRY ---
	var dir_hbox = HBoxContainer.new()
	conn_dir_edit = LineEdit.new()
	conn_dir_edit.placeholder_text = "Custom Direction..."
	conn_dir_edit.alignment = HORIZONTAL_ALIGNMENT_CENTER
	conn_dir_edit.size_flags_horizontal = 3
	conn_dir_edit.text = dir
	conn_dir_edit.text_changed.connect(func(_t): _update_connection_info())
	_apply_style(conn_dir_edit)
	dir_hbox.add_child(conn_dir_edit)
	parent_container.add_child(dir_hbox)
	
	parent_container.add_child(HSeparator.new())
	
	# --- TARGET UI ---
	parent_container.add_child(_lbl("Target Region:", Color.GRAY))
	conn_reg_opt = OptionButton.new(); conn_reg_opt.size_flags_horizontal = Control.SIZE_EXPAND_FILL; _apply_style(conn_reg_opt)
	conn_reg_opt.item_selected.connect(_on_conn_region_changed)
	parent_container.add_child(conn_reg_opt)
	
	parent_container.add_child(_lbl("Target Room:", Color.GRAY))
	conn_room_opt = OptionButton.new(); conn_room_opt.size_flags_horizontal = Control.SIZE_EXPAND_FILL; _apply_style(conn_room_opt)
	conn_room_opt.item_selected.connect(func(_i): _update_connection_info())
	parent_container.add_child(conn_room_opt)
	
	conn_twoway = CheckBox.new(); conn_twoway.text = "Two-way Link"; conn_twoway.button_pressed = true
	conn_twoway.toggled.connect(func(_b): _update_connection_info())
	_apply_style(conn_twoway)
	parent_container.add_child(conn_twoway)
	
	# --- INFO & WARNINGS ---
	conn_info_label = RichTextLabel.new(); conn_info_label.fit_content = true; conn_info_label.bbcode_enabled = true
	_apply_style(conn_info_label, Color.TRANSPARENT); parent_container.add_child(conn_info_label)
	
	parent_container.add_child(HSeparator.new())
	
	# --- BUTTONS ---
	var btn_box = HBoxContainer.new()
	btn_box.add_theme_constant_override("separation", 10)
	var margin_c = MarginContainer.new() 
	margin_c.add_theme_constant_override("margin_left", 2)
	margin_c.add_theme_constant_override("margin_right", 2)
	margin_c.add_child(btn_box)
	
	var btn = Button.new(); btn.text = "Connect"; btn.size_flags_horizontal = 3
	btn.pressed.connect(_on_connect_confirm); _apply_style(btn, Color(0.2, 0.35, 0.2))
	btn_box.add_child(btn)
	
	var btn_close = Button.new(); btn_close.text = "Cancel"; btn_close.size_flags_horizontal = 3
	btn_close.pressed.connect(func(): target_selected.emit(""))
	_apply_style(btn_close, Color(0.3, 0.1, 0.1))
	btn_box.add_child(btn_close)
	
	parent_container.add_child(margin_c)
	
	_populate_connection_data(target_id)
	
	if target_id == "":
		conn_dir_edit.grab_focus()

func set_target(region_id: String, room_id: String):
	# 1. Select Region
	var region_found = false
	for i in range(conn_reg_opt.item_count):
		if conn_reg_opt.get_item_metadata(i) == region_id:
			conn_reg_opt.select(i)
			_on_conn_region_changed(i)
			region_found = true
			break
	if not region_found: return
	# 2. Select Room
	var room_found = false
	for i in range(conn_room_opt.item_count):
		if conn_room_opt.get_item_metadata(i) == room_id:
			conn_room_opt.select(i)
			room_found = true
			break
	if room_found:
		_update_connection_info()

func _populate_connection_data(target_id_raw: String):
	conn_reg_opt.clear()
	var regions = conn_hierarchy.keys()
	regions.sort()
	
	var selected_idx = -1
	var idx = 0
	var cur_reg_id = ""
	
	for r in regions:
		if conn_hierarchy[r].filename == conn_cur_reg_filename:
			cur_reg_id = r
			break
			
	for r in regions:
		conn_reg_opt.add_item(r.capitalize()) 
		conn_reg_opt.set_item_metadata(idx, r)
		if r == cur_reg_id:
			selected_idx = idx
		idx += 1
		
	var target_reg = cur_reg_id
	var target_room = target_id_raw
	if ":" in target_id_raw:
		var parts = target_id_raw.split(":")
		target_reg = parts[0]
		target_room = parts[1]
	
	for i in range(conn_reg_opt.item_count):
		if conn_reg_opt.get_item_metadata(i) == target_reg:
			selected_idx = i
			break
	
	if selected_idx != -1:
		conn_reg_opt.select(selected_idx)
	
	_on_conn_region_changed(selected_idx)
	
	if target_room != "":
		for i in range(conn_room_opt.item_count):
			if conn_room_opt.get_item_metadata(i) == target_room:
				conn_room_opt.select(i)
				break
	
	_update_connection_info()

func _on_conn_region_changed(idx):
	conn_room_opt.clear()
	if idx == -1: return
	
	var reg_id = conn_reg_opt.get_item_metadata(idx)
	var data = conn_hierarchy.get(reg_id, {})
	var rooms = data.get("rooms", {})
	
	var room_keys = rooms.keys()
	room_keys.sort()
	
	for r_id in room_keys:
		conn_room_opt.add_item(rooms[r_id] + " (" + r_id + ")")
		conn_room_opt.set_item_metadata(conn_room_opt.item_count - 1, r_id)
	
	_update_connection_info()

func _update_connection_info():
	if not conn_info_label: return
	conn_info_label.text = ""
	var dir = conn_dir_edit.text.strip_edges().to_lower()
	var msgs = []
	
	var full_target_id = ""
	if conn_reg_opt.selected != -1 and conn_room_opt.selected != -1:
		var target_reg = conn_reg_opt.get_item_metadata(conn_reg_opt.selected)
		var target_room = conn_room_opt.get_item_metadata(conn_room_opt.selected)
		if target_reg == region_mgr.data.region_id:
			full_target_id = target_room
		else:
			full_target_id = target_reg + ":" + target_room
	target_selected.emit(full_target_id)
	
	if region_mgr.data.rooms.has(conn_src_id):
		var src_exits = region_mgr.data.rooms[conn_src_id].get("exits", {})
		if src_exits.has(dir):
			msgs.append("[color=salmon]âš  Source has exit '%s' -> %s (Overwrite)[/color]" % [dir, src_exits[dir]])
	
	if conn_room_opt.selected != -1 and conn_twoway.button_pressed:
		var target_reg = conn_reg_opt.get_item_metadata(conn_reg_opt.selected)
		var cur_reg_id = region_mgr.data.get("region_id", "")
		if target_reg == cur_reg_id:
			var target_id = conn_room_opt.get_item_metadata(conn_room_opt.selected)
			if region_mgr.data.rooms.has(target_id):
				var rev_dir = Constants.INV_DIR_MAP.get(dir, "")
				if rev_dir != "" and region_mgr.data.rooms[target_id].get("exits", {}).has(rev_dir):
					msgs.append("[color=orange]âš  Target has reverse exit (Overwrite)[/color]")
	
	if msgs.is_empty():
		conn_info_label.text = "[color=gray]Connection looks clear.[/color]"
	else:
		conn_info_label.text = "\n".join(msgs)

func _on_connect_confirm():
	var dir = conn_dir_edit.text
	if dir.strip_edges() == "": return
	if conn_room_opt.selected == -1: return
	var target_room = conn_room_opt.get_item_metadata(conn_room_opt.selected)
	var target_reg = conn_reg_opt.get_item_metadata(conn_reg_opt.selected)
	var final_target = target_reg + ":" + target_room
	
	target_selected.emit("") # Clear highlight after connecting
	connection_created.emit(conn_src_id, dir, final_target, conn_twoway.button_pressed)
	
	conn_dir_edit.text = ""
	conn_info_label.text = "[color=green]Connection Created.[/color]"

func _apply_style(node: Control, bg_color = Color(0.15,0.15,0.18)):
	var s=StyleBoxFlat.new(); s.bg_color=bg_color; s.set_border_width_all(1); s.border_color=Color(0.4,0.4,0.45); s.set_corner_radius_all(4); s.content_margin_left=8
	if node is Button:
		if node is CheckBox:
			s.content_margin_left = 4; s.content_margin_right = 4; node.alignment = HORIZONTAL_ALIGNMENT_LEFT
			var s_unchecked = s.duplicate(); s_unchecked.bg_color = Color(0.25, 0.1, 0.1); s_unchecked.border_color = Color(0.5, 0.3, 0.3)
			var s_checked = s.duplicate(); s_checked.bg_color = Color(0.1, 0.3, 0.15); s_checked.border_color = Color(0.3, 0.6, 0.4)
			node.add_theme_stylebox_override("normal", s_unchecked)
			node.add_theme_stylebox_override("pressed", s_checked)
			node.add_theme_stylebox_override("hover", s_unchecked.duplicate()) 
			node.add_theme_stylebox_override("hover_pressed", s_checked.duplicate()) 
			node.get_theme_stylebox("hover").bg_color = s_unchecked.bg_color.lightened(0.1)
			node.get_theme_stylebox("hover_pressed").bg_color = s_checked.bg_color.lightened(0.1)
			node.add_theme_stylebox_override("focus", s_unchecked.duplicate())
		else:
			node.add_theme_stylebox_override("normal", s)
			node.add_theme_stylebox_override("hover", s.duplicate())
			node.add_theme_stylebox_override("pressed", s.duplicate())
			node.add_theme_stylebox_override("focus", s.duplicate())
			node.get_theme_stylebox("hover").bg_color = bg_color.lightened(0.1)
			node.get_theme_stylebox("pressed").bg_color = bg_color.darkened(0.1)
			node.get_theme_stylebox("focus").bg_color = bg_color.lightened(0.05)
	elif node is LineEdit or node is TextEdit: s.bg_color=Color(0.08,0.08,0.1); node.add_theme_stylebox_override("normal", s)

func _lbl(t,c=Color.WHITE): var l=Label.new(); l.text=t; l.modulate=c; return l
func _clear_box(b): for c in b.get_children(): c.queue_free()
# scripts/ui/inspectors/MultiRoomInspector.gd
class_name MultiRoomInspector
extends RefCounted

signal data_modified

var container: VBoxContainer
var region_mgr: RegionManager
var action_handler: ActionHandler
var selected_ids: Array
var props_box: VBoxContainer
var popup_menu: PopupMenu

# Definition for intersection result
class MixedProp:
	var value
	var is_mixed: bool = false
	func _init(v, m=false): value = v; is_mixed = m

func _init(c: VBoxContainer, r_mgr: RegionManager, handler: ActionHandler):
	container = c
	region_mgr = r_mgr
	action_handler = handler

func build(ids: Array):
	selected_ids = ids
	
	container.add_child(InspectorStyle.create_section_header("MULTI-EDIT (%d Rooms)" % ids.size(), Color.ORANGE))
	
	var card = InspectorStyle.create_card()
	var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	# Tag Addition UI
	var header_box = HBoxContainer.new()
	header_box.add_child(InspectorStyle.lbl("Common Properties", Color.WHITE))
	var spacer = Control.new(); spacer.size_flags_horizontal = Control.SIZE_EXPAND_FILL; header_box.add_child(spacer)
	
	var btn_add = MenuButton.new(); btn_add.text = "+ Tag"
	btn_add.flat = true; btn_add.add_theme_color_override("font_color", InspectorStyle.COLOR_ACCENT)
	header_box.add_child(btn_add)
	vbox.add_child(header_box)
	
	props_box = VBoxContainer.new()
	props_box.add_theme_constant_override("separation", 6)
	vbox.add_child(props_box)
	
	popup_menu = btn_add.get_popup()
	popup_menu.id_pressed.connect(_on_add_tag)
	
	_refresh_props()

func _refresh_props():
	for c in props_box.get_children(): c.queue_free()
	
	# 1. Analyze Intersection
	var prop_counts = {} # key -> count
	var prop_values = {} # key -> first_val
	var prop_mixed = {} # key -> bool
	
	for id in selected_ids:
		if not region_mgr.data.rooms.has(id): continue
		var r = region_mgr.data.rooms[id]
		var p = r.get("properties", {})
		
		for k in p:
			if not prop_counts.has(k):
				prop_counts[k] = 0
				prop_values[k] = p[k]
				prop_mixed[k] = false
			
			prop_counts[k] += 1
			if prop_values[k] != p[k]:
				prop_mixed[k] = true
	
	# 2. Build UI for properties that exist in AT LEAST ONE selected room
	var keys = prop_counts.keys()
	keys.sort()
	
	popup_menu.clear()
	# Populate Add Menu (Common props not present in ALL)
	var common = ["dark", "outdoors", "safe_zone", "noisy", "smell", "weather", "music"]
	for c in common:
		popup_menu.add_item(c)
	popup_menu.add_separator()
	popup_menu.add_item("Custom...")
	
	if keys.is_empty():
		var l = Label.new(); l.text = "No properties found."; l.modulate = Color(1,1,1,0.3)
		props_box.add_child(l)
		return
		
	for k in keys:
		var is_universal = (prop_counts[k] == selected_ids.size())
		var is_mixed = prop_mixed[k]
		var val = prop_values[k]
		
		var row = PanelContainer.new()
		var s = StyleBoxFlat.new(); s.bg_color = Color(0.15, 0.15, 0.17); s.set_corner_radius_all(4)
		row.add_theme_stylebox_override("panel", s)
		var hb = HBoxContainer.new()
		row.add_child(hb)
		
		var lbl_k = Label.new(); lbl_k.text = k + ": "; lbl_k.custom_minimum_size.x = 80
		if not is_universal: lbl_k.modulate = Color(1, 1, 1, 0.5) # Dim if not on all
		hb.add_child(lbl_k)
		
		# Value Editor
		if is_mixed:
			var l_mix = Label.new(); l_mix.text = "<Mixed>"; l_mix.modulate = Color.GOLD
			l_mix.size_flags_horizontal = Control.SIZE_EXPAND_FILL
			hb.add_child(l_mix)
			
			var btn_set = Button.new(); btn_set.text = "Set All"
			InspectorStyle.apply_button_style(btn_set)
			btn_set.pressed.connect(func(): _edit_prop(k, val)) # Set all to the 'first' value found
			hb.add_child(btn_set)
		else:
			if typeof(val) == TYPE_BOOL:
				var chk = CheckBox.new(); chk.button_pressed = val; chk.text = str(val)
				chk.toggled.connect(func(b): _edit_prop(k, b))
				hb.add_child(chk)
			else:
				var ed = LineEdit.new(); ed.text = str(val); ed.size_flags_horizontal = Control.SIZE_EXPAND_FILL
				InspectorStyle.apply_input_style(ed)
				ed.text_submitted.connect(func(t):
					var new_v = t
					if typeof(val) == TYPE_FLOAT: new_v = t.to_float()
					elif typeof(val) == TYPE_INT: new_v = t.to_int()
					_edit_prop(k, new_v)
				)
				hb.add_child(ed)
				
		var btn_del = Button.new(); btn_del.text = "x"; btn_del.flat = true
		btn_del.pressed.connect(func(): _edit_prop(k, null)) # Null = Delete
		hb.add_child(btn_del)
		
		props_box.add_child(row)

func _edit_prop(key: String, new_val):
	var old_vals = {}
	for id in selected_ids:
		if region_mgr.data.rooms.has(id):
			var r = region_mgr.data.rooms[id]
			if r.get("properties", {}).has(key):
				old_vals[id] = r.properties[key]
			else:
				old_vals[id] = null # Marker for "didn't exist"
	
	action_handler.commit_batch_properties(selected_ids, key, new_val, old_vals)
	_refresh_props()

func _on_add_tag(idx):
	var txt = popup_menu.get_item_text(idx)
	if txt == "Custom...":
		return # TODO: Add custom dialog
	
	# Add property to all with default val (true for bools, empty string otherwise)
	var def_val = true
	_edit_prop(txt, def_val)
# scripts/ui/inspectors/panels/RoomContentPanel.gd
class_name RoomContentPanel
extends RefCounted

signal data_modified

# Data
var cur_data: Dictionary
var database_mgr: DatabaseManager

# UI
var npc_box: VBoxContainer
var item_box: VBoxContainer

func build(parent_container: VBoxContainer, data: Dictionary, db_mgr: DatabaseManager):
	cur_data = data
	database_mgr = db_mgr

	parent_container.add_child(InspectorStyle.create_section_header("CONTENT"))
	var card = InspectorStyle.create_card()
	var vbox = card.get_child(0).get_child(0)
	parent_container.add_child(card)
	
	vbox.add_child(InspectorStyle.lbl("NPCs", InspectorStyle.COLOR_TEXT_DIM))
	npc_box = VBoxContainer.new(); npc_box.add_theme_constant_override("separation", 6)
	vbox.add_child(npc_box)
	
	vbox.add_child(HSeparator.new())
	
	vbox.add_child(InspectorStyle.lbl("Items", InspectorStyle.COLOR_TEXT_DIM))
	item_box = VBoxContainer.new(); item_box.add_theme_constant_override("separation", 6)
	vbox.add_child(item_box)
	
	_refresh_content()

func _refresh_content():
	for c in npc_box.get_children(): c.queue_free()
	for c in item_box.get_children(): c.queue_free()
	
	# NPCs
	if cur_data.has("initial_npcs") and not cur_data.initial_npcs.is_empty():
		var idx = 0
		for n in cur_data.initial_npcs:
			var row = _create_content_row("npc", n, idx)
			npc_box.add_child(row)
			idx += 1
	else:
		var l = Label.new(); l.text="No NPCs."; l.modulate=Color(1,1,1,0.3); l.horizontal_alignment=HORIZONTAL_ALIGNMENT_CENTER
		l.size_flags_vertical = Control.SIZE_SHRINK_CENTER; npc_box.add_child(l)
		
	var btn_n = Button.new(); btn_n.text="+ Add NPC"; btn_n.alignment = HORIZONTAL_ALIGNMENT_CENTER
	InspectorStyle.apply_button_style(btn_n, Color(0.2, 0.2, 0.25))
	btn_n.pressed.connect(func():
		if not cur_data.has("initial_npcs"): cur_data.initial_npcs = []
		cur_data.initial_npcs.append({"template_id": "villager"})
		data_modified.emit(); _refresh_content()
	)
	npc_box.add_child(btn_n)
	
	# Items
	if cur_data.has("items") and not cur_data.items.is_empty():
		var idx = 0
		for i in cur_data.items:
			var row = _create_content_row("item", i, idx)
			item_box.add_child(row)
			idx += 1
	else:
		var l = Label.new(); l.text="No Items."; l.modulate=Color(1,1,1,0.3); l.horizontal_alignment=HORIZONTAL_ALIGNMENT_CENTER
		l.size_flags_vertical = Control.SIZE_SHRINK_CENTER; item_box.add_child(l)
		
	var btn_i = Button.new(); btn_i.text="+ Add Item"; btn_i.alignment = HORIZONTAL_ALIGNMENT_CENTER
	InspectorStyle.apply_button_style(btn_i, Color(0.2, 0.2, 0.25))
	btn_i.pressed.connect(func():
		if not cur_data.has("items"): cur_data.items = []
		cur_data.items.append({"item_id": "gold_coin"})
		data_modified.emit(); _refresh_content()
	)
	item_box.add_child(btn_i)

func _create_content_row(type, data, idx) -> PanelContainer:
	var pc = PanelContainer.new()
	var style = StyleBoxFlat.new(); style.bg_color = Color(0.15, 0.15, 0.17); style.set_corner_radius_all(4)
	pc.add_theme_stylebox_override("panel", style)
	
	var m = MarginContainer.new(); m.add_theme_constant_override("margin_left", 5); m.add_theme_constant_override("margin_right", 5)
	pc.add_child(m)
	
	var hb = HBoxContainer.new(); m.add_child(hb)
	var ico = Label.new(); ico.text = "ðŸ‘¤" if type == "npc" else "ðŸ“¦"; hb.add_child(ico)
	
	var vb_in = VBoxContainer.new(); vb_in.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	vb_in.add_theme_constant_override("separation", 2); hb.add_child(vb_in)
	
	if type == "npc":
		var hb1 = HBoxContainer.new(); hb1.add_child(InspectorStyle.lbl("T:", InspectorStyle.COLOR_TEXT_DIM))
		var ed_t = LineEdit.new(); ed_t.text = data.get("template_id", ""); ed_t.placeholder_text = "Template ID"
		ed_t.size_flags_horizontal = Control.SIZE_EXPAND_FILL; ed_t.flat = true
		InspectorStyle.apply_input_style(ed_t); ed_t.add_theme_stylebox_override("normal", StyleBoxEmpty.new())
		ed_t.text_submitted.connect(func(t): data.template_id = t; data_modified.emit()); hb1.add_child(ed_t)
		InspectorStyle.add_suggestion_button(hb1, ed_t, func(): return database_mgr.get_npc_ids()); vb_in.add_child(hb1)
		
		var hb2 = HBoxContainer.new(); hb2.add_child(InspectorStyle.lbl("I:", InspectorStyle.COLOR_TEXT_DIM))
		var ed_i = LineEdit.new(); ed_i.text = data.get("instance_id", ""); ed_i.placeholder_text = "Instance (Opt)"
		ed_i.size_flags_horizontal = Control.SIZE_EXPAND_FILL; ed_i.flat = true
		InspectorStyle.apply_input_style(ed_i); ed_i.add_theme_stylebox_override("normal", StyleBoxEmpty.new())
		ed_i.text_changed.connect(func(t): data.instance_id = t; data_modified.emit()); hb2.add_child(ed_i); vb_in.add_child(hb2)
	else:
		var hb1 = HBoxContainer.new()
		var ed_id = LineEdit.new(); ed_id.text = data.get("item_id", "")
		ed_id.size_flags_horizontal = Control.SIZE_EXPAND_FILL; ed_id.flat = true
		InspectorStyle.apply_input_style(ed_id); ed_id.add_theme_stylebox_override("normal", StyleBoxEmpty.new())
		ed_id.text_submitted.connect(func(t): data.item_id = t; data_modified.emit()); hb1.add_child(ed_id)
		InspectorStyle.add_suggestion_button(hb1, ed_id, func(): return database_mgr.get_item_ids())
		
		hb1.add_child(InspectorStyle.lbl("x", InspectorStyle.COLOR_TEXT_DIM))
		var sb = SpinBox.new(); sb.value = data.get("quantity", 1); sb.custom_minimum_size.x = 60
		InspectorStyle.apply_input_style(sb); sb.value_changed.connect(func(v): data.quantity = v; data_modified.emit()); hb1.add_child(sb)
		vb_in.add_child(hb1)
	
	var btn_del = Button.new(); btn_del.text = "ðŸ—‘"; btn_del.flat = true
	btn_del.pressed.connect(func(): 
		if type == "npc": cur_data.initial_npcs.remove_at(idx)
		else: cur_data.items.remove_at(idx)
		data_modified.emit(); _refresh_content()
	)
	hb.add_child(btn_del)
	
	return pc
# scripts/ui/inspectors/panels/RoomPropertiesPanel.gd
class_name RoomPropertiesPanel
extends RefCounted

signal data_modified

# Data
var cur_props: Dictionary

# UI
var props_box: VBoxContainer
var flow_container: HFlowContainer
var creation_tag: PanelContainer = null
var popup_menu: PopupMenu # New property to hold a direct reference

const COMMON_PROPS = {
	"Dark": {"key": "dark", "val": true},
	"Outdoors": {"key": "outdoors", "val": true},
	"Safe Zone": {"key": "safe_zone", "val": true},
	"Noisy": {"key": "noisy", "val": true},
	"Start Node": {"key": "is_start_node", "val": true},
	"Icon": {"key": "icon", "val": "none"},
	"Smell": {"key": "smell", "val": "damp earth"},
	"Weather": {"key": "weather", "val": "clear"},
	"Music": {"key": "music", "val": "default_theme"}
}

func build(parent_container: VBoxContainer, properties_data: Dictionary):
	cur_props = properties_data
	
	var header_box = HBoxContainer.new()
	header_box.add_child(InspectorStyle.create_section_header("PROPERTIES"))
	var spacer = Control.new(); spacer.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	header_box.add_child(spacer)
	
	var btn_add = MenuButton.new(); btn_add.text = "+ Tag"; btn_add.flat = true
	btn_add.add_theme_color_override("font_color", InspectorStyle.COLOR_ACCENT)
	btn_add.add_theme_color_override("font_hover_color", Color.WHITE)
	header_box.add_child(btn_add)
	parent_container.add_child(header_box)
	
	var card = InspectorStyle.create_card()
	var vbox = card.get_child(0).get_child(0)
	parent_container.add_child(card)
	
	popup_menu = btn_add.get_popup() # Store the reference here
	popup_menu.id_pressed.connect(_on_add_tag_selected)
	
	props_box = VBoxContainer.new()
	vbox.add_child(props_box)
	_refresh_props()

func _on_add_tag_selected(id):
	var item_text = popup_menu.get_item_text(id) # Use the stored reference
	if item_text == "Custom...":
		_show_creation_tag()
	else:
		var key = COMMON_PROPS[item_text].key
		var val = COMMON_PROPS[item_text].val
		if not cur_props.has(key):
			cur_props[key] = val
			data_modified.emit()
			_refresh_props()

func _show_creation_tag():
	if is_instance_valid(creation_tag): return # Already adding one
	
	creation_tag = PanelContainer.new()
	var style = StyleBoxFlat.new(); style.bg_color = Color(0.3, 0.3, 0.35); style.set_corner_radius_all(12)
	style.content_margin_left = 6; style.content_margin_right = 6; style.content_margin_top = 2; style.content_margin_bottom = 2
	creation_tag.add_theme_stylebox_override("panel", style)
	
	var hb = HBoxContainer.new(); creation_tag.add_child(hb)
	
	var key_edit = LineEdit.new(); key_edit.placeholder_text = "key"; key_edit.name = "KeyEdit"
	InspectorStyle.apply_input_style(key_edit); hb.add_child(key_edit)
	
	var type_select = OptionButton.new(); type_select.name = "TypeSelect"
	type_select.add_item("String"); type_select.add_item("Number"); type_select.add_item("Bool")
	InspectorStyle.apply_button_style(type_select); hb.add_child(type_select)
	
	var val_edit = LineEdit.new(); val_edit.placeholder_text = "value"; val_edit.name = "ValueEdit"
	InspectorStyle.apply_input_style(val_edit); hb.add_child(val_edit)
	
	var confirm_btn = Button.new(); confirm_btn.text = "âœ”"
	InspectorStyle.apply_button_style(confirm_btn, InspectorStyle.COLOR_SUCCESS); hb.add_child(confirm_btn)
	
	var cancel_btn = Button.new(); cancel_btn.text = "âœ–"
	InspectorStyle.apply_button_style(cancel_btn, InspectorStyle.COLOR_DANGER); hb.add_child(cancel_btn)
	
	flow_container.add_child(creation_tag)
	key_edit.grab_focus()
	
	confirm_btn.pressed.connect(_finalize_new_prop)
	cancel_btn.pressed.connect(_cancel_new_prop)
	key_edit.text_submitted.connect(func(_t): _finalize_new_prop())
	val_edit.text_submitted.connect(func(_t): _finalize_new_prop())

func _finalize_new_prop():
	if not is_instance_valid(creation_tag): return
	
	var key = creation_tag.get_node("KeyEdit").text.strip_edges()
	var type_idx = creation_tag.get_node("TypeSelect").selected
	var val_str = creation_tag.get_node("ValueEdit").text.strip_edges()
	
	if key.is_empty() or cur_props.has(key):
		# Visual feedback for error would be good here, but for now we just cancel
		_cancel_new_prop()
		return

	var final_val
	match type_idx:
		0: # String
			final_val = val_str
		1: # Number
			if val_str.is_valid_float(): final_val = val_str.to_float()
			else: final_val = 0.0
		2: # Bool
			final_val = val_str.to_lower() in ["true", "1", "yes", "on"]
	
	cur_props[key] = final_val
	creation_tag.queue_free()
	creation_tag = null
	data_modified.emit()
	_refresh_props()

func _cancel_new_prop():
	if is_instance_valid(creation_tag):
		creation_tag.queue_free()
		creation_tag = null

func _refresh_props():
	if is_instance_valid(flow_container):
		for c in flow_container.get_children():
			if c != creation_tag:
				c.queue_free()
	else:
		for c in props_box.get_children(): c.queue_free()
		flow_container = HFlowContainer.new()
		flow_container.add_theme_constant_override("h_separation", 8)
		flow_container.add_theme_constant_override("v_separation", 8)
		props_box.add_child(flow_container)

	# Update the dropdown menu for adding tags
	popup_menu.clear() # Use the stored reference
	var sorted_common_keys = COMMON_PROPS.keys()
	sorted_common_keys.sort()
	for k in sorted_common_keys:
		if not cur_props.has(COMMON_PROPS[k].key):
			popup_menu.add_item(k)
	popup_menu.add_separator()
	popup_menu.add_item("Custom...")
	
	if cur_props.is_empty():
		var l = Label.new(); l.text = "None."; l.modulate = Color(1,1,1,0.3); l.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		flow_container.add_child(l)
		return
	
	for key in cur_props:
		var val = cur_props[key]
		var tag = _create_prop_tag(key, val)
		flow_container.add_child(tag)

func _create_prop_tag(key, val) -> PanelContainer:
	var panel = PanelContainer.new()
	var style = StyleBoxFlat.new(); style.bg_color = Color(0.25, 0.25, 0.28); style.set_corner_radius_all(12)
	style.content_margin_left = 10; style.content_margin_right = 6; style.content_margin_top = 2; style.content_margin_bottom = 2
	panel.add_theme_stylebox_override("panel", style)
	
	var hb = HBoxContainer.new(); panel.add_child(hb)
	
	var lbl = Label.new(); lbl.text = key + ": "; lbl.modulate = Color(0.7, 0.9, 1.0)
	lbl.add_theme_font_size_override("font_size", 12); hb.add_child(lbl)
	
	if typeof(val) == TYPE_BOOL:
		var btn = Button.new(); btn.text = str(val).to_upper(); btn.flat = true
		btn.add_theme_font_size_override("font_size", 12)
		btn.add_theme_color_override("font_color", InspectorStyle.COLOR_SUCCESS if val else InspectorStyle.COLOR_DANGER)
		btn.pressed.connect(func(): cur_props[key] = !val; data_modified.emit(); _refresh_props())
		hb.add_child(btn)
	else:
		var ed = LineEdit.new(); ed.text = str(val); ed.flat = true; ed.expand_to_text_length = true; ed.custom_minimum_size.x = 30
		ed.add_theme_font_size_override("font_size", 12); ed.add_theme_stylebox_override("normal", StyleBoxEmpty.new())
		ed.text_submitted.connect(func(t): 
			if typeof(val) == TYPE_FLOAT or typeof(val) == TYPE_INT:
				cur_props[key] = t.to_float() if t.is_valid_float() else val
			else:
				cur_props[key] = t
			data_modified.emit()
			_refresh_props() # Refresh to ensure type consistency if input was bad
		)
		hb.add_child(ed)
		
	var del = Button.new(); del.text = "Ã—"; del.flat = true
	del.add_theme_font_size_override("font_size", 14); del.add_theme_color_override("font_color", Color(0.5, 0.5, 0.5))
	del.add_theme_color_override("font_hover_color", Color(1, 0.5, 0.5))
	del.pressed.connect(func(): cur_props.erase(key); data_modified.emit(); _refresh_props()); hb.add_child(del)
	return panel
# scripts/ui/inspectors/panels/RoomConnectionsPanel.gd
class_name RoomConnectionsPanel
extends RefCounted

signal data_modified
signal request_connection_form(id, name)

# Data
var cur_exits: Dictionary
var cur_id: String
var cur_name: String
var region_mgr: RegionManager
var world_mgr: WorldManager
var world_data_cache: Dictionary

# UI
var exits_box: VBoxContainer

func build(parent_container: VBoxContainer, id: String, name: String, exits_data: Dictionary, r_mgr: RegionManager, w_mgr: WorldManager):
	cur_id = id
	cur_name = name
	cur_exits = exits_data
	region_mgr = r_mgr
	world_mgr = w_mgr
	world_data_cache = world_mgr.get_all_world_data()
	
	parent_container.add_child(InspectorStyle.create_section_header("CONNECTIONS"))
	var card = InspectorStyle.create_card()
	var vbox = card.get_child(0).get_child(0)
	parent_container.add_child(card)
	
	exits_box = VBoxContainer.new()
	exits_box.add_theme_constant_override("separation", 6)
	vbox.add_child(exits_box)
	_refresh_exits()
	
	vbox.add_child(HSeparator.new())
	
	var m = MarginContainer.new(); m.add_theme_constant_override("margin_bottom", 4)
	var btn = Button.new(); btn.text = "ðŸ”— Link New Connection"; btn.alignment = HORIZONTAL_ALIGNMENT_CENTER
	btn.pressed.connect(func(): request_connection_form.emit(cur_id, cur_name))
	InspectorStyle.apply_button_style(btn, Color(0.2, 0.25, 0.3))
	m.add_child(btn)
	vbox.add_child(m)

func _refresh_exits():
	for c in exits_box.get_children(): c.queue_free()
	var keys = cur_exits.keys(); keys.sort()
	
	if keys.is_empty():
		var l = Label.new(); l.text = "No connections."; l.modulate = Color(1,1,1,0.3); l.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		exits_box.add_child(l)
		return

	for dir in keys:
		var target = cur_exits[dir]
		var row = _create_exit_row(dir, target)
		exits_box.add_child(row)

func _create_exit_row(dir, target) -> PanelContainer:
	var is_ext = ":" in target
	var pc = PanelContainer.new()
	var style = StyleBoxFlat.new(); style.bg_color = Color(0.12, 0.12, 0.14); style.set_corner_radius_all(4)
	
	if is_ext: style.border_width_bottom = 2; style.border_color = Color(0.8, 0.6, 0.2)
	else:
		style.border_width_left = 3
		match dir:
			"north","south","east","west": style.border_color = Color(0.3, 0.6, 0.9)
			"up","down","climb","dive": style.border_color = Color(0.7, 0.4, 0.8)
			_: style.border_color = Color(0.4, 0.8, 0.5)
			
	pc.add_theme_stylebox_override("panel", style)
	
	var m = MarginContainer.new()
	m.add_theme_constant_override("margin_left", 8); m.add_theme_constant_override("margin_right", 8)
	m.add_theme_constant_override("margin_top", 4); m.add_theme_constant_override("margin_bottom", 4)
	pc.add_child(m)
	
	var hb = HBoxContainer.new(); hb.add_theme_constant_override("separation", 10); m.add_child(hb)
	
	var l_dir = Label.new(); l_dir.text = dir.to_upper(); l_dir.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	l_dir.horizontal_alignment = HORIZONTAL_ALIGNMENT_RIGHT; l_dir.add_theme_font_size_override("font_size", 12)
	if is_ext: l_dir.modulate = Color(0.9, 0.8, 0.5)
	hb.add_child(l_dir)
	
	var is_two_way = false
	if not is_ext and region_mgr.data.rooms.has(target):
		var t_exits = region_mgr.data.rooms[target].get("exits", {})
		if t_exits.values().has(cur_id): is_two_way = true
	
	var arrow = Label.new(); arrow.text = "â‡„" if is_two_way else "â†’"
	arrow.modulate = InspectorStyle.COLOR_SUCCESS if is_two_way else Color(1,1,1,0.3)
	if is_ext: arrow.modulate = Color(0.9, 0.8, 0.5)
	hb.add_child(arrow)
	
	var vb_t = VBoxContainer.new(); vb_t.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	vb_t.add_theme_constant_override("separation", 0)
	
	var t_name = target
	if is_ext:
		var parts = target.split(":")
		var target_region_id = parts[0]
		var target_room_id = parts[1]
		if world_data_cache.has(target_region_id) and world_data_cache[target_region_id].rooms.has(target_room_id):
			t_name = world_data_cache[target_region_id].rooms[target_room_id].get("name", "Unnamed")
	elif region_mgr.data.rooms.has(target): 
		t_name = region_mgr.data.rooms[target].get("name", "Unnamed")
	
	var l_name = Label.new(); l_name.text = t_name; l_name.clip_text = true; l_name.add_theme_font_size_override("font_size", 14)
	var l_id = Label.new(); l_id.text = target; l_id.clip_text = true; l_id.add_theme_font_size_override("font_size", 10); l_id.modulate = Color(1,1,1,0.5)
	vb_t.add_child(l_name); vb_t.add_child(l_id); hb.add_child(vb_t)
	
	var btn_del = Button.new(); btn_del.text = "ðŸ—‘"; btn_del.flat = true
	btn_del.add_theme_color_override("font_color", Color(0.6, 0.3, 0.3))
	btn_del.add_theme_color_override("font_hover_color", Color(1.0, 0.4, 0.4))
	btn_del.pressed.connect(func(): cur_exits.erase(dir); data_modified.emit(); _refresh_exits())
	hb.add_child(btn_del)
	
	return pc
# scripts/ui/inspectors/QuestInspector.gd
class_name QuestInspector
extends RefCounted

signal data_modified
signal database_modified
signal request_graph_edit(quest_id) # New Signal

var container: VBoxContainer
var database_mgr: DatabaseManager
var world_mgr: WorldManager
var cur_id: String
var cur_data: Dictionary

var stages_box: VBoxContainer

func _init(c: VBoxContainer, db_mgr: DatabaseManager, w_mgr: WorldManager):
	container = c
	database_mgr = db_mgr
	world_mgr = w_mgr

func build(id: String, data: Dictionary):
	cur_id = id
	cur_data = data
	if not cur_data.has("stages"): cur_data["stages"] = []
	
	container.add_child(InspectorStyle.create_section_header("QUEST CONFIG", Color.GOLD))
	var card = InspectorStyle.create_card()
	var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	vbox.add_child(InspectorStyle.lbl("Quest ID: " + cur_id, Color.WHITE))
	
	# Graph Edit Button
	var btn_graph = Button.new(); btn_graph.text = "Visualize Graph"
	InspectorStyle.apply_button_style(btn_graph, Color.VIOLET)
	btn_graph.pressed.connect(func(): request_graph_edit.emit(cur_id))
	vbox.add_child(btn_graph)
	vbox.add_child(HSeparator.new())
	
	vbox.add_child(InspectorStyle.lbl("Title:", InspectorStyle.COLOR_TEXT_DIM))
	var title_ed = LineEdit.new(); title_ed.text = cur_data.get("title", "")
	title_ed.text_changed.connect(func(t): cur_data.title = t; database_modified.emit())
	InspectorStyle.apply_input_style(title_ed); vbox.add_child(title_ed)
	
	vbox.add_child(InspectorStyle.lbl("Summary:", InspectorStyle.COLOR_TEXT_DIM))
	var desc_ed = TextEdit.new(); desc_ed.custom_minimum_size.y = 60
	desc_ed.text = cur_data.get("description", "")
	desc_ed.text_changed.connect(func(): cur_data.description = desc_ed.text; database_modified.emit())
	InspectorStyle.apply_input_style(desc_ed); vbox.add_child(desc_ed)
	
	_build_stages_section()

func _build_stages_section():
	container.add_child(HSeparator.new())
	var header_box = HBoxContainer.new()
	header_box.add_child(InspectorStyle.create_section_header("QUEST STAGES", Color.CYAN))
	var spacer = Control.new(); spacer.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	header_box.add_child(spacer)
	
	var btn_add = Button.new(); btn_add.text = "+ Add Stage"
	InspectorStyle.apply_button_style(btn_add, Color(0.2, 0.3, 0.4))
	btn_add.pressed.connect(_add_stage)
	header_box.add_child(btn_add)
	container.add_child(header_box)
	
	stages_box = VBoxContainer.new()
	stages_box.add_theme_constant_override("separation", 12)
	container.add_child(stages_box)
	
	_refresh_stages()

func _refresh_stages():
	for c in stages_box.get_children(): c.queue_free()
	
	var stages = cur_data.get("stages", [])
	for i in range(stages.size()):
		stages_box.add_child(_create_stage_card(stages[i], i))

func _add_stage():
	var new_stage = {
		"id": "stage_" + str(cur_data.stages.size() + 1),
		"description": "",
		"type": "KILL",
		"target": "",
		"count": 1,
		"next": "",
		"_editor_pos": [cur_data.stages.size() * 200, 0] # Auto position
	}
	cur_data.stages.append(new_stage)
	database_modified.emit()
	_refresh_stages()

func _create_stage_card(stage: Dictionary, index: int) -> PanelContainer:
	var pc = InspectorStyle.create_card()
	var vbox = pc.get_child(0).get_child(0)
	
	# Header
	var hb_top = HBoxContainer.new()
	var lbl_idx = InspectorStyle.lbl("Stage %d" % (index + 1), Color.CYAN)
	hb_top.add_child(lbl_idx)
	
	var ed_id = LineEdit.new(); ed_id.text = stage.get("id", ""); ed_id.placeholder_text = "Stage ID"
	ed_id.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	InspectorStyle.apply_input_style(ed_id)
	ed_id.text_changed.connect(func(t): stage.id = t; database_modified.emit())
	hb_top.add_child(ed_id)
	
	var btn_del = Button.new(); btn_del.text = "X"
	InspectorStyle.apply_button_style(btn_del, Color(0.4, 0.1, 0.1))
	btn_del.pressed.connect(func(): cur_data.stages.remove_at(index); database_modified.emit(); _refresh_stages())
	hb_top.add_child(btn_del)
	vbox.add_child(hb_top)
	
	# Description
	var ed_desc = LineEdit.new(); ed_desc.text = stage.get("description", ""); ed_desc.placeholder_text = "Journal Entry / Description"
	InspectorStyle.apply_input_style(ed_desc)
	ed_desc.text_changed.connect(func(t): stage.description = t; database_modified.emit())
	vbox.add_child(ed_desc)
	
	# Logic Row
	var hb_logic = HBoxContainer.new()
	
	# Type
	var opt_type = OptionButton.new()
	var types = ["KILL", "COLLECT", "TALK", "GOTO", "INTERACT"]
	for t in types: opt_type.add_item(t)
	var curr_type = stage.get("type", "KILL")
	var type_idx = types.find(curr_type)
	if type_idx != -1: opt_type.selected = type_idx
	InspectorStyle.apply_button_style(opt_type)
	opt_type.item_selected.connect(func(idx): stage.type = types[idx]; database_modified.emit())
	hb_logic.add_child(opt_type)
	
	# Target (Smart Suggestion based on type)
	var ed_target = LineEdit.new(); ed_target.text = str(stage.get("target", ""))
	ed_target.placeholder_text = "Target ID"
	ed_target.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	InspectorStyle.apply_input_style(ed_target)
	ed_target.text_changed.connect(func(t): stage.target = t; database_modified.emit())
	hb_logic.add_child(ed_target)
	
	# Suggestion Button
	InspectorStyle.add_suggestion_button(hb_logic, ed_target, func():
		var t = opt_type.get_item_text(opt_type.selected)
		if t == "KILL" or t == "TALK": return database_mgr.get_npc_ids()
		if t == "COLLECT": return database_mgr.get_item_ids()
		return [] # No suggestions for GOTO yet (needs room list access)
	)
	
	# Count
	var sb_count = SpinBox.new(); sb_count.value = stage.get("count", 1)
	sb_count.tooltip_text = "Required Count"
	InspectorStyle.apply_input_style(sb_count)
	sb_count.value_changed.connect(func(v): stage.count = v; database_modified.emit())
	hb_logic.add_child(sb_count)
	
	vbox.add_child(hb_logic)
	
	# Next Stage
	var hb_next = HBoxContainer.new()
	hb_next.add_child(InspectorStyle.lbl("Next:", Color.GRAY))
	var ed_next = LineEdit.new(); ed_next.text = stage.get("next", ""); ed_next.placeholder_text = "Next Stage ID (empty = finish)"
	ed_next.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	InspectorStyle.apply_input_style(ed_next)
	ed_next.text_changed.connect(func(t): stage.next = t; database_modified.emit())
	hb_next.add_child(ed_next)
	vbox.add_child(hb_next)
	
	return pc
# scripts/ui/inspectors/RoomInspector.gd
class_name RoomInspector
extends RefCounted

signal data_modified
signal request_rename(old, new)
signal request_connection_form(id, name)
signal request_save_template(room_id) # New Signal

# Sub-panel controllers
var props_panel: RoomPropertiesPanel
var conn_panel: RoomConnectionsPanel
var content_panel: RoomContentPanel

var container: VBoxContainer
var region_mgr: RegionManager
var database_mgr: DatabaseManager
var world_mgr: WorldManager
var cur_id: String
var cur_data: Dictionary

const PROPS_PANEL_SCRIPT = preload("res://scripts/ui/inspectors/panels/RoomPropertiesPanel.gd")
const CONN_PANEL_SCRIPT = preload("res://scripts/ui/inspectors/panels/RoomConnectionsPanel.gd")
const CONTENT_PANEL_SCRIPT = preload("res://scripts/ui/inspectors/panels/RoomContentPanel.gd")

func _init(c: VBoxContainer, r_mgr: RegionManager, d_mgr: DatabaseManager, w_mgr: WorldManager):
	container = c
	region_mgr = r_mgr
	database_mgr = d_mgr
	world_mgr = w_mgr

func build(id: String, data: Dictionary):
	cur_id = id
	cur_data = data
	
	if not cur_data.has("properties"): cur_data.properties = {}
	if not cur_data.has("exits"): cur_data.exits = {}

	_build_general_info()
	
	props_panel = PROPS_PANEL_SCRIPT.new()
	props_panel.build(container, cur_data.properties)
	props_panel.data_modified.connect(func(): data_modified.emit())

	conn_panel = CONN_PANEL_SCRIPT.new()
	conn_panel.build(container, cur_id, cur_data.get("name", "Unnamed"), cur_data.exits, region_mgr, world_mgr)
	conn_panel.data_modified.connect(func(): data_modified.emit())
	conn_panel.request_connection_form.connect(func(cid, cname): request_connection_form.emit(cid, cname))

	content_panel = CONTENT_PANEL_SCRIPT.new()
	content_panel.build(container, cur_data, database_mgr)
	content_panel.data_modified.connect(func(): data_modified.emit())
	
	# Template Button
	container.add_child(HSeparator.new())
	var btn_tmpl = Button.new(); btn_tmpl.text = "Save as Template"
	btn_tmpl.pressed.connect(func(): request_save_template.emit(cur_id))
	InspectorStyle.apply_button_style(btn_tmpl, Color(0.3, 0.3, 0.2))
	container.add_child(btn_tmpl)

func _build_general_info():
	container.add_child(InspectorStyle.create_section_header("GENERAL INFO", InspectorStyle.COLOR_ACCENT))
	var card = InspectorStyle.create_card()
	var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	var id_box = HBoxContainer.new()
	id_box.add_child(InspectorStyle.lbl("ID:", InspectorStyle.COLOR_TEXT_DIM))
	var id_edit = LineEdit.new(); id_edit.text = cur_id; id_edit.size_flags_horizontal = 3
	id_edit.text_submitted.connect(func(t): request_rename.emit(cur_id, t))
	InspectorStyle.apply_input_style(id_edit)
	id_box.add_child(id_edit)
	vbox.add_child(id_box)
	
	var name_box = HBoxContainer.new()
	name_box.add_child(InspectorStyle.lbl("Name:", InspectorStyle.COLOR_TEXT_DIM))
	var name_edit = LineEdit.new(); name_edit.text = cur_data.get("name", ""); name_edit.size_flags_horizontal = 3
	name_edit.text_changed.connect(func(t): cur_data.name=t; data_modified.emit())
	InspectorStyle.apply_input_style(name_edit)
	name_box.add_child(name_edit)
	vbox.add_child(name_box)
	
	vbox.add_child(InspectorStyle.lbl("Description:", InspectorStyle.COLOR_TEXT_DIM))
	var desc_edit = TextEdit.new(); desc_edit.custom_minimum_size.y = 160
	desc_edit.wrap_mode = TextEdit.LINE_WRAPPING_BOUNDARY
	desc_edit.text = cur_data.get("description", "")
	desc_edit.text_changed.connect(func(): cur_data.description=desc_edit.text; data_modified.emit())
	InspectorStyle.apply_input_style(desc_edit)
	vbox.add_child(desc_edit)
# scripts/ui/inspectors/InspectorController.gd
class_name InspectorController
extends RefCounted

signal request_rename(old, new)
signal request_connection_modal
signal connection_created(src, dir, target, twoway)
signal target_selected_in_connector(target_id)
signal request_save_template(room_id) 
signal save_triggered
signal reload_triggered
signal data_modified
signal database_modified
signal request_graph_edit_mode(quest_id) # New Signal

var panel: Panel
var vbox_main: VBoxContainer
var content_container: VBoxContainer
var save_reload_container: HBoxContainer

var region_mgr: RegionManager
var world_mgr: WorldManager
var database_mgr: DatabaseManager

var connection_editor: ConnectionEditor
var action_handler: ActionHandler # Injected for MultiInspector

# Active Sub-Inspector
var current_inspector: RefCounted = null

const QUEST_INSPECTOR_SCRIPT = preload("res://scripts/ui/inspectors/QuestInspector.gd")
const MULTI_INSPECTOR_SCRIPT = preload("res://scripts/ui/inspectors/MultiRoomInspector.gd")

func setup(parent: Node, _region_mgr: RegionManager, _world_mgr: WorldManager, _db_mgr: DatabaseManager):
	region_mgr = _region_mgr
	world_mgr = _world_mgr
	database_mgr = _db_mgr
	
	connection_editor = ConnectionEditor.new(region_mgr)
	connection_editor.connection_created.connect(func(src,d,t,two): connection_created.emit(src,d,t,two))
	connection_editor.target_selected.connect(func(id): target_selected_in_connector.emit(id))
	
	panel = Panel.new()
	panel.anchor_left = 0.75; panel.anchor_right = 1.0
	panel.anchor_bottom = 0.96 
	var style = StyleBoxFlat.new()
	style.bg_color = InspectorStyle.COLOR_BG_MAIN
	style.set_border_width_all(0); style.border_width_left = 1
	style.border_color = Color(0.25, 0.25, 0.28)
	style.shadow_size = 4
	panel.add_theme_stylebox_override("panel", style)
	parent.add_child(panel)
	
	panel.visible = false 
	panel.gui_input.connect(_on_panel_gui_input)
	
	vbox_main = VBoxContainer.new()
	vbox_main.set_anchors_preset(Control.PRESET_FULL_RECT)
	vbox_main.offset_left = 16; vbox_main.offset_top = 16; vbox_main.offset_right = -16; vbox_main.offset_bottom = -16
	vbox_main.add_theme_constant_override("separation", 12)
	panel.add_child(vbox_main)

	var scroll = ScrollContainer.new()
	scroll.size_flags_vertical = Control.SIZE_EXPAND_FILL
	scroll.horizontal_scroll_mode = ScrollContainer.SCROLL_MODE_DISABLED
	vbox_main.add_child(scroll)
	
	content_container = VBoxContainer.new()
	content_container.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	content_container.add_theme_constant_override("separation", 16)
	scroll.add_child(content_container)

	save_reload_container = HBoxContainer.new()
	save_reload_container.custom_minimum_size.y = 40
	save_reload_container.add_theme_constant_override("separation", 10)
	vbox_main.add_child(save_reload_container)

	var btn_save = Button.new(); btn_save.text="SAVE DATA"; btn_save.size_flags_horizontal = 3
	btn_save.pressed.connect(func(): save_triggered.emit())
	InspectorStyle.apply_button_style(btn_save, InspectorStyle.COLOR_SUCCESS.darkened(0.2))
	save_reload_container.add_child(btn_save)
	
	var btn_reload = Button.new(); btn_reload.text="RELOAD"; btn_reload.size_flags_horizontal = 3
	btn_reload.pressed.connect(func(): reload_triggered.emit())
	InspectorStyle.apply_button_style(btn_reload, InspectorStyle.COLOR_DANGER.darkened(0.2))
	save_reload_container.add_child(btn_reload)

# Public Injection for MultiInspector
func set_action_handler(handler: ActionHandler):
	action_handler = handler

var cur_mode = "none"

func clear_selection(hide_panel: bool = true):
	cur_mode = "none"
	current_inspector = null
	_clear_box(content_container)
	save_reload_container.visible = true
	if hide_panel: panel.visible = false
	target_selected_in_connector.emit("") 

func load_room(id: String, data: Dictionary):
	clear_selection(false)
	cur_mode = "room"
	panel.visible = true
	
	var insp = RoomInspector.new(content_container, region_mgr, database_mgr, world_mgr)
	current_inspector = insp
	
	insp.data_modified.connect(func(): data_modified.emit())
	insp.request_rename.connect(func(o, n): request_rename.emit(o, n))
	insp.request_connection_form.connect(func(rid, rname): load_connection_form(rid, rname, world_mgr.get_global_hierarchy(), region_mgr.current_filename))
	insp.request_save_template.connect(func(rid): request_save_template.emit(rid))
	
	insp.build(id, data)

func load_region_root(data: Dictionary):
	clear_selection(false)
	cur_mode = "region_root"
	panel.visible = true
	
	var insp = RegionInspector.new(content_container)
	current_inspector = insp
	insp.data_modified.connect(func(): data_modified.emit())
	insp.build(data.get("region_id", "Unknown"), data)

func load_db_object(type: String, id: String, data: Dictionary):
	clear_selection(false)
	cur_mode = type
	panel.visible = true
	
	if type == "quest":
		var insp = QUEST_INSPECTOR_SCRIPT.new(content_container, database_mgr, world_mgr)
		current_inspector = insp
		insp.database_modified.connect(func(): database_modified.emit())
		insp.request_graph_edit.connect(func(qid): request_graph_edit_mode.emit(qid))
		insp.build(id, data)
	else:
		var insp = DatabaseInspector.new(content_container)
		insp.set_db_manager(database_mgr)
		current_inspector = insp
		insp.database_modified.connect(func(): database_modified.emit())
		insp.build(type, id, data)

func load_external_ref(full_id: String):
	clear_selection(false) 
	panel.visible = true
	content_container.add_child(InspectorStyle.create_section_header("EXTERNAL REFERENCE", Color.CYAN))
	var card = InspectorStyle.create_card(); var vbox = card.get_child(0).get_child(0)
	content_container.add_child(card)
	vbox.add_child(InspectorStyle.lbl(full_id, InspectorStyle.COLOR_TEXT_DIM))
	vbox.add_child(InspectorStyle.lbl("Node is in another file.", Color.GRAY))

func load_multi_selection(ids: Array):
	clear_selection(false)
	cur_mode = "multi"
	panel.visible = true
	
	var insp = MULTI_INSPECTOR_SCRIPT.new(content_container, region_mgr, action_handler)
	current_inspector = insp
	insp.data_modified.connect(func(): data_modified.emit())
	insp.build(ids)

func load_connection_form(src_id: String, src_name: String, hierarchy: Dictionary, cur_filename: String, target_id: String = "", dir: String = ""):
	cur_mode = "connection"
	save_reload_container.visible = false
	panel.visible = true 
	_clear_box(content_container)
	connection_editor.build_ui(content_container, src_id, src_name, hierarchy, cur_filename, target_id, dir)
	
	var margin_c = content_container.get_child(content_container.get_child_count()-1)
	if margin_c and margin_c.get_child_count() > 0:
		var btn_box = margin_c.get_child(0)
		var btn_c = btn_box.get_child(1) 
		if not btn_c.pressed.is_connected(_on_connect_cancel):
			btn_c.pressed.connect(_on_connect_cancel)

func set_connection_target(region_id: String, room_id: String):
	if cur_mode != "connection": return
	connection_editor.set_target(region_id, room_id)

func _on_connect_cancel():
	target_selected_in_connector.emit("") 
	if region_mgr.data.rooms.has(connection_editor.conn_src_id): 
		load_room(connection_editor.conn_src_id, region_mgr.data.rooms[connection_editor.conn_src_id])
	else: clear_selection()

func _clear_box(b): for c in b.get_children(): c.queue_free()
func _on_panel_gui_input(event): if event is InputEventMouseButton and event.button_index in [4,5]: panel.get_viewport().set_input_as_handled()

func load_world_mode():
	clear_selection(false) 
	cur_mode = "world"
	panel.visible = true
	content_container.add_child(InspectorStyle.create_section_header("WORLD MAP", Color.GOLD))
	var card = InspectorStyle.create_card(); var vbox = card.get_child(0).get_child(0)
	content_container.add_child(card)
	vbox.add_child(InspectorStyle.lbl("Arrangement Mode", Color.WHITE))

func load_quest_mode(quest_id: String):
	clear_selection(false)
	cur_mode = "quest_graph"
	panel.visible = true
	content_container.add_child(InspectorStyle.create_section_header("QUEST GRAPH: " + quest_id, Color.VIOLET))
	var card = InspectorStyle.create_card(); var vbox = card.get_child(0).get_child(0)
	content_container.add_child(card)
	vbox.add_child(InspectorStyle.lbl("Graph View", Color.WHITE))
	
	var btn = Button.new(); btn.text = "Back to Form View"
	InspectorStyle.apply_button_style(btn)
	btn.pressed.connect(func(): load_db_object("quest", quest_id, database_mgr.quests[quest_id]))
	vbox.add_child(btn)
# scripts/ui/inspectors/RegionInspector.gd
class_name RegionInspector
extends RefCounted

signal data_modified

var container: VBoxContainer
var cur_data: Dictionary
var cur_id: String

var spawner_box: VBoxContainer
var props_box: VBoxContainer
var flow_container: HFlowContainer
var creation_tag: PanelContainer = null
var popup_menu: PopupMenu # New property to hold a direct reference

const COMMON_PROPS = {
	"Dark": {"key": "dark", "val": true},
	"Outdoors": {"key": "outdoors", "val": true},
	"Safe Zone": {"key": "safe_zone", "val": true},
	"Noisy": {"key": "noisy", "val": true},
	"Smell": {"key": "smell", "val": "damp earth"},
	"Weather": {"key": "weather", "val": "clear"},
	"Music": {"key": "music", "val": "default_theme"}
}

func _init(c: VBoxContainer):
	container = c

func build(id: String, data: Dictionary):
	cur_id = id
	cur_data = data
	_build_general()
	_build_global_props()
	_build_spawner()

func _build_general():
	container.add_child(InspectorStyle.create_section_header("REGION SETTINGS", Color.GOLD))
	var card = InspectorStyle.create_card()
	var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	vbox.add_child(InspectorStyle.lbl("Region ID:", InspectorStyle.COLOR_TEXT_DIM))
	var lbl_id = LineEdit.new(); lbl_id.text = cur_id; lbl_id.editable = false; InspectorStyle.apply_input_style(lbl_id); vbox.add_child(lbl_id)
	
	vbox.add_child(InspectorStyle.lbl("Region Name:", InspectorStyle.COLOR_TEXT_DIM))
	var name_ed = LineEdit.new(); name_ed.text = cur_data.get("name", "")
	name_ed.text_changed.connect(func(t): cur_data.name = t; data_modified.emit())
	InspectorStyle.apply_input_style(name_ed); vbox.add_child(name_ed)

	vbox.add_child(InspectorStyle.lbl("Global Description:", InspectorStyle.COLOR_TEXT_DIM))
	var desc_ed = TextEdit.new(); desc_ed.custom_minimum_size.y = 100
	desc_ed.text = cur_data.get("description", "")
	desc_ed.text_changed.connect(func(): cur_data.description = desc_ed.text; data_modified.emit())
	InspectorStyle.apply_input_style(desc_ed); vbox.add_child(desc_ed)

func _build_global_props():
	var header_box = HBoxContainer.new()
	header_box.add_child(InspectorStyle.create_section_header("GLOBAL PROPERTIES"))
	var spacer = Control.new(); spacer.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	header_box.add_child(spacer)
	
	var btn_add = MenuButton.new(); btn_add.text = "+ Tag"; btn_add.flat = true
	btn_add.add_theme_color_override("font_color", InspectorStyle.COLOR_ACCENT)
	btn_add.add_theme_color_override("font_hover_color", Color.WHITE)
	header_box.add_child(btn_add)
	container.add_child(header_box)
	
	var card = InspectorStyle.create_card()
	var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	if not cur_data.has("properties"): cur_data.properties = {}
	
	popup_menu = btn_add.get_popup() # Store the reference
	popup_menu.id_pressed.connect(_on_add_tag_selected)
	
	props_box = VBoxContainer.new()
	vbox.add_child(props_box)
	_refresh_props()

func _on_add_tag_selected(id: int):
	var item_text = popup_menu.get_item_text(id)
	if item_text == "Custom...":
		_show_creation_tag()
	else:
		var key = COMMON_PROPS[item_text].key
		var val = COMMON_PROPS[item_text].val
		if not cur_data.properties.has(key):
			cur_data.properties[key] = val
			data_modified.emit()
			_refresh_props()

func _show_creation_tag():
	if is_instance_valid(creation_tag): return
	
	creation_tag = PanelContainer.new()
	var style = StyleBoxFlat.new(); style.bg_color = Color(0.3, 0.3, 0.35); style.set_corner_radius_all(12)
	style.content_margin_left = 6; style.content_margin_right = 6; style.content_margin_top = 2; style.content_margin_bottom = 2
	creation_tag.add_theme_stylebox_override("panel", style)
	
	var hb = HBoxContainer.new(); creation_tag.add_child(hb)
	
	var key_edit = LineEdit.new(); key_edit.placeholder_text = "key"; key_edit.name = "KeyEdit"
	InspectorStyle.apply_input_style(key_edit); hb.add_child(key_edit)
	
	var type_select = OptionButton.new(); type_select.name = "TypeSelect"
	type_select.add_item("String"); type_select.add_item("Number"); type_select.add_item("Bool")
	InspectorStyle.apply_button_style(type_select); hb.add_child(type_select)
	
	var val_edit = LineEdit.new(); val_edit.placeholder_text = "value"; val_edit.name = "ValueEdit"
	InspectorStyle.apply_input_style(val_edit); hb.add_child(val_edit)
	
	var confirm_btn = Button.new(); confirm_btn.text = "âœ”"
	InspectorStyle.apply_button_style(confirm_btn, InspectorStyle.COLOR_SUCCESS); hb.add_child(confirm_btn)
	
	var cancel_btn = Button.new(); cancel_btn.text = "âœ–"
	InspectorStyle.apply_button_style(cancel_btn, InspectorStyle.COLOR_DANGER); hb.add_child(cancel_btn)
	
	flow_container.add_child(creation_tag)
	key_edit.grab_focus()
	
	confirm_btn.pressed.connect(_finalize_new_prop)
	cancel_btn.pressed.connect(_cancel_new_prop)
	key_edit.text_submitted.connect(func(_t): _finalize_new_prop())
	val_edit.text_submitted.connect(func(_t): _finalize_new_prop())

func _finalize_new_prop():
	if not is_instance_valid(creation_tag): return
	
	var key = creation_tag.get_node("KeyEdit").text.strip_edges()
	var type_idx = creation_tag.get_node("TypeSelect").selected
	var val_str = creation_tag.get_node("ValueEdit").text.strip_edges()
	
	if key.is_empty() or cur_data.properties.has(key):
		_cancel_new_prop()
		return

	var final_val
	match type_idx:
		0: final_val = val_str
		1: final_val = val_str.to_float() if val_str.is_valid_float() else 0.0
		2: final_val = val_str.to_lower() in ["true", "1", "yes", "on"]
	
	cur_data.properties[key] = final_val
	creation_tag.queue_free(); creation_tag = null
	data_modified.emit(); _refresh_props()

func _cancel_new_prop():
	if is_instance_valid(creation_tag):
		creation_tag.queue_free(); creation_tag = null

func _refresh_props():
	if is_instance_valid(flow_container):
		for c in flow_container.get_children():
			if c != creation_tag:
				c.queue_free()
	else:
		for c in props_box.get_children(): c.queue_free()
		flow_container = HFlowContainer.new()
		flow_container.add_theme_constant_override("h_separation", 8)
		flow_container.add_theme_constant_override("v_separation", 8)
		props_box.add_child(flow_container)
	
	popup_menu.clear() # Use the stored reference
	var sorted_common_keys = COMMON_PROPS.keys(); sorted_common_keys.sort()
	for k in sorted_common_keys:
		if not cur_data.properties.has(COMMON_PROPS[k].key):
			popup_menu.add_item(k)
	popup_menu.add_separator(); popup_menu.add_item("Custom...")
	
	if cur_data.properties.is_empty():
		var l = Label.new(); l.text = "None."; l.modulate = Color(1,1,1,0.3); l.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
		flow_container.add_child(l)
		return
	
	for key in cur_data.properties:
		flow_container.add_child(_create_prop_tag(key, cur_data.properties[key]))

func _create_prop_tag(key, val) -> PanelContainer:
	var panel = PanelContainer.new()
	var style = StyleBoxFlat.new(); style.bg_color = Color(0.25, 0.25, 0.28); style.set_corner_radius_all(12)
	style.content_margin_left = 10; style.content_margin_right = 6; style.content_margin_top = 2; style.content_margin_bottom = 2
	panel.add_theme_stylebox_override("panel", style)
	
	var hb = HBoxContainer.new(); panel.add_child(hb)
	
	var lbl = Label.new(); lbl.text = key + ": "; lbl.modulate = Color(0.7, 0.9, 1.0)
	lbl.add_theme_font_size_override("font_size", 12); hb.add_child(lbl)
	
	if typeof(val) == TYPE_BOOL:
		var btn = Button.new(); btn.text = str(val).to_upper(); btn.flat = true
		btn.add_theme_font_size_override("font_size", 12)
		btn.add_theme_color_override("font_color", InspectorStyle.COLOR_SUCCESS if val else InspectorStyle.COLOR_DANGER)
		btn.pressed.connect(func(): cur_data.properties[key] = !val; data_modified.emit(); _refresh_props())
		hb.add_child(btn)
	else:
		var ed = LineEdit.new(); ed.text = str(val); ed.flat = true; ed.expand_to_text_length = true; ed.custom_minimum_size.x = 30
		ed.add_theme_font_size_override("font_size", 12); ed.add_theme_stylebox_override("normal", StyleBoxEmpty.new())
		ed.text_submitted.connect(func(t): 
			if typeof(val) == TYPE_FLOAT or typeof(val) == TYPE_INT:
				cur_data.properties[key] = t.to_float() if t.is_valid_float() else val
			else:
				cur_data.properties[key] = t
			data_modified.emit(); _refresh_props()
		)
		hb.add_child(ed)
		
	var del = Button.new(); del.text = "Ã—"; del.flat = true
	del.add_theme_font_size_override("font_size", 14); del.add_theme_color_override("font_color", Color(0.5, 0.5, 0.5))
	del.add_theme_color_override("font_hover_color", Color(1, 0.5, 0.5))
	del.pressed.connect(func(): cur_data.properties.erase(key); data_modified.emit(); _refresh_props()); hb.add_child(del)
	return panel

func _build_spawner():
	container.add_child(InspectorStyle.create_section_header("SPAWNER CONFIG", Color.SALMON))
	var card = InspectorStyle.create_card(); var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	if not cur_data.has("spawner"): cur_data.spawner = {}
	var sp = cur_data.spawner
	
	var hb_lvl = HBoxContainer.new()
	hb_lvl.add_child(InspectorStyle.lbl("Level Range:"))
	var sb_min = SpinBox.new(); sb_min.value = sp.get("level_range", [1,1])[0]; var sb_max = SpinBox.new(); sb_max.value = sp.get("level_range", [1,1])[1]
	InspectorStyle.apply_input_style(sb_min); InspectorStyle.apply_input_style(sb_max)
	var update_range = func(_v): sp.level_range = [sb_min.value, sb_max.value]; data_modified.emit()
	sb_min.value_changed.connect(update_range); sb_max.value_changed.connect(update_range)
	hb_lvl.add_child(sb_min); hb_lvl.add_child(InspectorStyle.lbl("-")); hb_lvl.add_child(sb_max)
	vbox.add_child(hb_lvl)
	
	vbox.add_child(InspectorStyle.lbl("Monster Weights:", InspectorStyle.COLOR_TEXT_DIM))
	spawner_box = VBoxContainer.new(); vbox.add_child(spawner_box)
	var btn_add_m = Button.new(); btn_add_m.text="Add Monster"; InspectorStyle.apply_button_style(btn_add_m, InspectorStyle.COLOR_SUCCESS.darkened(0.2))
	btn_add_m.pressed.connect(func():
		if not sp.has("monster_types"): sp.monster_types = {}
		sp.monster_types["new_monster"] = 1.0
		_refresh_spawner_box(); data_modified.emit()
	)
	vbox.add_child(btn_add_m)
	_refresh_spawner_box()

func _refresh_spawner_box():
	for c in spawner_box.get_children(): c.queue_free()
	var sp = cur_data.get("spawner", {})
	var types = sp.get("monster_types", {})
	
	for m_id in types:
		var panel = PanelContainer.new()
		var s = StyleBoxFlat.new(); s.bg_color = Color(0.12, 0.12, 0.14); s.set_corner_radius_all(4)
		panel.add_theme_stylebox_override("panel", s)
		var hb = HBoxContainer.new()
		panel.add_child(hb)
		
		var ed = LineEdit.new(); ed.text = m_id; ed.size_flags_horizontal=Control.SIZE_EXPAND_FILL
		ed.flat=true; InspectorStyle.apply_input_style(ed); ed.add_theme_stylebox_override("normal", StyleBoxEmpty.new())
		ed.text_submitted.connect(func(t): 
			if t != m_id: var v=types[m_id]; types.erase(m_id); types[t]=v; _refresh_spawner_box(); data_modified.emit()
		)
		hb.add_child(ed)
		
		var sb = SpinBox.new(); sb.step=0.1; sb.value=types[m_id]
		InspectorStyle.apply_input_style(sb)
		sb.value_changed.connect(func(v): types[m_id]=v; data_modified.emit())
		hb.add_child(sb)
		
		var d = Button.new(); d.text="x"; d.flat=true; d.pressed.connect(func(): types.erase(m_id); _refresh_spawner_box(); data_modified.emit())
		hb.add_child(d)
		spawner_box.add_child(panel)
# scripts/ui/inspectors/InspectorStyle.gd
class_name InspectorStyle
extends RefCounted

const COLOR_BG_MAIN = Color(0.12, 0.12, 0.14)
const COLOR_BG_CARD = Color(0.18, 0.18, 0.20)
const COLOR_ACCENT = Color(0.3, 0.5, 0.7)
const COLOR_DANGER = Color(0.7, 0.3, 0.3)
const COLOR_SUCCESS = Color(0.3, 0.6, 0.4)
const COLOR_TEXT_DIM = Color(0.6, 0.6, 0.65)

static func create_card() -> PanelContainer:
	var pc = PanelContainer.new()
	var style = StyleBoxFlat.new()
	style.bg_color = COLOR_BG_CARD
	style.set_corner_radius_all(6)
	style.set_border_width_all(1)
	style.border_color = Color(0.25, 0.25, 0.28)
	pc.add_theme_stylebox_override("panel", style)
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 12)
	margin.add_theme_constant_override("margin_right", 12)
	margin.add_theme_constant_override("margin_top", 12)
	margin.add_theme_constant_override("margin_bottom", 12)
	pc.add_child(margin)
	
	var vbox = VBoxContainer.new()
	vbox.add_theme_constant_override("separation", 10)
	margin.add_child(vbox)
	
	return pc

static func create_section_header(text: String, color: Color = Color.WHITE) -> Label:
	var l = Label.new()
	l.text = text
	l.add_theme_font_size_override("font_size", 12)
	l.add_theme_color_override("font_color", color)
	l.uppercase = true
	return l

static func create_sub_header(text: String) -> Label:
	var l = Label.new()
	l.text = text
	l.add_theme_font_size_override("font_size", 14)
	l.add_theme_color_override("font_color", Color(0.8, 0.8, 0.8))
	return l

static func apply_input_style(node: Control):
	var s = StyleBoxFlat.new()
	s.bg_color = Color(0.1, 0.1, 0.12)
	s.set_border_width_all(1)
	s.border_color = Color(0.3, 0.3, 0.35)
	s.set_corner_radius_all(4)
	s.content_margin_left = 8
	
	if node is LineEdit or node is SpinBox:
		node.add_theme_stylebox_override("normal", s)
		node.add_theme_stylebox_override("focus", s.duplicate()) 
	elif node is TextEdit:
		node.add_theme_stylebox_override("normal", s)

static func apply_button_style(btn: Button, bg: Color = Color(0.25, 0.25, 0.3)):
	var s = StyleBoxFlat.new()
	s.bg_color = bg
	s.set_corner_radius_all(4)
	s.content_margin_left = 10; s.content_margin_right = 10
	s.content_margin_top = 4; s.content_margin_bottom = 4
	
	var h = s.duplicate(); h.bg_color = bg.lightened(0.1)
	var p = s.duplicate(); p.bg_color = bg.darkened(0.1)
	
	btn.add_theme_stylebox_override("normal", s)
	btn.add_theme_stylebox_override("hover", h)
	btn.add_theme_stylebox_override("pressed", p)

static func lbl(t, c=Color.WHITE) -> Label:
	var l = Label.new(); l.text=t; l.modulate=c; return l

static func add_suggestion_button(parent: Control, target: LineEdit, getter: Callable):
	var b = MenuButton.new(); b.text=" v "
	apply_button_style(b)
	b.about_to_popup.connect(func():
		var p = b.get_popup(); p.clear()
		for x in getter.call(): p.add_item(x)
		
		# Clean up old signals to avoid stacking
		var conn = p.id_pressed.get_connections()
		for c in conn: p.id_pressed.disconnect(c.callable)
			
		p.id_pressed.connect(func(id): 
			target.text = p.get_item_text(p.get_item_index(id))
			target.text_submitted.emit(target.text)
			target.text_changed.emit(target.text)
		)
	)
	parent.add_child(b)
# scripts/ui/inspectors/DatabaseInspector.gd
class_name DatabaseInspector
extends RefCounted

signal data_modified
signal database_modified

var container: VBoxContainer
var cur_mode: String
var cur_id: String
var cur_data: Dictionary

# Sub-containers
var loot_box: VBoxContainer
var stats_grid: GridContainer
var props_box: VBoxContainer

# We access DatabaseManager to populate dropdowns via set_db_manager
var db_mgr_ref: DatabaseManager 

func _init(c: VBoxContainer):
	container = c

func set_db_manager(mgr):
	db_mgr_ref = mgr

func build(type: String, id: String, data: Dictionary):
	cur_mode = type
	cur_id = id
	cur_data = data
	
	var color = Color.GREEN if type == "npc" else Color.AQUAMARINE
	container.add_child(InspectorStyle.create_section_header("%s DATABASE" % type.to_upper(), color))
	
	_build_header_card()
	
	if type == "npc":
		_build_npc_stats()
		_build_loot_table()
	elif type == "item":
		_build_item_details()
		_build_item_properties()

func _build_header_card():
	var card = InspectorStyle.create_card(); var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	vbox.add_child(InspectorStyle.lbl("ID: " + cur_id, Color.WHITE))
	
	# Name
	vbox.add_child(InspectorStyle.lbl("Name:", InspectorStyle.COLOR_TEXT_DIM))
	var ed_name = LineEdit.new(); ed_name.text = cur_data.get("name", "")
	ed_name.text_changed.connect(func(t): cur_data.name=t; database_modified.emit())
	InspectorStyle.apply_input_style(ed_name); vbox.add_child(ed_name)
	
	# Description
	vbox.add_child(InspectorStyle.lbl("Description:", InspectorStyle.COLOR_TEXT_DIM))
	var ed_desc = TextEdit.new(); ed_desc.custom_minimum_size.y=60; ed_desc.wrap_mode = TextEdit.LINE_WRAPPING_BOUNDARY
	ed_desc.text = cur_data.get("description", "")
	ed_desc.text_changed.connect(func(): cur_data.description=ed_desc.text; database_modified.emit())
	InspectorStyle.apply_input_style(ed_desc); vbox.add_child(ed_desc)

# --- NPC SPECIFIC ---

func _build_npc_stats():
	container.add_child(HSeparator.new())
	container.add_child(InspectorStyle.create_sub_header("Combat Stats"))
	
	var card = InspectorStyle.create_card(); var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	# Basic
	var hb_basic = HBoxContainer.new()
	vbox.add_child(hb_basic)
	_add_spin_field(hb_basic, "Level", "level", 1)
	_add_spin_field(hb_basic, "Health", "health", 10)
	_add_spin_field(hb_basic, "Mana", "max_mana", 0)
	
	# Attributes Grid
	vbox.add_child(InspectorStyle.lbl("Attributes:", InspectorStyle.COLOR_TEXT_DIM))
	var grid = GridContainer.new(); grid.columns = 2
	grid.add_theme_constant_override("h_separation", 20)
	vbox.add_child(grid)
	
	if not cur_data.has("stats"): cur_data["stats"] = {}
	var stats = cur_data.stats
	
	var attr_keys = ["strength", "dexterity", "constitution", "agility", "intelligence", "wisdom", "spell_power", "magic_resist"]
	for k in attr_keys:
		_add_stat_row(grid, k.capitalize(), k, stats)

func _add_spin_field(parent, label, key, default):
	var vb = VBoxContainer.new(); vb.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	vb.add_child(InspectorStyle.lbl(label, InspectorStyle.COLOR_TEXT_DIM))
	var sb = SpinBox.new(); sb.value = cur_data.get(key, default)
	sb.value_changed.connect(func(v): cur_data[key] = v; database_modified.emit())
	InspectorStyle.apply_input_style(sb)
	vb.add_child(sb); parent.add_child(vb)

func _add_stat_row(parent, label, key, stats_dict):
	var hb = HBoxContainer.new(); hb.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	var l = Label.new(); l.text = label; l.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	hb.add_child(l)
	var sb = SpinBox.new(); sb.value = stats_dict.get(key, 0); sb.custom_minimum_size.x = 70
	sb.value_changed.connect(func(v): stats_dict[key] = v; database_modified.emit())
	InspectorStyle.apply_input_style(sb)
	hb.add_child(sb)
	parent.add_child(hb)

func _build_loot_table():
	container.add_child(HSeparator.new())
	var hb = HBoxContainer.new()
	hb.add_child(InspectorStyle.create_sub_header("Loot Table"))
	var spacer = Control.new(); spacer.size_flags_horizontal = Control.SIZE_EXPAND_FILL; hb.add_child(spacer)
	var btn_add = Button.new(); btn_add.text = "+ Drop"; InspectorStyle.apply_button_style(btn_add)
	btn_add.pressed.connect(_add_loot_entry)
	hb.add_child(btn_add); container.add_child(hb)
	
	loot_box = VBoxContainer.new(); loot_box.add_theme_constant_override("separation", 6)
	container.add_child(loot_box)
	
	if not cur_data.has("loot_table"): cur_data["loot_table"] = {}
	_refresh_loot_table()

func _refresh_loot_table():
	for c in loot_box.get_children(): c.queue_free()
	var table = cur_data.loot_table
	
	for item_id in table:
		var entry = table[item_id]
		var pc = PanelContainer.new()
		var style = StyleBoxFlat.new(); style.bg_color = Color(0.15, 0.15, 0.17); style.set_corner_radius_all(4)
		pc.add_theme_stylebox_override("panel", style)
		
		var m = MarginContainer.new(); m.add_theme_constant_override("margin_left", 5); m.add_theme_constant_override("margin_right", 5)
		pc.add_child(m)
		var hb = HBoxContainer.new(); m.add_child(hb)
		
		# Item ID / Gold
		var lbl_id = Label.new(); lbl_id.text = item_id
		if item_id == "gold_value": lbl_id.modulate = Color.GOLD
		lbl_id.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		hb.add_child(lbl_id)
		
		# Chance
		hb.add_child(InspectorStyle.lbl("Chance:", Color.GRAY))
		var sb_c = SpinBox.new(); sb_c.step = 0.05; sb_c.max_value = 1.0
		sb_c.value = entry.get("chance", 0.0)
		sb_c.custom_minimum_size.x = 60
		InspectorStyle.apply_input_style(sb_c)
		sb_c.value_changed.connect(func(v): entry["chance"] = v; database_modified.emit())
		hb.add_child(sb_c)
		
		# Qty (Range)
		var qty = entry.get("quantity", [1, 1])
		if typeof(qty) != TYPE_ARRAY: qty = [qty, qty]
		
		hb.add_child(InspectorStyle.lbl("Qty:", Color.GRAY))
		var sb_min = SpinBox.new(); sb_min.value = qty[0]; sb_min.custom_minimum_size.x = 50
		InspectorStyle.apply_input_style(sb_min)
		var sb_max = SpinBox.new(); sb_max.value = qty[1]; sb_max.custom_minimum_size.x = 50
		InspectorStyle.apply_input_style(sb_max)
		
		var update_qty = func(_v): entry["quantity"] = [sb_min.value, sb_max.value]; database_modified.emit()
		sb_min.value_changed.connect(update_qty)
		sb_max.value_changed.connect(update_qty)
		
		# Delete
		var btn_del = Button.new(); btn_del.text = "X"; btn_del.flat = true
		btn_del.pressed.connect(func(): table.erase(item_id); database_modified.emit(); _refresh_loot_table())
		hb.add_child(btn_del)
		
		loot_box.add_child(pc)

func _add_loot_entry():
	var popup = PopupMenu.new()
	popup.add_item("Item from DB")
	popup.add_item("Gold Value")
	popup.id_pressed.connect(func(id):
		if id == 1:
			cur_data.loot_table["gold_value"] = {"chance": 0.5, "quantity": [1, 10]}
			_refresh_loot_table()
			database_modified.emit()
		else:
			var k = "new_item_" + str(randi() % 100)
			cur_data.loot_table[k] = {"chance": 0.1, "quantity": [1, 1]}
			_refresh_loot_table()
			database_modified.emit()
	)
	container.add_child(popup)
	popup.position = Vector2i(container.get_global_mouse_position())
	popup.popup()

# --- ITEM SPECIFIC ---

func _build_item_details():
	container.add_child(HSeparator.new())
	container.add_child(InspectorStyle.create_sub_header("Details"))
	
	var card = InspectorStyle.create_card(); var vbox = card.get_child(0).get_child(0)
	container.add_child(card)
	
	# Type
	var hb = HBoxContainer.new()
	hb.add_child(InspectorStyle.lbl("Type:", InspectorStyle.COLOR_TEXT_DIM))
	var type_opt = OptionButton.new()
	var item_types = ["Weapon", "Armor", "Consumable", "Treasure", "Gem", "Junk", "Key", "Tool", "Item", "Material"]
	for t in item_types: type_opt.add_item(t)
	var current_type = cur_data.get("type", "Item")
	var idx = item_types.find(current_type)
	if idx != -1: type_opt.selected = idx
	else:
		type_opt.add_item(current_type) # Handle custom types
		type_opt.select(type_opt.item_count - 1)
	type_opt.item_selected.connect(func(i): cur_data.type = type_opt.get_item_text(i); database_modified.emit())
	type_opt.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	InspectorStyle.apply_button_style(type_opt)
	hb.add_child(type_opt)
	vbox.add_child(hb)
	
	# Weight & Value
	var hb2 = HBoxContainer.new()
	_add_spin_field(hb2, "Weight", "weight", 0.0)
	_add_spin_field(hb2, "Value", "value", 0)
	vbox.add_child(hb2)
	
	# Stackable
	var chk = CheckBox.new(); chk.text = "Stackable"
	chk.button_pressed = cur_data.get("stackable", false)
	chk.toggled.connect(func(b): cur_data.stackable = b; database_modified.emit())
	vbox.add_child(chk)

func _build_item_properties():
	container.add_child(HSeparator.new())
	var hb = HBoxContainer.new()
	hb.add_child(InspectorStyle.create_sub_header("Item Properties"))
	var spacer = Control.new(); spacer.size_flags_horizontal = Control.SIZE_EXPAND_FILL; hb.add_child(spacer)
	var btn_add = Button.new(); btn_add.text = "+ Prop"; InspectorStyle.apply_button_style(btn_add)
	
	# Setup property addition menu
	var pp = PopupMenu.new()
	pp.add_item("String"); pp.add_item("Number"); pp.add_item("Bool"); pp.add_item("Equip Slot")
	pp.id_pressed.connect(_add_item_prop.bind(pp))
	btn_add.pressed.connect(func(): pp.position = Vector2i(btn_add.get_screen_position()) + Vector2i(0, 30); pp.popup())
	container.add_child(pp)
	
	hb.add_child(btn_add); container.add_child(hb)
	
	props_box = VBoxContainer.new(); props_box.add_theme_constant_override("separation", 6)
	container.add_child(props_box)
	
	if not cur_data.has("properties"): cur_data["properties"] = {}
	_refresh_item_props()

func _add_item_prop(id, popup):
	var k = "new_prop"
	var v = ""
	if id == 1: v = 0
	elif id == 2: v = false
	elif id == 3: k = "equip_slot"; v = []
	
	cur_data.properties[k] = v
	database_modified.emit()
	_refresh_item_props()

func _refresh_item_props():
	for c in props_box.get_children(): c.queue_free()
	
	var props = cur_data.properties
	for key in props:
		var val = props[key]
		
		var panel = PanelContainer.new()
		var style = StyleBoxFlat.new(); style.bg_color = Color(0.25, 0.25, 0.28); style.set_corner_radius_all(6)
		style.content_margin_left = 10; style.content_margin_right = 10; style.content_margin_top = 4; style.content_margin_bottom = 4
		panel.add_theme_stylebox_override("panel", style)
		
		var hb = HBoxContainer.new()
		panel.add_child(hb)
		
		# Key
		if key == "equip_slot":
			var l = Label.new(); l.text = "Equip Slots"; l.modulate = Color.CYAN
			hb.add_child(l)
		else:
			var ed_k = LineEdit.new(); ed_k.text = key; ed_k.custom_minimum_size.x = 120
			InspectorStyle.apply_input_style(ed_k)
			# If key changes, we must replace the entry in dictionary
			ed_k.text_submitted.connect(func(t): 
				if t != key and not props.has(t):
					props[t] = val; props.erase(key); database_modified.emit(); _refresh_item_props()
			)
			hb.add_child(ed_k)
		
		var spacer = Control.new(); spacer.size_flags_horizontal = Control.SIZE_EXPAND_FILL; hb.add_child(spacer)
		
		# Value
		if key == "equip_slot" and typeof(val) == TYPE_ARRAY:
			var btn_slots = MenuButton.new(); btn_slots.text = "Select Slots..."
			if not val.is_empty(): btn_slots.text = ",".join(val)
			InspectorStyle.apply_button_style(btn_slots)
			var popup = btn_slots.get_popup()
			popup.hide_on_checkable_item_selection = false
			var slots = ["head", "body", "legs", "feet", "main_hand", "off_hand", "neck", "hands", "ring"]
			for s in slots:
				popup.add_check_item(s)
				popup.set_item_checked(popup.item_count-1, val.has(s))
			
			popup.index_pressed.connect(func(idx):
				var s_name = slots[idx]
				if val.has(s_name): val.erase(s_name)
				else: val.append(s_name)
				popup.set_item_checked(idx, val.has(s_name))
				btn_slots.text = ",".join(val) if not val.is_empty() else "Select Slots..."
				database_modified.emit()
			)
			hb.add_child(btn_slots)
			
		elif typeof(val) == TYPE_BOOL:
			var chk = CheckBox.new(); chk.button_pressed = val; chk.text = "True" if val else "False"
			chk.toggled.connect(func(b): props[key] = b; chk.text = "True" if b else "False"; database_modified.emit())
			hb.add_child(chk)
		elif typeof(val) == TYPE_FLOAT or typeof(val) == TYPE_INT:
			var sb = SpinBox.new(); sb.step = 0.1; sb.allow_greater = true; sb.allow_lesser = true
			sb.value = val; sb.custom_minimum_size.x = 80
			InspectorStyle.apply_input_style(sb)
			sb.value_changed.connect(func(v): props[key] = v; database_modified.emit())
			hb.add_child(sb)
		else:
			var ed_v = LineEdit.new(); ed_v.text = str(val); ed_v.custom_minimum_size.x = 150
			InspectorStyle.apply_input_style(ed_v)
			ed_v.text_changed.connect(func(t): props[key] = t; database_modified.emit())
			hb.add_child(ed_v)
			
		var btn_x = Button.new(); btn_x.text = "Ã—"; btn_x.flat = true
		btn_x.add_theme_color_override("font_color", Color(0.6, 0.6, 0.6))
		btn_x.add_theme_color_override("font_hover_color", Color.RED)
		btn_x.pressed.connect(func(): props.erase(key); database_modified.emit(); _refresh_item_props())
		hb.add_child(btn_x)
		
		props_box.add_child(panel)
# scripts/ui/SidePanel.gd
class_name SidePanel
extends Panel

# Signals
signal request_load_region(filename)
signal request_jump_to_room(id)
signal snap_toggled(is_on)
signal request_validate
signal tool_changed(mode, data)
signal request_create_db_entry(type) 
signal request_delete_db_entry(type, id)
signal request_select_db_entry(type, id)
signal request_auto_layout
signal request_create_modal_open
signal request_context_menu(global_pos, meta)

# UI Components
var explorer_panel: ExplorerPanel
var database_tree: Tree
var db_filter_opt: OptionButton
var palette_list: ItemList
var template_list: ItemList
var paint_key_edit: LineEdit
var paint_val_edit: LineEdit

# Button Refs for State Updates
var btn_stop_template: Button
var btn_stop_palette: Button

# Data Cache
var _cached_npcs: Dictionary = {}
var _cached_items: Dictionary = {}
var _cached_magic: Dictionary = {}
var _cached_quests: Dictionary = {}
var _cached_templates: Dictionary = {}

func setup():
	anchor_right = 0.20
	anchor_bottom = 0.96
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.1, 0.1, 0.12, 0.95)
	style.set_border_width_all(1)
	style.border_color = Color(0.3, 0.3, 0.35, 0.95)
	add_theme_stylebox_override("panel", style)
	
	var vbox = VBoxContainer.new()
	vbox.set_anchors_preset(Control.PRESET_FULL_RECT)
	vbox.offset_left=10; vbox.offset_top=10; vbox.offset_right=-10; vbox.offset_bottom=-10
	add_child(vbox)
	
	var tabs = TabContainer.new()
	tabs.size_flags_vertical = 3 
	vbox.add_child(tabs)
	
	_setup_explorer_tab(tabs)
	_setup_database_tab(tabs)
	_setup_templates_tab(tabs)
	_setup_palette_tab(tabs)
	_setup_paint_tab(tabs)
	
	return vbox

# --- PUBLIC API FOR UI UPDATES ---

func update_stamp_button_state(is_stamping: bool):
	var text = "Stop Stamping (ESC)" if is_stamping else "Select Item to Stamp"
	var col = Color(0.3, 0.1, 0.1) if is_stamping else Color(0.1, 0.1, 0.12)
	
	if btn_stop_template:
		btn_stop_template.text = text
		btn_stop_template.disabled = not is_stamping
		_apply_style(btn_stop_template, col)
		
	if btn_stop_palette:
		btn_stop_palette.text = text
		btn_stop_palette.disabled = not is_stamping
		_apply_style(btn_stop_palette, col)
	
	# Deselect lists if not stamping
	if not is_stamping:
		template_list.deselect_all()
		palette_list.deselect_all()

func _create_tab_margin(name: String) -> MarginContainer:
	var m = MarginContainer.new()
	m.name = name
	m.add_theme_constant_override("margin_left", 5)
	m.add_theme_constant_override("margin_right", 5)
	m.add_theme_constant_override("margin_top", 12)
	m.add_theme_constant_override("margin_bottom", 5)
	return m

func _setup_explorer_tab(tabs: TabContainer):
	var margin = _create_tab_margin("Explorer")
	explorer_panel = ExplorerPanel.new()
	explorer_panel.setup()
	explorer_panel.request_load_region.connect(func(f): request_load_region.emit(f))
	explorer_panel.request_jump_to_room.connect(func(id): request_jump_to_room.emit(id))
	explorer_panel.request_create_modal_open.connect(func(): request_create_modal_open.emit())
	explorer_panel.request_validate.connect(func(): request_validate.emit())
	explorer_panel.request_auto_layout.connect(func(): request_auto_layout.emit())
	explorer_panel.snap_toggled.connect(func(b): snap_toggled.emit(b))
	explorer_panel.request_context_menu.connect(func(p, m): request_context_menu.emit(p, m))
	
	margin.add_child(explorer_panel)
	tabs.add_child(margin)

func _setup_database_tab(tabs: TabContainer):
	var margin = _create_tab_margin("Database")
	var db_vbox = VBoxContainer.new(); db_vbox.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	db_vbox.add_theme_constant_override("separation", 12)
	
	var db_head = HBoxContainer.new()
	db_filter_opt = OptionButton.new()
	db_filter_opt.add_item("NPCs")
	db_filter_opt.add_item("Items")
	db_filter_opt.add_item("Magic")
	db_filter_opt.add_item("Quests")
	_apply_style(db_filter_opt)
	db_filter_opt.item_selected.connect(func(_i): _refresh_db_list())
	db_head.add_child(db_filter_opt)
	db_vbox.add_child(db_head)
	
	database_tree = Tree.new()
	database_tree.size_flags_vertical = SIZE_EXPAND_FILL
	database_tree.hide_root = true
	database_tree.select_mode = Tree.SELECT_ROW
	database_tree.allow_rmb_select = true
	
	var tree_style = StyleBoxFlat.new()
	tree_style.bg_color = Color(0.05, 0.05, 0.08)
	database_tree.add_theme_stylebox_override("bg", tree_style)
	
	database_tree.item_selected.connect(func():
		var item = database_tree.get_selected()
		if not item: return
		var meta = item.get_metadata(0)
		if meta and meta.has("id"):
			var type = _get_current_db_type()
			request_select_db_entry.emit(type, meta.id)
	)
	
	database_tree.gui_input.connect(func(event):
		if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_RIGHT and event.pressed:
			var pos = event.position
			var item = database_tree.get_item_at_position(pos)
			if item:
				var meta = item.get_metadata(0)
				if meta and meta.has("id"):
					item.select(0) 
					var type = _get_current_db_type()
					var global_pos = database_tree.get_global_position() + pos
					var context_meta = {"type": "db_entry", "kind": type, "id": meta.id}
					request_context_menu.emit(global_pos, context_meta)
					get_viewport().set_input_as_handled()
	)
	
	db_vbox.add_child(database_tree)
	
	var db_btns = HBoxContainer.new()
	var btn_mk_db = Button.new(); btn_mk_db.text="Create"; btn_mk_db.size_flags_horizontal=3
	_apply_style(btn_mk_db, Color(0.2,0.3,0.2))
	btn_mk_db.pressed.connect(func(): request_create_db_entry.emit(_get_current_db_type()))
	db_btns.add_child(btn_mk_db)
	
	var btn_del_db = Button.new(); btn_del_db.text="Delete"; btn_del_db.size_flags_horizontal=3
	_apply_style(btn_del_db, Color(0.3,0.1,0.1))
	btn_del_db.pressed.connect(func():
		var item = database_tree.get_selected()
		if not item: return
		var meta = item.get_metadata(0)
		if meta and meta.has("id"):
			request_delete_db_entry.emit(_get_current_db_type(), meta.id)
	)
	db_btns.add_child(btn_del_db)
	
	margin.add_child(db_vbox)
	tabs.add_child(margin)

func _get_current_db_type() -> String:
	match db_filter_opt.selected:
		0: return "npc"
		1: return "item"
		2: return "magic"
		3: return "quest"
	return "npc"

func _setup_templates_tab(tabs: TabContainer):
	var margin = _create_tab_margin("Templates")
	var t_vbox = VBoxContainer.new(); t_vbox.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	t_vbox.add_theme_constant_override("separation", 12)
	
	t_vbox.add_child(_lbl("Room Prefabs:", Color.GRAY))
	
	template_list = ItemList.new(); template_list.size_flags_vertical = 3
	template_list.add_theme_stylebox_override("bg", StyleBoxFlat.new())
	template_list.get_theme_stylebox("bg").bg_color = Color(0.05, 0.05, 0.08)
	
	# Change to item_clicked to allow re-selection
	template_list.item_clicked.connect(func(idx, pos, btn):
		if btn == MOUSE_BUTTON_LEFT:
			tool_changed.emit(EditorUIManager.ToolMode.STAMP, {"type": "room_template", "id": template_list.get_item_metadata(idx)})
		elif btn == MOUSE_BUTTON_RIGHT:
			var id = template_list.get_item_metadata(idx)
			var global_pos = template_list.get_global_position() + pos
			var meta = {"type": "db_entry", "kind": "template", "id": id}
			request_context_menu.emit(global_pos, meta)
	)
	
	t_vbox.add_child(template_list)
	
	var btn_del = Button.new(); btn_del.text = "Delete Template"
	_apply_style(btn_del, Color(0.3, 0.1, 0.1))
	btn_del.pressed.connect(func():
		if not template_list.is_anything_selected(): return
		var idx = template_list.get_selected_items()[0]
		request_delete_db_entry.emit("template", template_list.get_item_metadata(idx))
	)
	t_vbox.add_child(btn_del)
	
	btn_stop_template = Button.new()
	btn_stop_template.text = "Select Item to Stamp"
	btn_stop_template.disabled = true
	_apply_style(btn_stop_template, Color(0.1, 0.1, 0.12))
	btn_stop_template.pressed.connect(func(): tool_changed.emit(EditorUIManager.ToolMode.SELECT, {}))
	t_vbox.add_child(btn_stop_template)
	
	margin.add_child(t_vbox)
	tabs.add_child(margin)

func _setup_palette_tab(tabs: TabContainer):
	var margin = _create_tab_margin("Palette")
	var pal_vbox = VBoxContainer.new(); pal_vbox.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	pal_vbox.add_theme_constant_override("separation", 12)
	
	pal_vbox.add_child(_lbl("Content Stamper:", Color.GRAY))
	palette_list = ItemList.new(); palette_list.size_flags_vertical = 3
	palette_list.add_theme_stylebox_override("bg", StyleBoxFlat.new())
	palette_list.get_theme_stylebox("bg").bg_color = Color(0.05, 0.05, 0.08)
	
	# Change to item_clicked to allow re-selection
	palette_list.item_clicked.connect(func(idx, pos, btn):
		if btn == MOUSE_BUTTON_LEFT:
			tool_changed.emit(EditorUIManager.ToolMode.STAMP, palette_list.get_item_metadata(idx))
	)
	pal_vbox.add_child(palette_list)
	
	btn_stop_palette = Button.new()
	btn_stop_palette.text = "Select Item to Stamp"
	btn_stop_palette.disabled = true
	_apply_style(btn_stop_palette, Color(0.1, 0.1, 0.12))
	btn_stop_palette.pressed.connect(func(): tool_changed.emit(EditorUIManager.ToolMode.SELECT, {}))
	pal_vbox.add_child(btn_stop_palette)
	
	margin.add_child(pal_vbox)
	tabs.add_child(margin)

func _setup_paint_tab(tabs: TabContainer):
	var margin = _create_tab_margin("Paint")
	var pnt_vbox = VBoxContainer.new(); pnt_vbox.size_flags_horizontal = Control.SIZE_EXPAND_FILL
	pnt_vbox.add_theme_constant_override("separation", 12)
	
	pnt_vbox.add_child(_lbl("Key:", Color.GRAY))
	paint_key_edit = LineEdit.new(); paint_key_edit.text = "biome"; _apply_style(paint_key_edit)
	pnt_vbox.add_child(paint_key_edit)
	pnt_vbox.add_child(_lbl("Value:", Color.GRAY))
	paint_val_edit = LineEdit.new(); paint_val_edit.text = "swamp"; _apply_style(paint_val_edit)
	pnt_vbox.add_child(paint_val_edit)
	pnt_vbox.add_child(HSeparator.new())
	var btn_start_paint = Button.new(); btn_start_paint.text = "Activate Paint Mode"; _apply_style(btn_start_paint, Color(0.2, 0.3, 0.2))
	btn_start_paint.pressed.connect(func(): tool_changed.emit(EditorUIManager.ToolMode.PAINT, {"key": paint_key_edit.text, "val": paint_val_edit.text}))
	pnt_vbox.add_child(btn_start_paint)
	var btn_stop_paint = Button.new(); btn_stop_paint.text = "Stop Painting (ESC)"; _apply_style(btn_stop_paint)
	btn_stop_paint.pressed.connect(func(): tool_changed.emit(EditorUIManager.ToolMode.SELECT, {}))
	pnt_vbox.add_child(btn_stop_paint)
	
	margin.add_child(pnt_vbox)
	tabs.add_child(margin)

func update_db_lists(npcs: Dictionary, items: Dictionary, templates: Dictionary, magic: Dictionary, quests: Dictionary):
	_cached_npcs = npcs
	_cached_items = items
	_cached_templates = templates
	_cached_magic = magic
	_cached_quests = quests
	_refresh_db_list()
	_refresh_palette()
	_refresh_templates()

func refresh_explorer(h, c, s): explorer_panel.update_data(h, c, s) 
func select_room_item(id): explorer_panel.select_room_item(id)
func update_dirty_visuals(cur, dirty, rooms): explorer_panel.update_dirty_visuals(cur, dirty, rooms)
func update_layout_btn_text(is_world: bool): explorer_panel.update_layout_btn_text(is_world)

func _refresh_db_list():
	database_tree.clear()
	var root = database_tree.create_item()
	var mode = db_filter_opt.selected
	var data_source = {}
	
	match mode:
		0: data_source = _cached_npcs
		1: data_source = _cached_items
		2: data_source = _cached_magic
		3: data_source = _cached_quests
	
	# 1. Group by Filename
	var groups = {}
	for id in data_source:
		var entry = data_source[id]
		var fname = entry.get("_filename", "custom.json")
		var group_name = fname.get_file().replace(".json", "").to_upper()
		
		if not groups.has(group_name): groups[group_name] = []
		groups[group_name].append(id)
	
	var group_keys = groups.keys()
	group_keys.sort()
	
	# 2. Build Tree
	for g_name in group_keys:
		var group_item = database_tree.create_item(root)
		group_item.set_text(0, g_name)
		group_item.set_selectable(0, false)
		group_item.set_custom_color(0, Color(0.7, 0.7, 0.7))
		group_item.set_custom_bg_color(0, Color(0.12, 0.12, 0.15))
		
		var ids = groups[g_name]
		ids.sort()
		
		for id in ids:
			var entry = data_source[id]
			var item = database_tree.create_item(group_item)
			item.set_text(0, id)
			item.set_metadata(0, {"id": id})
			
			var col = Color.WHITE
			if mode == 0: # NPC
				if entry.get("friendly", true): col = Color.LIGHT_GREEN
				else: col = Color.SALMON
			elif mode == 1: # Item
				var type = entry.get("type", "Item")
				match type:
					"Weapon": col = Color.SALMON
					"Armor": col = Color.CORNFLOWER_BLUE
					"Consumable": col = Color.LIGHT_GREEN
					"Treasure", "Gem": col = Color.GOLD
					"Junk": col = Color.WEB_GRAY
					"Key", "Tool": col = Color.SANDY_BROWN
					_: col = Color.AQUAMARINE
			elif mode == 2: col = Color.VIOLET
			elif mode == 3: col = Color.GOLD
			
			item.set_icon(0, _get_color_icon(col))

func _refresh_palette():
	palette_list.clear()
	# NPCs
	var n_keys = _cached_npcs.keys()
	n_keys.sort()
	for n in n_keys: 
		var idx=palette_list.add_item("NPC: "+n)
		palette_list.set_item_metadata(idx, {"type":"npc","id":n})
		palette_list.set_item_icon(idx, _get_color_icon(Color.SALMON))
	
	# Items
	var i_keys = _cached_items.keys()
	i_keys.sort()
	for i in i_keys: 
		var idx=palette_list.add_item("Item: "+i)
		palette_list.set_item_metadata(idx, {"type":"item","id":i})
		palette_list.set_item_icon(idx, _get_color_icon(Color.AQUAMARINE))

func _refresh_templates():
	template_list.clear()
	var t_keys = _cached_templates.keys()
	t_keys.sort()
	for t in t_keys:
		var idx = template_list.add_item(t)
		template_list.set_item_metadata(idx, t)
		template_list.set_item_icon(idx, _get_color_icon(Color.GOLD))

func _apply_style(node: Control, bg_color = Color(0.15, 0.15, 0.18)):
	var s = StyleBoxFlat.new(); s.bg_color = bg_color; s.set_border_width_all(1); s.border_color = Color(0.4, 0.4, 0.45); s.set_corner_radius_all(4); s.content_margin_left = 8; s.content_margin_right = 8
	if node is Button:
		node.add_theme_stylebox_override("normal", s); node.add_theme_stylebox_override("hover", s.duplicate()); node.add_theme_stylebox_override("pressed", s.duplicate())
		node.get_theme_stylebox("hover").bg_color = bg_color.lightened(0.1); node.get_theme_stylebox("pressed").bg_color = bg_color.darkened(0.1)
		
		# Apply to disabled too so it doesn't revert to default theme
		var dis = s.duplicate(); dis.bg_color = bg_color.darkened(0.2); dis.border_color = Color(0.3, 0.3, 0.3)
		node.add_theme_stylebox_override("disabled", dis)
	elif node is LineEdit:
		var s2 = s.duplicate(); s2.bg_color = Color(0.08,0.08,0.1); node.add_theme_stylebox_override("normal", s2)

func _get_color_icon(col: Color) -> ImageTexture:
	var img = Image.create(16, 16, false, Image.FORMAT_RGBA8); img.fill(col); return ImageTexture.create_from_image(img)

func _lbl(t, c=Color.WHITE): var l=Label.new(); l.text=t; l.modulate=c; return l
# scripts/scenes/RegionScene.gd
class_name RegionScene
extends Node2D

signal region_selected(region_id)
signal region_moved_committed(old_pos, new_pos)
signal region_dragged(new_pos)
signal request_edit(region_id)

var region_id: String = ""
var dragging: bool = false
var drag_start_pos: Vector2
var _is_selected: bool = false

# Layout Data
var content_rect: Rect2 # The static area containing the nodes
var bg_color: Color
var cached_rooms: Dictionary = {}

const ROOM_SIZE = Vector2(80, 80)
const PADDING = 200.0
const MIN_VISUAL_SIZE = Vector2(2000, 1500)
const BASE_HEADER_HEIGHT = 60.0 # Base height before scaling

func setup(id: String, data: Dictionary, color: Color):
	region_id = id
	bg_color = color
	cached_rooms = data.get("rooms", {})
	
	# 1. Calculate the actual bounds of the room nodes themselves.
	var min_p = Vector2(INF, INF)
	var max_p = Vector2(-INF, -INF)
	var has_rooms = false
	
	for r_id in cached_rooms:
		has_rooms = true
		var ep = cached_rooms[r_id].get("_editor_pos", [0, 0])
		var local_pos = Vector2(ep[0], ep[1])
		
		min_p.x = min(min_p.x, local_pos.x)
		min_p.y = min(min_p.y, local_pos.y)
		max_p.x = max(max_p.x, local_pos.x)
		max_p.y = max(max_p.y, local_pos.y)
	
	if not has_rooms:
		min_p = Vector2(-100, -100)
		max_p = Vector2(100, 100)
	
	# 2. Determine the final size of the content area, enforcing the minimum size.
	var content_size_raw = (max_p - min_p) + ROOM_SIZE
	var final_content_area_size = Vector2(
		max(content_size_raw.x, MIN_VISUAL_SIZE.x),
		max(content_size_raw.y, MIN_VISUAL_SIZE.y)
	)
	
	# 3. Center the final, padded box on the geometric center of the actual content.
	var content_geometric_center = min_p + (content_size_raw / 2.0)
	var final_padded_size = final_content_area_size + Vector2(PADDING * 2, PADDING * 2)
	
	content_rect = Rect2(
		content_geometric_center - (final_padded_size / 2.0),
		final_padded_size
	)
	
	queue_redraw()

func set_selected(is_selected: bool):
	_is_selected = is_selected
	queue_redraw()

func get_global_center() -> Vector2:
	return global_position + content_rect.get_center()

func get_room_local_center(room_id: String) -> Vector2:
	if cached_rooms.has(room_id):
		return _get_vec(cached_rooms[room_id]) + (ROOM_SIZE / 2.0)
	return Vector2.ZERO

func _get_current_visuals(zoom: float) -> Dictionary:
	# Calculate dynamic scaling based on zoom
	var scale_factor = clamp(1.0 / sqrt(zoom), 1.0, 4.0)
	
	# Counteract the node's own scale to keep visuals consistent
	var inv_scale = 1.0 / self.scale.x
	
	# Scale the header's base height to compensate for the node's scale
	var effective_header_height = BASE_HEADER_HEIGHT * scale_factor * inv_scale
	
	# Grow header UPWARDS from content rect using the correctly scaled height
	var header_r = Rect2(
		content_rect.position.x, 
		content_rect.position.y - effective_header_height,
		content_rect.size.x, 
		effective_header_height
	)
	
	var total_r = header_r.merge(content_rect)
	
	# If the node is scaled (i.e., in World View), use a smaller base font size.
	var base_font_size = 16.0 if self.scale.x < 1.0 else 32.0
	
	return {
		"scale": scale_factor,
		"header_rect": header_r,
		"main_rect": total_r,
		# Font size also needs to be scaled up to look correct after node scaling
		"font_size": int((base_font_size * scale_factor) * inv_scale)
	}

func _draw():
	var cam = get_viewport().get_camera_2d()
	var zoom = cam.zoom.x if cam else 1.0
	var viz = _get_current_visuals(zoom)
	
	var scale_factor = viz.scale
	var header_rect = viz.header_rect
	var main_rect = viz.main_rect
	
	# Palette
	var col_header = bg_color.darkened(0.2)
	var col_content = bg_color.darkened(0.6)
	col_content.a = 0.95
	var col_border = Color(0.85, 0.85, 0.85, 1.0)
	var col_text = Color(1, 1, 1, 1.0)
	
	# Counteract node scale for consistent visual weight
	var inv_scale = 1.0 / self.scale.x
	
	# 1. Drop Shadow
	var shadow_off = Vector2(16, 16) * scale_factor * inv_scale
	draw_rect(Rect2(main_rect.position + shadow_off, main_rect.size), Color(0,0,0,0.5), true)
	
	# 2. Backgrounds
	draw_rect(content_rect, col_content, true)
	draw_rect(header_rect, col_header, true)
	
	# 3. Frame / Border
	var border_w = 4.0 * scale_factor * inv_scale
	# Draw outer frame
	draw_rect(main_rect, col_border, false, border_w)
	
	# Draw header divider bar using a filled rectangle for proper height
	var bar_y = content_rect.position.y
	draw_rect(
		Rect2(main_rect.position.x, bar_y - (border_w / 2.0), main_rect.size.x, border_w),
		col_border
	)
	
	# 4. Title
	var font = ThemeDB.get_fallback_font()
	var title = region_id.capitalize().replace("_", " ")
	var font_size = viz.font_size
	
	# Center text in header rect
	var str_size = font.get_string_size(title, HORIZONTAL_ALIGNMENT_CENTER, -1, font_size)
	var center_x = header_rect.position.x + (header_rect.size.x / 2.0) - (str_size.x / 2.0)
	var center_y = header_rect.position.y + (header_rect.size.y / 2.0) + (str_size.y / 3.0)
	
	draw_string(font, Vector2(center_x, center_y), title, HORIZONTAL_ALIGNMENT_LEFT, -1, font_size, col_text)
	
	# 5. Internal Connections
	for r_id in cached_rooms:
		var start = _get_vec(cached_rooms[r_id]) + (ROOM_SIZE/2)
		var exits = cached_rooms[r_id].get("exits", {})
		for dir in exits:
			var target = exits[dir]
			if not ":" in target and cached_rooms.has(target):
				var end = _get_vec(cached_rooms[target]) + (ROOM_SIZE/2)
				draw_line(start, end, Color(1, 1, 1, 0.15), 2.0 * scale_factor * inv_scale)

	# 6. Nodes (Rooms)
	var node_col = Color(0.9, 0.9, 0.9, 0.5)
	for r_id in cached_rooms:
		var pos = _get_vec(cached_rooms[r_id])
		var rect = Rect2(pos, ROOM_SIZE)
		draw_rect(rect, node_col, true)
		draw_rect(rect, Color(0,0,0,0.5), false, 1.0 * scale_factor * inv_scale)
		
	# 7. Draw Selection Highlight (if selected)
	if _is_selected:
		var select_border_width = 8.0 * scale_factor * inv_scale
		draw_rect(main_rect, Color.GOLD, false, select_border_width)

func _get_vec(r_data) -> Vector2:
	var ep = r_data.get("_editor_pos", [0,0])
	return Vector2(ep[0], ep[1])

func _unhandled_input(event):
	if event is InputEventMouseButton:
		var cam = get_viewport().get_camera_2d()
		var zoom = cam.zoom.x if cam else 1.0
		var viz = _get_current_visuals(zoom)
		var hit_rect = viz.main_rect
		
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.pressed:
				var local_mouse = get_local_mouse_position()
				if hit_rect.has_point(local_mouse):
					dragging = true
					drag_start_pos = position
					region_selected.emit(region_id)
					get_viewport().set_input_as_handled()
			else:
				if dragging:
					dragging = false
					if position.distance_to(drag_start_pos) > 1.0:
						region_moved_committed.emit(drag_start_pos, position)
		
		elif event.button_index == MOUSE_BUTTON_RIGHT and event.pressed:
			var local_mouse = get_local_mouse_position()
			if hit_rect.has_point(local_mouse):
				request_edit.emit(region_id)
				get_viewport().set_input_as_handled()

	if event is InputEventMouseMotion and dragging:
		var cam = get_viewport().get_camera_2d()
		var zoom = cam.zoom if cam else Vector2.ONE
		position += event.relative / zoom
		region_dragged.emit(position)
# scripts/scenes/QuestNode.gd
extends Control

signal selected(stage_idx)
signal dragged(new_pos)
signal drag_ended

var stage_index: int = -1
var stage_data: Dictionary = {}

var dragging = false
var drag_offset = Vector2()
var _is_selected = false

func setup(idx: int, data: Dictionary):
	stage_index = idx
	stage_data = data
	
	var panel = PanelContainer.new()
	var style = StyleBoxFlat.new()
	style.bg_color = Color(0.1, 0.1, 0.15)
	style.set_corner_radius_all(8)
	style.set_border_width_all(2)
	style.border_color = Color(0.4, 0.4, 0.8)
	panel.add_theme_stylebox_override("panel", style)
	panel.mouse_filter = Control.MOUSE_FILTER_PASS
	
	var margin = MarginContainer.new()
	margin.add_theme_constant_override("margin_left", 8)
	margin.add_theme_constant_override("margin_right", 8)
	margin.add_theme_constant_override("margin_top", 6)
	margin.add_theme_constant_override("margin_bottom", 6)
	panel.add_child(margin)
	
	var vbox = VBoxContainer.new()
	margin.add_child(vbox)
	
	var lbl_id = Label.new()
	lbl_id.text = data.get("id", "stage_%d" % idx)
	lbl_id.add_theme_font_size_override("font_size", 14)
	lbl_id.modulate = Color.CYAN
	vbox.add_child(lbl_id)
	
	var lbl_type = Label.new()
	lbl_type.text = data.get("type", "EVENT")
	lbl_type.add_theme_font_size_override("font_size", 10)
	lbl_type.modulate = Color(0.7, 0.7, 0.7)
	vbox.add_child(lbl_type)
	
	add_child(panel)
	custom_minimum_size = Vector2(140, 60)
	
	# Input Handling
	gui_input.connect(_on_gui_input)

func set_selected(val: bool):
	_is_selected = val
	var p = get_child(0) as PanelContainer
	var s = p.get_theme_stylebox("panel") as StyleBoxFlat
	s.border_color = Color.GOLD if val else Color(0.4, 0.4, 0.8)

func _on_gui_input(event):
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.pressed:
				dragging = true
				drag_offset = get_global_mouse_position() - global_position
				selected.emit(stage_index)
			else:
				if dragging:
					dragging = false
					drag_ended.emit()
	
	if event is InputEventMouseMotion and dragging:
		global_position = get_global_mouse_position() - drag_offset
		dragged.emit(global_position)
# scripts/scenes/RoomScene.gd
extends Node2D

signal room_selected(room_id)
signal dragged(new_position)
signal right_clicked
signal connection_drag_started(room_id)
signal creation_drag_started(room_id, anchor_pos)
signal drag_started
signal drag_ended

var dragging = false
var drag_offset = Vector2()

var _current_color: Color = Color(0.2, 0.2, 0.2)
var _is_selected: bool = false
var _is_proxy: bool = false
var _is_highlighted: bool = false
var snap_step: int = 0

# State variables for icons
var _npc_visible: bool = false
var _item_visible: bool = false
var _start_visible: bool = false
var _custom_icon_id: String = ""
var _properties: Dictionary = {}

# Data Cache
var _cached_name: String = "Unnamed"
var _cached_id: String = ""

@onready var visual_panel = $VisualPanel

# Internal UI References
var main_layout: VBoxContainer
var id_label: Label
var name_label: Label
var content_container: Control 
var anchor_container: Control
var panel_style: StyleBoxFlat

func _ready():
	# 1. Panel Styling
	var existing_style = visual_panel.get_theme_stylebox("panel")
	if existing_style and existing_style is StyleBoxFlat:
		panel_style = existing_style.duplicate()
	else:
		panel_style = StyleBoxFlat.new()
	
	panel_style.set_corner_radius_all(6)
	panel_style.set_border_width_all(2)
	panel_style.border_color = Color(0.8, 0.8, 0.8, 0.5)
	panel_style.shadow_size = 4
	panel_style.shadow_offset = Vector2(0, 2)
	panel_style.shadow_color = Color(0, 0, 0, 0.4)
	
	visual_panel.add_theme_stylebox_override("panel", panel_style)
	visual_panel.gui_input.connect(_on_panel_gui_input)
	visual_panel.mouse_entered.connect(_on_mouse_entered)
	visual_panel.mouse_exited.connect(_on_mouse_exited)
	visual_panel.mouse_filter = Control.MOUSE_FILTER_STOP
	visual_panel.draw.connect(_draw_icons)
	
	# 2. Build Layout Structure
	main_layout = VBoxContainer.new()
	main_layout.name = "MainLayout"
	main_layout.set_anchors_preset(Control.PRESET_FULL_RECT)
	main_layout.offset_left = 4; main_layout.offset_right = -4
	main_layout.offset_top = 4; main_layout.offset_bottom = -4
	main_layout.alignment = BoxContainer.ALIGNMENT_CENTER
	main_layout.mouse_filter = Control.MOUSE_FILTER_IGNORE
	visual_panel.add_child(main_layout)
	
	# 3. Capture or Create Labels
	name_label = visual_panel.get_node_or_null("NameLabel")
	if not name_label: name_label = Label.new(); name_label.name = "NameLabel"
	if name_label.get_parent() != main_layout:
		if name_label.get_parent(): name_label.get_parent().remove_child(name_label)
		main_layout.add_child(name_label)
	
	name_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	name_label.add_theme_font_size_override("font_size", 13)
	name_label.modulate = Color(1, 1, 1, 1.0)
	name_label.size_flags_vertical = Control.SIZE_SHRINK_CENTER
	
	id_label = visual_panel.get_node_or_null("IDLabel")
	if not id_label: id_label = Label.new(); id_label.name = "IDLabel"
	if id_label.get_parent() != main_layout:
		if id_label.get_parent(): id_label.get_parent().remove_child(id_label)
		main_layout.add_child(id_label)
		
	id_label.horizontal_alignment = HORIZONTAL_ALIGNMENT_CENTER
	id_label.add_theme_font_size_override("font_size", 9)
	id_label.modulate = Color(1, 1, 1, 0.5)
	
	# 4. Handle Anchors
	anchor_container = visual_panel.get_node_or_null("AnchorContainer")
	if anchor_container:
		anchor_container.move_to_front()
		anchor_container.visible = false
		anchor_container.mouse_filter = Control.MOUSE_FILTER_IGNORE
		for child in anchor_container.get_children():
			if child is Control:
				child.mouse_filter = Control.MOUSE_FILTER_STOP
				child.gui_input.connect(func(ev): _on_anchor_gui_input(ev, child))

	if _is_proxy: set_as_proxy(true)
	else: set_node_color(_current_color)
	
	if name_label: name_label.text = _cached_name
	if id_label: id_label.text = _cached_id
	
	update_icons(_npc_visible, _item_visible, _start_visible, _custom_icon_id, _properties)
	_update_border()

func get_connection_anchor_point(dir: String) -> Vector2:
	var pos = visual_panel.position
	var size = visual_panel.size
	var c = pos + (size / 2.0)
	var d = dir.to_lower()
	
	if d in ["up", "down", "in", "out", "climb", "dive"]: return to_global(c)
	if d in ["north", "n"]: return to_global(Vector2(c.x, pos.y))
	if d in ["south", "s"]: return to_global(Vector2(c.x, pos.y + size.y))
	if d in ["east", "e"]: return to_global(Vector2(pos.x + size.x, c.y))
	if d in ["west", "w"]: return to_global(Vector2(pos.x, c.y))
	if d in ["northeast", "ne"]: return to_global(Vector2(pos.x + size.x, pos.y))
	if d in ["northwest", "nw"]: return to_global(Vector2(pos.x, pos.y))
	if d in ["southeast", "se"]: return to_global(Vector2(pos.x + size.x, pos.y + size.y))
	if d in ["southwest", "sw"]: return to_global(Vector2(pos.x, pos.y + size.y))
	return to_global(c)

func set_info(name_text: String, id_text: String):
	_cached_name = name_text
	_cached_id = id_text
	if name_label: name_label.text = name_text
	if id_label: id_label.text = id_text

func set_as_proxy(is_proxy: bool):
	_is_proxy = is_proxy
	if is_node_ready() and visual_panel:
		if is_proxy:
			modulate.a = 0.9
			set_node_color(Color(0.15, 0.25, 0.35)) 
			if id_label: id_label.modulate = Color(0.6, 0.8, 1.0)
		else:
			modulate.a = 1.0
			if id_label: id_label.modulate = Color(1, 1, 1, 0.5)
	_update_border()

func set_node_color(color: Color):
	_current_color = color
	if is_node_ready() and panel_style:
		panel_style.bg_color = color
		_update_border()

func update_icons(has_npcs: bool, has_items: bool, is_start: bool, custom_icon_id: String, properties: Dictionary):
	_npc_visible = has_npcs
	_item_visible = has_items
	_start_visible = is_start
	_custom_icon_id = custom_icon_id
	_properties = properties
	
	if not is_node_ready(): return
	visual_panel.queue_redraw()

func _draw_icons():
	# Draw vector icons based on property tags
	var x_offset = 5.0
	var y_offset = 5.0
	var icon_size = 8.0
	
	# Draw Standard Status Icons
	if _start_visible:
		_draw_shape(Vector2(x_offset + 4, y_offset + 4), "star", Color.GOLD, icon_size)
		x_offset += 12
	if _npc_visible:
		_draw_shape(Vector2(x_offset + 4, y_offset + 4), "face", Color.SALMON, icon_size)
		x_offset += 12
	if _item_visible:
		_draw_shape(Vector2(x_offset + 4, y_offset + 4), "box", Color.AQUAMARINE, icon_size)
		x_offset += 12
		
	# Draw Property Icons
	for key in _properties:
		var val = _properties[key]
		# Only draw properties that are true or are specific strings, based on Constants
		if Constants.ICON_DEFINITIONS.has(key) and (val == true or typeof(val) == TYPE_STRING):
			var def = Constants.ICON_DEFINITIONS[key]
			_draw_shape(Vector2(x_offset + 4, y_offset + 4), def.shape, def.color, icon_size)
			x_offset += 12
			if x_offset > visual_panel.size.x - 10: break # Avoid overflow

func _draw_shape(pos: Vector2, shape: String, col: Color, r: float):
	var p = visual_panel
	match shape:
		"circle": p.draw_circle(pos, r/2, col)
		"box": p.draw_rect(Rect2(pos - Vector2(r/2, r/2), Vector2(r,r)), col)
		"star": 
			var pts = PackedVector2Array()
			for i in range(5):
				var a = deg_to_rad(i * 72 - 90)
				pts.append(pos + Vector2(cos(a), sin(a)) * (r/2))
			p.draw_colored_polygon(pts, col)
		"moon":
			p.draw_circle(pos, r/2, col)
			p.draw_circle(pos + Vector2(2, -1), r/2.2, _current_color) # Cutout
		"drop":
			var pts = [pos + Vector2(0, -r/2), pos + Vector2(r/2, r/2), pos + Vector2(-r/2, r/2)]
			p.draw_colored_polygon(PackedVector2Array(pts), col)
		"skull":
			p.draw_circle(pos, r/2, col)
			p.draw_rect(Rect2(pos + Vector2(-r/4, r/4), Vector2(r/2, r/3)), col)
		"shield":
			var pts = [pos + Vector2(-r/2, -r/2), pos + Vector2(r/2, -r/2), pos + Vector2(0, r/2)]
			p.draw_colored_polygon(PackedVector2Array(pts), col)
		"tree":
			var pts = [pos + Vector2(0, -r/2), pos + Vector2(r/2, r/2), pos + Vector2(-r/2, r/2)]
			p.draw_colored_polygon(PackedVector2Array(pts), col)
			p.draw_rect(Rect2(pos + Vector2(-1, r/2), Vector2(2, 2)), Color.BROWN)
		"note":
			p.draw_rect(Rect2(pos - Vector2(r/4, r/2), Vector2(r/2, r)), col)
		"flake":
			p.draw_line(pos + Vector2(-r/2, 0), pos + Vector2(r/2, 0), col, 1.0)
			p.draw_line(pos + Vector2(0, -r/2), pos + Vector2(0, r/2), col, 1.0)
		"face":
			p.draw_circle(pos, r/2, col)
		_:
			p.draw_circle(pos, r/2, col)

func set_selected(selected: bool):
	_is_selected = selected
	z_index = 10 if _is_selected else 0
	_update_border()

func set_highlighted(is_highlighted: bool):
	_is_highlighted = is_highlighted
	z_index = 5 if _is_highlighted else (10 if _is_selected else 0)
	_update_border()

func _update_border():
	if not is_node_ready() or not panel_style: return
	
	if _is_highlighted:
		panel_style.border_color = Color(0.2, 0.8, 1.0)
		panel_style.set_border_width_all(4)
	elif _is_selected:
		panel_style.border_color = Color(1.0, 0.7, 0.1)
		panel_style.set_border_width_all(3)
	elif _is_proxy:
		panel_style.border_color = Color(0.3, 0.5, 0.7, 0.8)
		panel_style.set_border_width_all(2)
	else:
		panel_style.border_color = Color(0.8, 0.8, 0.8, 0.2)
		panel_style.set_border_width_all(1)

func _on_mouse_entered():
	if panel_style: panel_style.bg_color = _current_color.lightened(0.15)
	if anchor_container: anchor_container.visible = true
	if not _is_selected and not _is_highlighted: z_index = 5

func _on_mouse_exited():
	if panel_style: panel_style.bg_color = _current_color
	if anchor_container: anchor_container.visible = false
	if not _is_selected and not _is_highlighted: z_index = 0

func _on_panel_gui_input(event):
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_LEFT:
			if event.pressed:
				if event.ctrl_pressed:
					emit_signal("connection_drag_started", _cached_id)
				else:
					dragging = true
					drag_offset = get_global_mouse_position() - global_position
					emit_signal("room_selected", _cached_id)
					emit_signal("drag_started")
			else:
				if dragging:
					dragging = false
					emit_signal("drag_ended")
		elif event.button_index == MOUSE_BUTTON_RIGHT and event.pressed:
			emit_signal("right_clicked")

	if event is InputEventMouseMotion and dragging:
		var raw_pos = get_global_mouse_position() - drag_offset
		if snap_step > 0:
			global_position = raw_pos.snapped(Vector2(snap_step, snap_step))
		else:
			global_position = raw_pos
		emit_signal("dragged", global_position)

func _on_anchor_gui_input(event: InputEvent, anchor_node: Control):
	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
		var anchor_global_pos = anchor_node.get_global_rect().get_center()
		emit_signal("creation_drag_started", _cached_id, anchor_global_pos)

func set_passive(enabled: bool):
	if enabled:
		if visual_panel: visual_panel.mouse_filter = Control.MOUSE_FILTER_IGNORE
		if anchor_container: 
			anchor_container.visible = false
			for c in anchor_container.get_children():
				if c is Control: c.mouse_filter = Control.MOUSE_FILTER_IGNORE
	else:
		if visual_panel: visual_panel.mouse_filter = Control.MOUSE_FILTER_STOP
# scripts/core/WorldManager.gd
class_name WorldManager
extends RefCounted

const REGIONS_DIR = "res://data/regions/"
const WORLD_LAYOUT_FILE = "res://data/world_layout.json"

var world_node_positions: Dictionary = {}

func _init():
	load_world_layout()

func load_world_layout():
	world_node_positions.clear()
	if FileAccess.file_exists(WORLD_LAYOUT_FILE):
		var f = FileAccess.open(WORLD_LAYOUT_FILE, FileAccess.READ)
		var json = JSON.new()
		if json.parse(f.get_as_text()) == OK:
			var d = json.get_data()
			if d.has("positions"): world_node_positions = d.positions

func save_world_layout():
	var d = { "positions": world_node_positions }
	var f = FileAccess.open(WORLD_LAYOUT_FILE, FileAccess.WRITE)
	if f: f.store_string(JSON.stringify(d, "\t"))

func update_world_node_pos(region_id: String, pos: Vector2):
	world_node_positions[region_id] = [pos.x, pos.y]

func get_global_hierarchy() -> Dictionary:
	var hierarchy = {}
	var files = _scan_regions_recursive(REGIONS_DIR, "")
	
	for fname in files:
		var f = FileAccess.open(REGIONS_DIR.path_join(fname), FileAccess.READ)
		if f:
			var json = JSON.new()
			if json.parse(f.get_as_text()) == OK:
				var d = json.get_data()
				# Use explicit region_id if present, otherwise filename without ext
				var rid = d.get("region_id", fname.get_file().replace(".json", ""))
				var room_list = {}
				var rooms = d.get("rooms", {})
				for r_id in rooms:
					room_list[r_id] = rooms[r_id].get("name", "Unnamed")
				hierarchy[rid] = {"filename": fname, "rooms": room_list}
	return hierarchy

func get_all_world_data() -> Dictionary:
	var world_data = {}
	var files = _scan_regions_recursive(REGIONS_DIR, "")
	
	for fname in files:
		var f = FileAccess.open(REGIONS_DIR.path_join(fname), FileAccess.READ)
		if f:
			var json = JSON.new()
			if json.parse(f.get_as_text()) == OK:
				var d = json.get_data()
				var rid = d.get("region_id", fname.get_file().replace(".json", ""))
				world_data[rid] = d
	return world_data

func _scan_regions_recursive(root_dir: String, current_subdir: String) -> Array:
	var files = []
	var full_path = root_dir.path_join(current_subdir)
	var dir = DirAccess.open(full_path)
	if dir:
		dir.list_dir_begin()
		var name = dir.get_next()
		while name != "":
			if dir.current_is_dir():
				if name != "." and name != "..":
					files.append_array(_scan_regions_recursive(root_dir, current_subdir.path_join(name)))
			elif name.ends_with(".json"):
				files.append(current_subdir.path_join(name))
			name = dir.get_next()
	return files

func validate_world_links() -> Array:
	var errors = []
	var full_world = get_all_world_data()
	
	for region_id in full_world:
		var rooms = full_world[region_id].get("rooms", {})
		for room_id in rooms:
			var exits = rooms[room_id].get("exits", {})
			for dir in exits:
				var target = exits[dir]
				if ":" in target:
					var parts = target.split(":")
					var target_rid = parts[0]
					var target_room = parts[1]
					if not full_world.has(target_rid):
						errors.append("[%s] %s -> %s: Unknown Region '%s'" % [region_id, room_id, dir, target_rid])
					elif not full_world[target_rid]["rooms"].has(target_room):
						errors.append("[%s] %s -> %s: Unknown Room '%s' in %s" % [region_id, room_id, dir, target_room, target_rid])
				else:
					if not rooms.has(target):
						errors.append("[%s] %s -> %s: Unknown Room '%s'" % [region_id, room_id, dir, target])
					else:
						# One-way check
						var t_exits = rooms[target].get("exits", {})
						var found_back = false
						for t_dir in t_exits:
							if t_exits[t_dir] == room_id: found_back = true
						if not found_back:
							errors.append("[%s] %s -> %s: One-way link (Target '%s' does not link back)" % [region_id, room_id, dir, target])
	return errors
# scripts/core/CommandProcessor.gd
class_name CommandProcessor
extends RefCounted

var undo_stack: Array = []
var redo_stack: Array = []
var max_history: int = 50

class Command:
	var do_func: Callable
	var undo_func: Callable
	var description: String
	
	func _init(d: Callable, u: Callable, desc: String = ""):
		do_func = d
		undo_func = u
		description = desc

func commit(do_action: Callable, undo_action: Callable, desc: String = "Action"):
	var cmd = Command.new(do_action, undo_action, desc)
	cmd.do_func.call()
	undo_stack.append(cmd)
	redo_stack.clear()
	if undo_stack.size() > max_history:
		undo_stack.pop_front()
	print("CMD: ", desc)

func undo():
	if undo_stack.is_empty(): return
	var cmd = undo_stack.pop_back()
	cmd.undo_func.call()
	redo_stack.append(cmd)
	print("UNDO: ", cmd.description)

func redo():
	if redo_stack.is_empty(): return
	var cmd = redo_stack.pop_back()
	cmd.do_func.call()
	undo_stack.append(cmd)
	print("REDO: ", cmd.description)
# scripts/core/Main.gd
extends Node2D

# Managers
var region_mgr: RegionManager
var world_mgr: WorldManager
var database_mgr: DatabaseManager
var cmd_proc: CommandProcessor

# Controllers
var ui_mgr: EditorUIManager
var inspector: InspectorController
var graph_controller: GraphController
var camera_controller: CameraController
var action_handler: ActionHandler

# State
var state: EditorState
var view_states: Dictionary = {}
var editor_clipboard: Array = []
var cached_hierarchy: Dictionary = {}

# Input state
var mouse_down_pos: Vector2
var deselection_primed: bool = false
var is_dragging_object: bool = false
const DRAG_PIXEL_THRESHOLD = 10

# Scene Refs
@onready var main_camera = $MainCamera
@onready var room_container = $RoomContainer
@onready var connection_layer = $ConnectionLayer
@onready var ui_layer = $UILayer
var grid_layer: GridLayer

func _ready():
	region_mgr = RegionManager.new()
	world_mgr = WorldManager.new()
	database_mgr = DatabaseManager.new()
	cmd_proc = CommandProcessor.new()
	state = EditorState.new()
	
	grid_layer = GridLayer.new(); add_child(grid_layer); move_child(grid_layer, 0)
	grid_layer.setup(main_camera)
	grid_layer.visible = false
	
	ui_mgr = EditorUIManager.new(); ui_mgr.setup(ui_layer)
	inspector = InspectorController.new(); inspector.setup(ui_layer, region_mgr, world_mgr, database_mgr)
	graph_controller = GraphController.new(); graph_controller.setup(room_container, connection_layer, state)
	camera_controller = CameraController.new(); camera_controller.setup(main_camera, ui_mgr)
	action_handler = ActionHandler.new(); action_handler.setup(self, state, cmd_proc, region_mgr, world_mgr, graph_controller, ui_mgr, inspector)
	
	# Inject ActionHandler into Inspector for Multi-Edit
	inspector.set_action_handler(action_handler)
	
	_connect_ui_signals()
	_connect_inspector_signals()
	_connect_graph_signals()
	
	_bootstrap_ui()
	if FileAccess.file_exists("res://data/regions/town.json"): _load_region("town.json")
	else: _load_region("")

func _process(_delta):
	if ui_mgr:
		ui_mgr.update_status_coords(get_global_mouse_position())
		if ui_mgr.search_modal.visible and ui_mgr.search_data_cache.is_empty():
			ui_mgr.cache_search_data(world_mgr.get_all_world_data(), database_mgr.npcs, database_mgr.items)

func _bootstrap_ui():
	if ui_mgr.footer_container:
		var btn_reg = Button.new(); btn_reg.text = "Region Settings"
		ui_mgr.footer_container.add_child(btn_reg); ui_mgr.footer_container.move_child(btn_reg, 0)
		ui_mgr._apply_style(btn_reg, Color(0.2, 0.25, 0.3))
		btn_reg.pressed.connect(func(): inspector.load_region_root(region_mgr.data))
	if not DirAccess.dir_exists_absolute("res://data/regions/"): DirAccess.make_dir_recursive_absolute("res://data/regions/")
	_update_db_ui()

func _update_db_ui():
	ui_mgr.update_db_lists(
		database_mgr.npcs, 
		database_mgr.items, 
		database_mgr.templates,
		database_mgr.magic,
		database_mgr.quests
	)

func _connect_ui_signals():
	ui_mgr.request_load_region.connect(_load_region)
	ui_mgr.request_validate.connect(func(): ui_mgr.show_validation_results(world_mgr.validate_world_links())) 
	ui_mgr.request_create_connection.connect(action_handler.create_connection)
	ui_mgr.request_create_region.connect(_create_region)
	ui_mgr.context_action.connect(action_handler.handle_context_action)
	ui_mgr.snap_toggled.connect(func(b): state.snap_enabled=b; graph_controller.set_snap(b); grid_layer.visible=(b and not state.is_world_view); grid_layer.queue_redraw())
	ui_mgr.creation_direction_selected.connect(action_handler.create_room_from_anchor)
	ui_mgr.tool_changed.connect(func(m, d): state.cur_tool_mode=m; state.cur_tool_data=d; ui_mgr.update_tool_display(m, d); if m!=EditorUIManager.ToolMode.SELECT: _deselect_all())
	ui_mgr.request_jump_to_room.connect(_jump_to_room)
	ui_mgr.request_jump_to_error.connect(func(f, i): 
		if f != region_mgr.current_filename: _load_region(f, false, true)
		await get_tree().create_timer(0.01).timeout; _jump_to_room(i)
	)
	ui_mgr.request_toggle_world_view.connect(func(enabled): _set_world_view(enabled))
	ui_mgr.request_auto_layout.connect(_on_request_layout)
	ui_mgr.request_center_view.connect(func(): camera_controller.center_on_nodes(graph_controller.get_active_nodes()))
	ui_mgr.request_copy.connect(_on_copy_request)
	ui_mgr.request_paste.connect(_on_paste_request)

	ui_mgr.request_select_db_entry.connect(func(t, id): 
		if t=="template": return
		var d
		match t:
			"npc": d = database_mgr.npcs[id]
			"item": d = database_mgr.items[id]
			"magic": d = database_mgr.magic[id]
			"quest": d = database_mgr.quests[id]
		inspector.load_db_object(t, id, d); _deselect_room_only()
	)
	ui_mgr.request_create_db_entry.connect(func(t):
		var id = "new_" + t; var d = {"name": "New " + t.capitalize()}
		match t:
			"npc": database_mgr.add_npc(id, d)
			"item": database_mgr.add_item(id, d)
			"magic": database_mgr.add_magic(id, d)
			"quest": database_mgr.add_quest(id, d)
		_update_db_ui()
	)
	ui_mgr.request_delete_db_entry.connect(func(t, id):
		database_mgr.delete_entry(t, id); _update_db_ui(); inspector.clear_selection()
	)
	ui_mgr.request_delete_room_confirm.connect(action_handler.execute_delete_room)

func _connect_inspector_signals():
	inspector.request_rename.connect(func(o, n): 
		cmd_proc.commit(
			func(): region_mgr.rename_room(o, n); _refresh_view(); _on_node_click(n, false); _update_explorer_dirty_state(),
			func(): region_mgr.rename_room(n, o); _refresh_view(); _on_node_click(o, false); _update_explorer_dirty_state(),
			"Rename Room"
		)
	)
	inspector.request_connection_modal.connect(func(): 
		if state.selected_ids.size() == 1: 
			var id = state.selected_ids[0]
			inspector.load_connection_form(id, region_mgr.data.rooms[id].name, world_mgr.get_global_hierarchy(), region_mgr.current_filename)
	)
	inspector.connection_created.connect(action_handler.create_connection)
	inspector.target_selected_in_connector.connect(_on_connection_target_selected)
	inspector.request_save_template.connect(_on_save_template_request)
	inspector.save_triggered.connect(func(): 
		if state.is_world_view: world_mgr.save_world_layout() 
		else:
			region_mgr.save_region(); region_mgr.mark_clean(); _update_explorer_dirty_state()
			database_mgr.save_all()
	)
	inspector.reload_triggered.connect(func():
		_deselect_all(); 
		if state.is_world_view: world_mgr.load_world_layout(); _refresh_view(); camera_controller.center_on_nodes(graph_controller.get_active_nodes())
		else: _load_region(region_mgr.current_filename, true)
	)
	inspector.data_modified.connect(_on_data_modified)
	inspector.database_modified.connect(func(): _update_db_ui())
	
	# New Quest Graph Signal
	inspector.request_graph_edit_mode.connect(func(qid):
		var q_data = database_mgr.quests.get(qid, {})
		inspector.load_quest_mode(qid)
		graph_controller.load_quest_graph(qid, q_data)
		camera_controller.center_on_nodes(graph_controller.get_active_nodes())
	)

func _connect_graph_signals():
	graph_controller.world_region_selected.connect(_on_world_region_selected)
	graph_controller.node_drag_started.connect(func(_id): is_dragging_object = true)
	graph_controller.world_view_builder.region_dragged.connect(func(): is_dragging_object = true)
	graph_controller.node_selected.connect(func(id): _on_node_click(id, Input.is_key_pressed(KEY_SHIFT)))
	graph_controller.node_drag_started.connect(func(id):
		if not state.is_selected(id): return 
		state.drag_start_positions.clear()
		for sel_id in state.selected_ids: state.drag_start_positions[sel_id] = graph_controller.get_node_position(sel_id)
	)
	graph_controller.node_dragging.connect(func(id, current_pos):
		# Handle multi-node dragging for Quest Graph too (ids are ints, converted to string for generic logic)
		var id_str = str(id)
		if not state.is_selected(id_str) or not state.drag_start_positions.has(id_str): return
		var delta = current_pos - state.drag_start_positions[id_str]
		for sel_id in state.selected_ids:
			if sel_id != id_str and state.drag_start_positions.has(sel_id):
				graph_controller.set_node_position(sel_id, state.drag_start_positions[sel_id] + delta)
	)
	graph_controller.node_dragged.connect(func(id, new_pos):
		is_dragging_object = false
		var id_str = str(id)
		if state.drag_start_positions.has(id_str) and state.is_selected(id_str):
			var delta = new_pos - state.drag_start_positions[id_str]
			if delta.length_squared() > 1.0: action_handler.commit_batch_move(delta)
	)
	graph_controller.node_right_clicked.connect(func(id):
		if state.is_world_view: return
		if ":" in str(id):
			var parts = id.split(":"); var target_region_file = parts[0] + ".json"; var target_room_id = parts[1]
			_load_region(target_region_file, false, true); await get_tree().create_timer(0.05).timeout; _jump_to_room(target_room_id)
		else: ui_mgr.show_context_menu({"Rename":0, "Delete":99, "Set Start":3}); ui_mgr.context_menu.set_meta("target", str(id))
	)
	graph_controller.connection_drag_started.connect(func(id): state.dragging_conn={"active":true, "start":graph_controller.get_node_position(id), "end":Vector2.ZERO, "src":id})
	graph_controller.creation_drag_started.connect(func(id, pos): state.creating_conn={"active":true, "start_pos":pos, "end_pos":pos, "src_id":id})
	graph_controller.region_moved.connect(func(id, old, new):
		cmd_proc.commit(
			func(): world_mgr.update_world_node_pos(id, new); _refresh_view(),
			func(): world_mgr.update_world_node_pos(id, old); _refresh_view(),
			"Move Region"
		)
	)
	graph_controller.request_region_edit.connect(func(id): ui_mgr.btn_world_view.button_pressed = false; _load_region(id + ".json", false, true))

func _unhandled_input(event):
	if event is InputEventKey and event.pressed:
		if event.keycode == KEY_Z and event.ctrl_pressed: cmd_proc.undo(); if not state.is_world_view: _refresh_view(); _on_data_modified()
		elif event.keycode == KEY_Y and event.ctrl_pressed: cmd_proc.redo(); if not state.is_world_view: _refresh_view(); _on_data_modified()
		elif event.keycode == KEY_ESCAPE:
			if state.cur_tool_mode != EditorUIManager.ToolMode.SELECT: ui_mgr.tool_changed.emit(EditorUIManager.ToolMode.SELECT, {})
			elif state.is_box_selecting: state.is_box_selecting = false; graph_controller.update_selection_box(Rect2(), false)
		elif event.keycode == KEY_F: camera_controller.center_on_nodes(graph_controller.get_active_nodes())
		elif event.keycode == KEY_F and event.ctrl_pressed: ui_mgr.show_search_modal()

	if ui_mgr.is_mouse_over_ui(): return

	if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
		var mouse_pos = get_global_mouse_position()
		var is_on_node = _is_mouse_on_any_node(mouse_pos)

		if event.pressed:
			is_dragging_object = false
			if not is_on_node and not state.is_box_selecting and state.cur_tool_mode == EditorUIManager.ToolMode.STAMP and state.cur_tool_data.get("type") == "room_template":
				_stamp_template_at(mouse_pos)
				return 

			if not is_on_node and not state.is_box_selecting:
				deselection_primed = true; mouse_down_pos = mouse_pos
		else:
			if deselection_primed and not is_dragging_object and mouse_pos.distance_to(mouse_down_pos) < DRAG_PIXEL_THRESHOLD: _deselect_all()
			deselection_primed = false; is_dragging_object = false

	if not state.is_box_selecting and camera_controller.handle_input(event):
		if camera_controller.is_panning: is_dragging_object = true
		graph_controller.queue_redraw(); grid_layer.queue_redraw()
		return

	if state.dragging_conn.get("active", false):
		if event is InputEventMouseButton and not event.pressed:
			var target_id = graph_controller.get_room_under_mouse(get_global_mouse_position())
			var src_name = region_mgr.data.rooms.get(state.dragging_conn.src, {}).get("name", "...")
			if target_id != "" and target_id != state.dragging_conn.src: 
				inspector.load_connection_form(state.dragging_conn.src, src_name, world_mgr.get_global_hierarchy(), region_mgr.current_filename, target_id)
			else: inspector.load_connection_form(state.dragging_conn.src, src_name, world_mgr.get_global_hierarchy(), region_mgr.current_filename)
			state.dragging_conn.active = false; graph_controller.queue_redraw()
		elif event is InputEventMouseMotion: graph_controller.queue_redraw()
		return

	if state.creating_conn.get("active", false) and event is InputEventMouseButton and not event.pressed:
		ui_mgr.show_creation_menu(event.position); state.creating_conn.active = false; graph_controller.queue_redraw()
		return

	if state.cur_tool_mode == EditorUIManager.ToolMode.SELECT and event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT and event.pressed and event.shift_pressed:
		state.is_box_selecting = true; state.box_select_start = get_global_mouse_position()
		return

func _is_mouse_on_any_node(mouse_pos: Vector2) -> bool:
	if state.is_world_view:
		for region_node in graph_controller.world_view_builder.world_region_nodes.values():
			if is_instance_valid(region_node):
				var cam_zoom = main_camera.zoom.x if main_camera else 1.0
				var local_rect = region_node._get_current_visuals(cam_zoom).main_rect
				var global_transform = region_node.get_global_transform()
				var global_rect = global_transform * local_rect
				if global_rect.has_point(mouse_pos): return true
	else:
		if graph_controller.get_room_under_mouse(mouse_pos) != "": return true
	return false

# --- TEMPLATE LOGIC ---

func _stamp_template_at(pos: Vector2):
	var template_id = state.cur_tool_data.get("id")
	if not database_mgr.templates.has(template_id): return
	
	var tmpl_data = database_mgr.templates[template_id]
	var new_id = "room_" + str(Time.get_ticks_msec()) + "_" + str(randi() % 1000)
	while region_mgr.data.rooms.has(new_id):
		new_id = "room_" + str(Time.get_ticks_msec()) + "_" + str(randi() % 1000)
	
	var new_room_data = tmpl_data.duplicate(true)
	new_room_data.erase("_filename")
	new_room_data.erase("id")
	new_room_data.exits = {} 
	new_room_data._editor_pos = [pos.x, pos.y]
	
	cmd_proc.commit(
		func():
			region_mgr.add_room_data(new_id, new_room_data)
			_refresh_view(); _on_node_click(new_id, false)
			region_mgr.mark_room_dirty(new_id); _update_explorer_dirty_state(),
		func():
			region_mgr.remove_room_data(new_id)
			_refresh_view(); _update_explorer_dirty_state(),
		"Stamp Room Template"
	)

func _on_save_template_request(room_id):
	if not region_mgr.data.rooms.has(room_id): return
	var room_data = region_mgr.data.rooms[room_id].duplicate(true)
	var template_id = room_data.get("name", "template").to_snake_case() + "_tpl"
	database_mgr.save_template(template_id, room_data)
	_update_db_ui()
	print("Saved template: " + template_id)

# --- COPY/PASTE LOGIC ---

func _on_copy_request():
	editor_clipboard.clear()
	if state.selected_ids.is_empty(): return
	for id in state.selected_ids:
		if region_mgr.data.rooms.has(id):
			editor_clipboard.append(region_mgr.data.rooms[id].duplicate(true))
	print("Copied %d rooms." % editor_clipboard.size())

func _on_paste_request():
	if editor_clipboard.is_empty() or state.is_world_view: return
	var new_ids = []; var paste_offset = Vector2(50, 50)
	for room_data in editor_clipboard:
		var new_id = "room_" + str(Time.get_ticks_msec()) + "_" + str(randi() % 1000)
		while region_mgr.data.rooms.has(new_id):
			new_id = "room_" + str(Time.get_ticks_msec()) + "_" + str(randi() % 1000)
			
		var new_data = room_data.duplicate(true)
		var old_pos = Vector2(new_data._editor_pos[0], new_data._editor_pos[1])
		var new_pos = old_pos + paste_offset
		new_data._editor_pos = [new_pos.x, new_pos.y]
		new_data.exits = {}
		region_mgr.add_room_data(new_id, new_data)
		region_mgr.mark_room_dirty(new_id)
		new_ids.append(new_id)
	
	_refresh_view()
	state.set_selection(new_ids)
	_update_selection_state()
	_update_explorer_dirty_state()
	print("Pasted %d rooms." % editor_clipboard.size())

# --- VIEW LOGIC ---

func _load_region(file, force_reload: bool = false, keep_ui_visible: bool = false):
	if state.is_world_view: ui_mgr.btn_world_view.button_pressed = false; return
	if not force_reload and file == region_mgr.current_filename and file != "": return
	
	if region_mgr.current_filename != "": view_states[region_mgr.current_filename] = {"pos": main_camera.position, "zoom": main_camera.zoom}
	
	if file == "" or region_mgr.load_region(file):
		if not keep_ui_visible: _deselect_all()
		_refresh_view()
		
		if view_states.has(file):
			var vs = view_states[file]; main_camera.position = vs.pos; main_camera.zoom = vs.zoom
		else:
			camera_controller.center_on_nodes(graph_controller.get_active_nodes())

		var rooms = region_mgr.data.get("rooms", {})
		ui_mgr.update_status_info(region_mgr.data.get("name", file), rooms.size())
		ui_mgr.call_deferred("refresh_explorer", world_mgr.get_global_hierarchy(), file, "")

func _create_region(name, rooms_data):
	if not name.ends_with(".json"): name += ".json"
	var new_data = { "region_id": name.replace(".json", ""), "description": "New region", "rooms": rooms_data }
	var file = FileAccess.open("res://data/regions/" + name, FileAccess.WRITE)
	if file: file.store_string(JSON.stringify(new_data, "\t")); file.close()
	_load_region(name)

func _on_node_click(id: String, shift_mod: bool):
	if state.is_world_view: return
	
	match state.cur_tool_mode:
		EditorUIManager.ToolMode.PAINT:
			var k = state.cur_tool_data.get("key", ""); var v = state.cur_tool_data.get("val", "")
			if k and region_mgr.data.rooms.has(id): 
				if not region_mgr.data.rooms[id].has("properties"): region_mgr.data.rooms[id]["properties"] = {}
				var val = v if not v in ["true", "false"] else v == "true"
				region_mgr.data.rooms[id]["properties"][k] = val; _on_data_modified()
			return
		EditorUIManager.ToolMode.STAMP:
			if state.cur_tool_data.get("type") == "room_template": return # Handled in _unhandled_input
			if not region_mgr.data.rooms.has(id): return
			var t = state.cur_tool_data.get("type"); var cid = state.cur_tool_data.get("id")
			var key = "initial_npcs" if t == "npc" else "items"
			var data_key = "template_id" if t == "npc" else "item_id"
			if not region_mgr.data.rooms[id].has(key): region_mgr.data.rooms[id][key] = []
			region_mgr.data.rooms[id][key].append({data_key: cid}); _on_data_modified()
			return
	
	if state.dragging_conn.active and id != state.dragging_conn.src: return
	
	if inspector.cur_mode == "connection":
		var parts = id.split(":"); inspector.set_connection_target(parts[0], parts[1])
		return

	if shift_mod:
		if state.is_selected(id): state.remove_from_selection(id)
		else: state.add_to_selection(id)
	elif not state.is_selected(id):
		state.set_selection([id])
	
	_update_selection_state()

func _on_connection_target_selected(target_id: String):
	state.highlighted_target_id = target_id
	if target_id != "" and inspector.connection_editor:
		state.connection_preview.active = true
		state.connection_preview.source_id = inspector.connection_editor.conn_src_id
		state.connection_preview.target_id = target_id
	else:
		state.connection_preview.active = false
	graph_controller.update_highlight_visuals(); graph_controller.queue_redraw()

func _on_world_region_selected(region_id: String):
	if not state.is_world_view: return
	state.set_selection([region_id])
	graph_controller.update_selection_visuals(state.selected_ids)
	var all_data = world_mgr.get_all_world_data()
	if all_data.has(region_id): inspector.load_region_root(all_data[region_id])
	graph_controller.queue_redraw()

func _update_selection_state():
	graph_controller.update_selection_visuals(state.selected_ids)
	if state.selected_ids.size() == 1:
		var id = state.selected_ids[0]
		
		# Allow focus for Quests too (using index as string)
		if graph_controller.current_mode == GraphController.ViewMode.QUEST:
			# Quest selection logic specific
			pass
		else:
			camera_controller.focus_on(graph_controller.get_node_position(id), false)
			
		if region_mgr.data.rooms.has(id):
			inspector.load_room(id, region_mgr.data.rooms[id]); ui_mgr.select_room_item(id)
		else: inspector.load_external_ref(id)
	elif state.selected_ids.size() > 1:
		inspector.load_multi_selection(state.selected_ids); ui_mgr.select_room_item("")
	else:
		_deselect_all(false)

func _jump_to_room(id):
	_on_node_click(id, false); camera_controller.focus_on(graph_controller.get_node_position(id), true)

func _refresh_view():
	graph_controller.rebuild(region_mgr.data, world_mgr.get_all_world_data(), world_mgr.world_node_positions, region_mgr.current_filename)

func _set_world_view(enabled: bool):
	var cache_key = "world_view" if state.is_world_view else region_mgr.current_filename
	if cache_key != "": view_states[cache_key] = {"pos": main_camera.position, "zoom": main_camera.zoom}
	
	state.is_world_view = enabled
	state.creating_conn = { "active": false }; state.dragging_conn = { "active": false }
	_deselect_all()
	grid_layer.visible = state.snap_enabled and not state.is_world_view
	_refresh_view()
	
	if enabled:
		inspector.load_world_mode()
		if view_states.has("world_view"):
			var vs = view_states["world_view"]; main_camera.position = vs.pos; main_camera.zoom = vs.zoom
		else: main_camera.zoom = Vector2.ONE; camera_controller.center_on_nodes(graph_controller.get_active_nodes())
	elif view_states.has(region_mgr.current_filename):
		var vs = view_states[region_mgr.current_filename]; main_camera.position = vs.pos; main_camera.zoom = vs.zoom

func _on_request_layout():
	if state.is_world_view:
		var all_data = world_mgr.get_all_world_data()
		var old_positions = world_mgr.world_node_positions.duplicate()
		var new_positions = LayoutOptimizer.optimize_world_layout(all_data)
		cmd_proc.commit(
			func():
				for rid in new_positions: world_mgr.update_world_node_pos(rid, new_positions[rid])
				_refresh_view(),
			func():
				world_mgr.world_node_positions = old_positions; _refresh_view(),
			"Auto-Arrange World Map"
		)
	else:
		var old_pos = {}; for id in region_mgr.data.rooms: old_pos[id] = Vector2(region_mgr.data.rooms[id]._editor_pos[0], region_mgr.data.rooms[id]._editor_pos[1])
		var new_pos = LayoutOptimizer.optimize_layout(region_mgr.data.rooms)
		cmd_proc.commit(
			func():
				for id in new_pos: region_mgr.set_room_pos(id, new_pos[id])
				_refresh_view(); camera_controller.center_on_nodes(graph_controller.get_active_nodes()),
			func():
				for id in old_pos: region_mgr.set_room_pos(id, old_pos[id])
				_refresh_view(); camera_controller.center_on_nodes(graph_controller.get_active_nodes()),
			"Auto-Arrange Layout"
		)

func _deselect_all(hide_ui: bool = true): 
	state.clear_selection()
	if state.is_world_view:
		graph_controller.update_selection_visuals([])
		inspector.load_world_mode()
	else:
		graph_controller.update_selection_visuals([])
		inspector.clear_selection(hide_ui)

func _deselect_room_only(): 
	state.clear_selection(); graph_controller.update_selection_visuals([])

func _on_data_modified():
	if not state.is_world_view:
		for id in state.selected_ids:
			region_mgr.mark_room_dirty(id)
			graph_controller.update_specific_node(id, region_mgr.data)
		_update_explorer_dirty_state()
	graph_controller.queue_redraw()

func _update_explorer_dirty_state():
	if cached_hierarchy.is_empty():
		cached_hierarchy = world_mgr.get_global_hierarchy()
	
	if region_mgr.data.has("region_id"):
		var rid = region_mgr.data.region_id
		var live_rooms = {}
		for r_id in region_mgr.data.rooms:
			live_rooms[r_id] = region_mgr.data.rooms[r_id].get("name", "Unnamed")
		
		cached_hierarchy[rid] = {
			"filename": region_mgr.current_filename, 
			"rooms": live_rooms
		}

	var selected = state.selected_ids[0] if not state.selected_ids.is_empty() else ""
	ui_mgr.refresh_explorer(cached_hierarchy, region_mgr.current_filename, selected)
	ui_mgr.update_dirty_visuals(region_mgr.current_filename, region_mgr.is_region_dirty, region_mgr.dirty_room_ids)
# scripts/core/EditorState.gd
class_name EditorState
extends RefCounted

# Manages the active state of the editor.

# View & Tool State
var is_world_view: bool = false
var snap_enabled: bool = false
var cur_tool_mode = EditorUIManager.ToolMode.SELECT
var cur_tool_data: Dictionary = {}

# Selection State
var selected_ids: Array = []
var highlighted_target_id: String = ""
var connection_preview: Dictionary = {"active": false, "source_id": "", "target_id": ""}

# Interaction State (temporary state during an action)
var dragging_conn: Dictionary = {"active": false, "start": Vector2.ZERO, "end": Vector2.ZERO, "src": ""}
var creating_conn: Dictionary = { "active": false, "start_pos": Vector2.ZERO, "end_pos": Vector2.ZERO, "src_id": "" }
var is_box_selecting: bool = false
var box_select_start: Vector2 = Vector2.ZERO
var drag_start_positions: Dictionary = {}

func clear_selection():
	selected_ids.clear()

func set_selection(ids: Array):
	selected_ids = ids

func add_to_selection(id: String):
	if not selected_ids.has(id):
		selected_ids.append(id)

func remove_from_selection(id: String):
	if selected_ids.has(id):
		selected_ids.erase(id)

func is_selected(id: String) -> bool:
	return selected_ids.has(id)
# scripts/core/ActionHandler.gd
class_name ActionHandler
extends RefCounted

var state: EditorState
var main_node: Node2D 
var cmd_proc: CommandProcessor
var region_mgr: RegionManager
var world_mgr: WorldManager
var graph_controller: GraphController
var ui_mgr: EditorUIManager
var inspector: InspectorController

func setup(p_main: Node2D, p_state: EditorState, p_cmd: CommandProcessor, p_rm: RegionManager, p_wm: WorldManager, p_gc: GraphController, p_ui: EditorUIManager, p_insp: InspectorController):
	main_node = p_main
	state = p_state
	cmd_proc = p_cmd
	region_mgr = p_rm
	world_mgr = p_wm
	graph_controller = p_gc
	ui_mgr = p_ui
	inspector = p_insp

func create_connection(src_id: String, dir: String, target_id: String, two_way: bool):
	var final_target = target_id
	if ":" in target_id:
		var parts = target_id.split(":")
		if parts[0] == region_mgr.data.region_id:
			final_target = parts[1]

	cmd_proc.commit(
		func():
			region_mgr.add_exit(src_id, dir, final_target)
			if two_way:
				var inv_dir = Constants.INV_DIR_MAP.get(dir.to_lower(), "")
				if inv_dir and not ":" in final_target:
					region_mgr.add_exit(final_target, inv_dir, src_id)
			main_node._refresh_view()
			region_mgr.mark_room_dirty(src_id)
			if region_mgr.data.rooms.has(final_target):
				region_mgr.mark_room_dirty(final_target)
			main_node._update_explorer_dirty_state(),
		func():
			region_mgr.remove_exit(src_id, dir)
			if two_way and not ":" in final_target:
				region_mgr.remove_exit(final_target, Constants.INV_DIR_MAP.get(dir.to_lower(), ""))
			main_node._refresh_view()
			region_mgr.mark_room_dirty(src_id)
			if region_mgr.data.rooms.has(final_target):
				region_mgr.mark_room_dirty(final_target)
			main_node._update_explorer_dirty_state(),
		"Add Connection"
	)

func create_room_from_anchor(direction: String):
	var src = state.creating_conn.src_id
	var pos = state.creating_conn.end_pos
	var new_id = "room_" + str(Time.get_ticks_msec()) + "_" + str(randi() % 1000)
	var inv = Constants.INV_DIR_MAP.get(direction.to_lower(), "")
	var r_data = { "name": "New Room", "description": "", "exits": {}, "properties": {}, "_editor_pos": [pos.x, pos.y] }
	
	cmd_proc.commit(
		func():
			region_mgr.add_room_data(new_id, r_data)
			region_mgr.add_exit(src, direction, new_id)
			if inv: region_mgr.add_exit(new_id, inv, src)
			main_node._refresh_view()
			main_node._on_node_click(new_id, false)
			region_mgr.mark_room_dirty(new_id)
			region_mgr.mark_room_dirty(src)
			main_node._update_explorer_dirty_state(),
		func():
			region_mgr.remove_exit(src, direction)
			region_mgr.remove_room_data(new_id)
			main_node._refresh_view()
			region_mgr.mark_room_dirty(src)
			main_node._update_explorer_dirty_state(),
		"Create Room Directional"
	)

func handle_context_action(action_id: int):
	if not ui_mgr.context_menu.has_meta("target_id"): return
	
	var target_id = ui_mgr.context_menu.get_meta("target_id")
	var target_type = ui_mgr.context_menu.get_meta("target_type")
	
	if target_type == "room":
		if action_id == 0: # Rename
			main_node._on_node_click(target_id, false)
			
		elif action_id == 3: # Set Start
			cmd_proc.commit(
				func():
					for rid in region_mgr.data.rooms: region_mgr.data.rooms[rid].get("properties", {}).erase("is_start_node")
					if not region_mgr.data.rooms[target_id].has("properties"): region_mgr.data.rooms[target_id].properties = {}
					region_mgr.data.rooms[target_id].properties["is_start_node"] = true
					main_node._on_data_modified(),
				func(): pass, 
				"Set Start Node"
			)
		elif action_id == 99: # Delete request
			ui_mgr.show_delete_room_prompt(target_id)
			
	elif target_type == "region":
		if action_id == 200: # Load Region
			var hierarchy = world_mgr.get_global_hierarchy()
			if hierarchy.has(target_id):
				main_node._load_region(hierarchy[target_id].filename)

	elif target_type == "db_entry":
		var kind = ui_mgr.context_menu.get_meta("db_kind")
		if action_id == 300: # Edit
			ui_mgr.request_select_db_entry.emit(kind, target_id)
		elif action_id == 301: # Delete
			ui_mgr.request_delete_db_entry.emit(kind, target_id)

func execute_delete_room(room_id: String, remove_incoming: bool):
	var old_room_data = region_mgr.data.rooms[room_id].duplicate(true)
	var incoming_links = []
	if remove_incoming:
		incoming_links = region_mgr.find_incoming_connections(room_id)
	
	cmd_proc.commit(
		func(): 
			region_mgr.remove_room_data(room_id)
			for link in incoming_links:
				region_mgr.remove_exit(link.source, link.dir)
				region_mgr.mark_room_dirty(link.source)
			
			main_node._refresh_view()
			main_node._deselect_all()
			main_node._update_explorer_dirty_state(),
		func(): 
			region_mgr.add_room_data(room_id, old_room_data)
			for link in incoming_links:
				region_mgr.add_exit(link.source, link.dir, room_id)
				region_mgr.mark_room_dirty(link.source)
				
			main_node._refresh_view()
			main_node._update_explorer_dirty_state(),
		"Delete Room"
	)

func commit_batch_move(delta: Vector2):
	if state.is_world_view: return
	
	var move_data = {}
	for id in state.selected_ids:
		var old_pos = state.drag_start_positions.get(id, Vector2.ZERO)
		var new_pos = old_pos + delta
		move_data[id] = {"old": old_pos, "new": new_pos}

	cmd_proc.commit(
		func():
			for id in move_data:
				region_mgr.set_room_pos(id, move_data[id].new)
				graph_controller.update_specific_node(id, region_mgr.data)
				region_mgr.mark_room_dirty(id)
			main_node._update_explorer_dirty_state()
			graph_controller.queue_redraw(),
		func():
			for id in move_data:
				region_mgr.set_room_pos(id, move_data[id].old)
				graph_controller.update_specific_node(id, region_mgr.data)
				region_mgr.mark_room_dirty(id)
			main_node._update_explorer_dirty_state()
			graph_controller.queue_redraw(),
		"Move %d Rooms" % move_data.size()
	)

func commit_batch_properties(ids: Array, key: String, new_val, old_vals: Dictionary):
	cmd_proc.commit(
		func():
			for id in ids:
				if not region_mgr.data.rooms.has(id): continue
				if not region_mgr.data.rooms[id].has("properties"): region_mgr.data.rooms[id].properties = {}
				
				if new_val == null: # Deletion
					region_mgr.data.rooms[id].properties.erase(key)
				else:
					region_mgr.data.rooms[id].properties[key] = new_val
				
				region_mgr.mark_room_dirty(id)
				graph_controller.update_specific_node(id, region_mgr.data)
			inspector.data_modified.emit(),
		func():
			for id in ids:
				if not region_mgr.data.rooms.has(id): continue
				var prev = old_vals.get(id)
				if prev == null:
					if region_mgr.data.rooms[id].has("properties"):
						region_mgr.data.rooms[id].properties.erase(key)
				else:
					if not region_mgr.data.rooms[id].has("properties"): region_mgr.data.rooms[id].properties = {}
					region_mgr.data.rooms[id].properties[key] = prev
					
				region_mgr.mark_room_dirty(id)
				graph_controller.update_specific_node(id, region_mgr.data)
			inspector.data_modified.emit(),
		"Batch Edit: %s" % key
	)
# scripts/core/Constants.gd
class_name Constants
extends RefCounted

const DIR_N = "north"
const DIR_S = "south"
const DIR_E = "east"
const DIR_W = "west"
const DIR_NE = "northeast"
const DIR_NW = "northwest"
const DIR_SE = "southeast"
const DIR_SW = "southwest"
const DIR_UP = "up"
const DIR_DOWN = "down"
const DIR_IN = "in"
const DIR_OUT = "out"
const DIR_CLIMB = "climb"
const DIR_DIVE = "dive"

const DIR_VECTORS = { 
	DIR_N: Vector2(0, -1), DIR_S: Vector2(0, 1), 
	DIR_E: Vector2(1, 0), DIR_W: Vector2(-1, 0), 
	DIR_NE: Vector2(1, -1), DIR_NW: Vector2(-1, -1), 
	DIR_SE: Vector2(1, 1), DIR_SW: Vector2(-1, 1), 
	DIR_UP: Vector2(0.5, -0.5), DIR_DOWN: Vector2(-0.5, 0.5), 
	DIR_IN: Vector2(0.2, 0.2), DIR_OUT: Vector2(-0.2, -0.2),
	DIR_CLIMB: Vector2(0.5, -0.5), DIR_DIVE: Vector2(0.5, 0.5) 
}

const INV_DIR_MAP = {
	DIR_N: DIR_S, DIR_S: DIR_N, 
	DIR_E: DIR_W, DIR_W: DIR_E, 
	DIR_UP: DIR_DOWN, DIR_DOWN: DIR_UP, 
	DIR_IN: DIR_OUT, DIR_OUT: DIR_IN,
	DIR_NE: DIR_SW, DIR_SW: DIR_NE,
	DIR_NW: DIR_SE, DIR_SE: DIR_NW,
	DIR_CLIMB: DIR_DIVE, DIR_DIVE: DIR_CLIMB
}

const ANCHORS = {
	DIR_N: Vector2(0, -50), DIR_S: Vector2(0, 50),
	DIR_E: Vector2(100, 0), DIR_W: Vector2(-100, 0),
	DIR_NE: Vector2(100, -50), DIR_NW: Vector2(-100, -50),
	DIR_SE: Vector2(100, 50), DIR_SW: Vector2(-100, 50),
	DIR_UP: Vector2(80, -50), DIR_CLIMB: Vector2(80, -50),
	DIR_DOWN: Vector2(80, 50), DIR_DIVE: Vector2(80, 50),
	DIR_IN: Vector2(30, 30), DIR_OUT: Vector2(-30, -30)
}

# New Icon Definitions for Dynamic Visuals
const ICON_DEFINITIONS = {
	"dark": { "shape": "moon", "color": Color(0.6, 0.6, 0.8) },
	"water": { "shape": "drop", "color": Color(0.2, 0.6, 1.0) },
	"underwater": { "shape": "drop", "color": Color(0.2, 0.4, 0.8) },
	"danger": { "shape": "skull", "color": Color(1.0, 0.3, 0.3) },
	"boss": { "shape": "skull", "color": Color(1.0, 0.1, 0.1) },
	"safe_zone": { "shape": "shield", "color": Color(0.3, 0.8, 0.4) },
	"outdoors": { "shape": "tree", "color": Color(0.2, 0.6, 0.2) },
	"noisy": { "shape": "note", "color": Color(1.0, 0.8, 0.2) },
	"cold": { "shape": "flake", "color": Color(0.7, 0.9, 1.0) },
	"hot": { "shape": "flame", "color": Color(1.0, 0.5, 0.2) }
}
# scripts/generators/RegionGenerator.gd
class_name RegionGenerator
extends RefCounted

# Facade for all procedural generation algorithms.
# Delegates to specialized generator classes.

const CELL_SIZE = Vector2(250, 250)

enum Algo { EMPTY, GRID, MAZE, HUB, CRESCENT, RING, CAVERN, SECTOR, HIGHWAY, SPIRAL, FRACTAL, RIVER, TARGET }

const GRID_BASED = preload("res://scripts/generators/GridBasedGenerators.gd")
const PATH_BASED = preload("res://scripts/generators/PathBasedGenerators.gd")
const GRAPH_BASED = preload("res://scripts/generators/GraphBasedGenerators.gd")

static func generate(algo: int, params: Dictionary) -> Dictionary:
	var rooms = {}
	match algo:
		Algo.EMPTY: rooms = {}
		Algo.GRID: rooms = GRID_BASED.generate_grid(params)
		Algo.MAZE: rooms = GRID_BASED.generate_maze(params)
		Algo.CAVERN: rooms = GRID_BASED.generate_cavern(params)
		Algo.SECTOR: rooms = GRID_BASED.generate_sector(params)
		Algo.TARGET: rooms = GRID_BASED.generate_target(params)
		Algo.HIGHWAY: rooms = PATH_BASED.generate_highway(params)
		Algo.RIVER: rooms = PATH_BASED.generate_river(params)
		Algo.SPIRAL: rooms = PATH_BASED.generate_spiral(params)
		Algo.HUB: rooms = GRAPH_BASED.generate_hub(params)
		Algo.CRESCENT: rooms = GRAPH_BASED.generate_crescent(params)
		Algo.RING: rooms = GRAPH_BASED.generate_ring(params)
		Algo.FRACTAL: rooms = GRAPH_BASED.generate_fractal(params)
	
	return _center_rooms(rooms)

# --- PUBLIC HELPERS (used by specialized generators) ---

static func add_grid_room(rooms: Dictionary, grid_map: Dictionary, pos: Vector2i, prefix: String) -> String:
	if grid_map.has(pos): return grid_map[pos]
	var id = "room_%d_%d" % [pos.x, pos.y]
	rooms[id] = make_room("%s %d-%d" % [prefix, pos.x, pos.y], Vector2(pos) * CELL_SIZE)
	grid_map[pos] = id
	return id

static func connect_grid_neighbors(rooms: Dictionary, grid_map: Dictionary, density: float):
	var neighbors = [
		{ "off": Vector2i(1, 0), "d": false }, { "off": Vector2i(0, 1), "d": false },
		{ "off": Vector2i(1, 1), "d": true }, { "off": Vector2i(-1, 1), "d": true }
	]
	var prob_card = lerp(0.3, 1.0, density); var prob_diag = lerp(0.0, 0.8, density)
	for pos in grid_map:
		for n in neighbors:
			if grid_map.has(pos + n.off) and randf() < (prob_diag if n.d else prob_card):
				link_rooms(rooms, grid_map[pos], grid_map[pos + n.off], Vector2(n.off))

static func link_rooms(rooms: Dictionary, id_a: String, id_b: String, vec_diff: Vector2):
	var d_str = get_dir_from_vec(vec_diff)
	var r_str = get_dir_from_vec(-vec_diff)
	if d_str != "" and r_str != "":
		rooms[id_a].exits[d_str] = id_b
		rooms[id_b].exits[r_str] = id_a

static func keep_largest_island(rooms: Dictionary) -> Dictionary:
	if rooms.is_empty(): return rooms
	var visited = {}; var islands = []
	for rid in rooms:
		if visited.has(rid): continue
		var island = []; var queue = [rid]; visited[rid] = true
		while not queue.is_empty():
			var curr = queue.pop_front(); island.append(curr)
			for dir in rooms[curr].exits:
				var neighbor = rooms[curr].exits[dir]
				if not ":" in neighbor and rooms.has(neighbor) and not visited.has(neighbor):
					visited[neighbor] = true; queue.append(neighbor)
		islands.append(island)
	if islands.is_empty(): return rooms
	islands.sort_custom(func(a, b): return a.size() > b.size())
	var final_rooms = {}; for id in islands[0]: final_rooms[id] = rooms[id]
	for id in final_rooms:
		var exits = final_rooms[id].exits.duplicate()
		for dir in exits:
			if not ":" in exits[dir] and not final_rooms.has(exits[dir]):
				final_rooms[id].exits.erase(dir)
	return final_rooms

static func make_room(name: String, pos: Vector2) -> Dictionary:
	return { "name": name, "description": "Generated.", "exits": {}, "properties": {}, "_editor_pos": [pos.x, pos.y] }

static func get_dir_from_vec(v: Vector2) -> String:
	var deg = rad_to_deg(v.angle()); if deg < 0: deg += 360
	if deg >= 337.5 or deg < 22.5: return Constants.DIR_E
	if deg >= 22.5 and deg < 67.5: return Constants.DIR_SE
	if deg >= 67.5 and deg < 112.5: return Constants.DIR_S
	if deg >= 112.5 and deg < 157.5: return Constants.DIR_SW
	if deg >= 157.5 and deg < 202.5: return Constants.DIR_W
	if deg >= 202.5 and deg < 247.5: return Constants.DIR_NW
	if deg >= 247.5 and deg < 292.5: return Constants.DIR_N
	if deg >= 292.5 and deg < 337.5: return Constants.DIR_NE
	return ""

# --- PRIVATE HELPERS ---

static func _center_rooms(rooms: Dictionary) -> Dictionary:
	if rooms.is_empty(): return rooms
	var min_p = Vector2(INF, INF); var max_p = Vector2(-INF, -INF)
	for id in rooms:
		var p = Vector2(rooms[id]._editor_pos[0], rooms[id]._editor_pos[1])
		min_p.x = min(min_p.x, p.x); min_p.y = min(min_p.y, p.y)
		max_p.x = max(max_p.x, p.x); max_p.y = max(max_p.y, p.y)
	var center_offset = (min_p + max_p) / 2.0
	center_offset = center_offset.snapped(Vector2(CELL_SIZE.x / 2.0, CELL_SIZE.y / 2.0))
	for id in rooms:
		var p = Vector2(rooms[id]._editor_pos[0], rooms[id]._editor_pos[1]) - center_offset
		rooms[id]["_editor_pos"] = [p.x, p.y]
	return rooms
# scripts/generators/LayoutOptimizer.gd
class_name LayoutOptimizer
extends RefCounted

const SNAP_GRID = Vector2(32, 32)

static func optimize_layout(rooms: Dictionary) -> Dictionary:
	var result = {}
	var processed = {}
	var queue = []
	var spacing = Vector2(350, 250) 
	
	# Use constants for direction mapping
	var vectors = Constants.DIR_VECTORS

	var start_id = ""
	for id in rooms:
		if not rooms[id] is Dictionary: continue # Skip malformed data
		if rooms[id].get("properties", {}).get("is_start_node", false): start_id = id; break
	if start_id == "" and not rooms.is_empty(): start_id = rooms.keys()[0]
	if start_id == "": return {}

	var run_bfs = func(root_id, start_pos):
		if processed.has(root_id): return
		
		# Snap start position
		result[root_id] = start_pos.snapped(SNAP_GRID)
		processed[root_id] = true
		queue.append(root_id)
		
		while not queue.is_empty():
			var curr_id = queue.pop_front()
			var curr_pos = result[curr_id]
			var exits = rooms[curr_id].get("exits", {})
			
			for dir in exits:
				var target_id = exits[dir]
				if ":" in target_id or processed.has(target_id): continue
				if not rooms.has(target_id): continue
				
				# Get vector from constants, default to diagonal if unknown
				var vec = vectors.get(dir.to_lower(), Vector2(1, 1))
				
				# Calculate and Snap Target Position
				var raw_target_pos = curr_pos + (vec * spacing)
				result[target_id] = raw_target_pos.snapped(SNAP_GRID)
				
				processed[target_id] = true
				queue.append(target_id)

	run_bfs.call(start_id, Vector2.ZERO)
	
	# Handle disconnected islands
	var island_offset = Vector2(0, 600)
	for id in rooms:
		if not processed.has(id): 
			run_bfs.call(id, island_offset)
			island_offset.y += 600
			
	return result

static func optimize_world_layout(all_data: Dictionary) -> Dictionary:
	var region_sizes = {}
	var region_centers = {} 
	var connections = {}
	var positions = {} 
	var placed_rects = [] 
	
	# --- 1. ANALYZE REGIONS ---
	for rid in all_data:
		var r_data = all_data[rid]
		var rooms = r_data.get("rooms", {})
		connections[rid] = []
		
		var min_p = Vector2(INF, INF)
		var max_p = Vector2(-INF, -INF)
		var has_rooms = false
		
		for room_id in rooms:
			var ep = rooms[room_id].get("_editor_pos", [0, 0])
			var p = Vector2(ep[0], ep[1])
			min_p.x = min(min_p.x, p.x)
			min_p.y = min(min_p.y, p.y)
			max_p.x = max(max_p.x, p.x)
			max_p.y = max(max_p.y, p.y)
			has_rooms = true
			
			var exits = rooms[room_id].get("exits", {})
			for dir in exits:
				var target = exits[dir]
				if ":" in target:
					var parts = target.split(":")
					var target_rid = parts[0]
					if target_rid != rid:
						connections[rid].append({
							"target": target_rid, 
							"dir": dir,
							"vec": _dir_to_vec(dir)
						})
		
		if has_rooms:
			var size = (max_p - min_p) + Vector2(250, 250)
			region_sizes[rid] = size
			region_centers[rid] = (min_p + max_p) / 2.0
		else:
			region_sizes[rid] = Vector2(500, 500)
			region_centers[rid] = Vector2(250, 250)

	# --- 2. PLACEMENT LOOP ---
	var nodes_to_process = all_data.keys()
	var island_start_x = 0.0 
	
	while not nodes_to_process.is_empty():
		var start_node = ""
		if "town" in nodes_to_process: start_node = "town"
		else: start_node = nodes_to_process[0]
			
		nodes_to_process.erase(start_node)
		
		var start_pos = Vector2(island_start_x, 0)
		positions[start_node] = start_pos.snapped(SNAP_GRID)
		
		var s_size = region_sizes[start_node]
		var s_rect_origin = start_pos + region_centers[start_node] - s_size/2.0
		var s_rect = Rect2(s_rect_origin, s_size)
		placed_rects.append(s_rect)
		
		var queue = [start_node]
		var processed_in_island = {start_node: true}
		
		while not queue.is_empty():
			var curr_id = queue.pop_front()
			var curr_pos = positions[curr_id]
			
			for conn in connections.get(curr_id, []):
				var neighbor = conn.target
				if positions.has(neighbor): continue
				if not region_sizes.has(neighbor): continue
				
				processed_in_island[neighbor] = true
				if neighbor in nodes_to_process: nodes_to_process.erase(neighbor)
				queue.append(neighbor)
				
				var dir_vec = conn.vec
				if dir_vec == Vector2.ZERO: dir_vec = Vector2(1, 0)
				
				var my_size = region_sizes[curr_id]
				var their_size = region_sizes[neighbor]
				
				var dist = (abs(dir_vec.x) * (my_size.x + their_size.x) + abs(dir_vec.y) * (my_size.y + their_size.y)) * 0.55
				dist = max(dist, 600.0)
				
				var placed = false
				var angle_attempts = [0, PI/6, -PI/6, PI/4, -PI/4, PI/2, -PI/2]
				
				for ang in angle_attempts:
					var rot_vec = dir_vec.rotated(ang)
					var test_pos = curr_pos + (rot_vec * dist)
					test_pos = test_pos.snapped(SNAP_GRID) # Snap calculated position
					
					var test_rect_origin = test_pos + region_centers[neighbor] - their_size/2.0
					var test_rect = Rect2(test_rect_origin, their_size)
					
					var overlap = false
					for r in placed_rects:
						if r.grow(-50).intersects(test_rect.grow(-50)):
							overlap = true
							break
					
					if not overlap:
						positions[neighbor] = test_pos
						placed_rects.append(test_rect)
						placed = true
						break
				
				if not placed:
					var fallback_pos = curr_pos + (dir_vec * (dist * 1.5))
					positions[neighbor] = fallback_pos.snapped(SNAP_GRID)
					var fallback_rect_origin = positions[neighbor] + region_centers[neighbor] - their_size/2.0
					var fallback_rect = Rect2(fallback_rect_origin, their_size)
					placed_rects.append(fallback_rect)

		var max_x = island_start_x
		for r in placed_rects:
			if r.end.x > max_x:
				max_x = r.end.x
		
		island_start_x = max_x + 800.0

	return positions

static func _dir_to_vec(d: String) -> Vector2:
	return Constants.DIR_VECTORS.get(d.to_lower(), Vector2(1,0))
# scripts/generators/GraphBasedGenerators.gd
class_name GraphBasedGenerators
extends RefCounted

# Contains procedural generation algorithms based on graph or node expansion.

static func generate_hub(p: Dictionary):
	var tendril_len = int(p.get("rows", 10)); var branch_chance = p.get("room_density", 0.5); var c_density = p.get("conn_density", 0.5)
	var rooms = {}; var grid_map = {}
	var center_id = _add_grid_room(rooms, grid_map, Vector2i(0, 0), "The Hub")
	var start_nodes = []
	var neighbor_offsets = [Vector2i(0,-1), Vector2i(0,1), Vector2i(1,0), Vector2i(-1,0), Vector2i(1,1), Vector2i(-1,1), Vector2i(1,-1), Vector2i(-1,-1)]
	for n in neighbor_offsets:
		var id = _add_grid_room(rooms, grid_map, n, "Inner Circle")
		_link_rooms(rooms, center_id, id, Vector2(n)); start_nodes.append(id)

	for start_id in start_nodes:
		var start_pos = Vector2i((Vector2(rooms[start_id]._editor_pos[0], rooms[start_id]._editor_pos[1]) / RegionGenerator.CELL_SIZE).round())
		var curr_pos = start_pos; var curr_id = start_id; var main_dir = start_pos
		for i in range(randi_range(tendril_len / 2, tendril_len)):
			var next_pos = curr_pos + main_dir
			if grid_map.has(next_pos): break
			var next_id = _add_grid_room(rooms, grid_map, next_pos, "Tendril")
			_link_rooms(rooms, curr_id, next_id, Vector2(main_dir))
			curr_pos = next_pos; curr_id = next_id
			if randf() < branch_chance:
				var spur_pos = curr_pos + neighbor_offsets.pick_random()
				if not grid_map.has(spur_pos):
					var spur_id = _add_grid_room(rooms, grid_map, spur_pos, "Spur")
					_link_rooms(rooms, curr_id, spur_id, Vector2(spur_pos - curr_pos))
	_connect_grid_neighbors(rooms, grid_map, c_density)
	return RegionGenerator.keep_largest_island(rooms)

static func generate_crescent(p: Dictionary):
	var size = int(p.get("rows", 15)); var rotation_deg = int(p.get("cols", 0)); var thickness = p.get("room_density", 0.5); var c_density = p.get("conn_density", 0.5)
	var rooms = {}; var grid_map = {}
	var radius_outer = size / 2.0; var radius_inner = radius_outer * (1.0 - thickness)
	var rot_rad = deg_to_rad(rotation_deg); var target_angle = Vector2.RIGHT.rotated(rot_rad).angle()
	for x in range(-size, size + 1):
		for y in range(-size, size + 1):
			var pos = Vector2(x, y); var dist = pos.length()
			if dist <= radius_outer and dist >= radius_inner:
				if abs(angle_difference(pos.angle(), target_angle)) < (PI * 0.6):
					_add_grid_room(rooms, grid_map, Vector2i(x, y), "Crescent")
	_connect_grid_neighbors(rooms, grid_map, c_density)
	return RegionGenerator.keep_largest_island(rooms)
	
static func generate_ring(p: Dictionary):
	var size = int(p.get("rows", 15)); var thickness = p.get("room_density", 0.5); var c_density = p.get("conn_density", 0.5)
	var rooms = {}; var grid_map = {}
	var radius_outer = size / 2.0; var radius_inner = radius_outer * (1.0 - thickness)
	for x in range(-size, size + 1):
		for y in range(-size, size + 1):
			var dist = Vector2(x, y).length()
			if dist <= radius_outer and dist >= radius_inner: _add_grid_room(rooms, grid_map, Vector2i(x, y), "Ring")
	_connect_grid_neighbors(rooms, grid_map, c_density)
	return RegionGenerator.keep_largest_island(rooms)

static func generate_fractal(p: Dictionary):
	var room_count = int(p.get("rows", 30)); var branches = int(p.get("cols", 2)); var cross_connect = p.get("conn_density", 0.1)
	var rooms = {}; var grid_map = {}; var q = []
	var root_id = _add_grid_room(rooms, grid_map, Vector2i.ZERO, "Root"); q.append(root_id)
	var created_count = 1
	while not q.is_empty() and created_count < room_count:
		var parent_id = q.pop_front()
		var parent_pos = Vector2i( (Vector2(rooms[parent_id]._editor_pos[0], rooms[parent_id]._editor_pos[1]) / RegionGenerator.CELL_SIZE).round() )
		for i in range(branches):
			var angle = randf_range(0, TAU)
			var dist = randf_range(2.0, 5.0)
			var child_pos = parent_pos + Vector2i( (Vector2.RIGHT.rotated(angle) * dist).round() )
			if not grid_map.has(child_pos):
				var child_id = _add_grid_room(rooms, grid_map, child_pos, "Branch")
				_link_rooms(rooms, parent_id, child_id, Vector2(child_pos - parent_pos))
				q.append(child_id); created_count += 1
				if created_count >= room_count: break
	if cross_connect > 0:
		_connect_grid_neighbors(rooms, grid_map, cross_connect)
	return RegionGenerator.keep_largest_island(rooms)

# --- HELPER METHODS ---
static func _add_grid_room(rooms, grid_map, pos, prefix): return RegionGenerator.add_grid_room(rooms, grid_map, pos, prefix)
static func _connect_grid_neighbors(rooms, grid_map, density): RegionGenerator.connect_grid_neighbors(rooms, grid_map, density)
static func _link_rooms(rooms, id_a, id_b, vec): RegionGenerator.link_rooms(rooms, id_a, id_b, vec)
# scripts/generators/GridBasedGenerators.gd
class_name GridBasedGenerators
extends RefCounted

# Contains procedural generation algorithms that operate primarily on a grid.
# All methods are static and should be pure functions.

static func generate_grid(p: Dictionary):
	var rows = int(p.get("rows", 10)); var cols = int(p.get("cols", 10)); var r_density = p.get("room_density", 0.5); var c_density = p.get("conn_density", 0.5)
	var rooms = {}; var grid_map = {} 
	for y in range(cols):
		for x in range(rows):
			if randf() < r_density:
				var pos = Vector2i(x, y); _add_grid_room(rooms, grid_map, pos, "Area")
	_connect_grid_neighbors(rooms, grid_map, c_density)
	return RegionGenerator.keep_largest_island(rooms)

static func generate_maze(p: Dictionary):
	var rows = int(p.get("rows", 10)); var cols = int(p.get("cols", 10)); var loop_chance = p.get("conn_density", 0.0)
	var rooms = {}; var visited = {}; var stack = []; var room_map = {}
	
	var get_or_create = func(pos: Vector2i):
		if not room_map.has(pos):
			var id = "maze_%d_%d" % [pos.x, pos.y]; rooms[id] = RegionGenerator.make_room("Maze", Vector2(pos) * RegionGenerator.CELL_SIZE); room_map[pos] = id
		return room_map[pos]
	
	var start_pos = Vector2i(randi_range(0, rows-1), randi_range(0, cols-1))
	stack.append(start_pos); visited[start_pos] = true; get_or_create.call(start_pos)
	
	while not stack.is_empty():
		var curr = stack.back(); var neighbors = []; var dirs = [Vector2i(0, -1), Vector2i(0, 1), Vector2i(1, 0), Vector2i(-1, 0)]
		for d in dirs:
			var n = curr + d
			if n.x >= 0 and n.x < rows and n.y >= 0 and n.y < cols and not visited.has(n): neighbors.append(d)
			
		if neighbors.is_empty(): stack.pop_back()
		else:
			var dir = neighbors[randi() % neighbors.size()]
			var next = curr + dir; visited[next] = true; stack.append(next)
			_link_rooms(rooms, get_or_create.call(curr), get_or_create.call(next), Vector2(dir))
	
	if loop_chance > 0.0: # Braiding
		for pos in room_map:
			var id = room_map[pos]; var dirs = [Vector2i(1, 0), Vector2i(0, 1)]
			for d in dirs:
				var n = pos + d
				if room_map.has(n) and not rooms[id].exits.has(RegionGenerator.get_dir_from_vec(Vector2(d))):
					if randf() < loop_chance: _link_rooms(rooms, id, room_map[n], Vector2(d))
	return rooms

static func generate_cavern(p: Dictionary):
	var w = int(p.get("rows", 20)); var h = int(p.get("cols", 20)); var fill_prob = p.get("room_density", 0.45) 
	var grid = []; for x in range(w): grid.append([]); for y in range(h): grid[x].append(randf() < fill_prob)
	for s in range(4): 
		var new_grid = grid.duplicate(true)
		for x in range(1, w-1):
			for y in range(1, h-1):
				var neighbors = 0
				for i in range(-1, 2):
					for j in range(-1, 2):
						if i == 0 and j == 0: continue
						if grid[x+i][y+j]: neighbors += 1
				if grid[x][y]: new_grid[x][y] = (neighbors >= 4)
				else: new_grid[x][y] = (neighbors >= 5)
		grid = new_grid
	var rooms = {}; var grid_map = {}
	for x in range(w):
		for y in range(h):
			if grid[x][y]: _add_grid_room(rooms, grid_map, Vector2i(x,y), "Cavern")
	_connect_grid_neighbors(rooms, grid_map, p.get("conn_density", 0.8))
	return RegionGenerator.keep_largest_island(rooms)

static func generate_sector(p: Dictionary):
	var w = int(p.get("rows", 20)); var h = int(p.get("cols", 20)); var min_size = lerp(8, 3, p.get("room_density", 0.5))
	var rooms = {}; var grid_map = {}; var rects = [Rect2i(0, 0, w, h)]; var final_sectors = []
	while not rects.is_empty():
		var r = rects.pop_front()
		if r.size.x <= min_size or r.size.y <= min_size or randf() < 0.1: final_sectors.append(r); continue
		var split_horz = r.size.x > r.size.y; if r.size.x == r.size.y: split_horz = (randf() > 0.5)
		if split_horz:
			var split = randi_range(int(r.size.x * 0.4), int(r.size.x * 0.6))
			rects.append(Rect2i(r.position.x, r.position.y, split, r.size.y))
			rects.append(Rect2i(r.position.x + split, r.position.y, r.size.x - split, r.size.y))
		else:
			var split = randi_range(int(r.size.y * 0.4), int(r.size.y * 0.6))
			rects.append(Rect2i(r.position.x, r.position.y, r.size.x, split))
			rects.append(Rect2i(r.position.x, r.position.y + split, r.size.x, r.size.y - split))
	for i in range(final_sectors.size()):
		var r = final_sectors[i].grow(-1)
		for x in range(r.position.x, r.end.x):
			for y in range(r.position.y, r.end.y):
				var pos = Vector2i(x, y)
				_add_grid_room(rooms, grid_map, pos, "Sector %d" % i)
				if grid_map.has(pos + Vector2i.LEFT): _link_rooms(rooms, grid_map[pos], grid_map[pos + Vector2i.LEFT], Vector2.LEFT)
				if grid_map.has(pos + Vector2i.UP): _link_rooms(rooms, grid_map[pos], grid_map[pos + Vector2i.UP], Vector2.UP)
	for i in range(len(final_sectors) - 1):
		var p1 = final_sectors[i].get_center(); var p2 = final_sectors[i+1].get_center()
		var cursor = Vector2i(p1); while cursor != Vector2i(p2):
			if cursor.x != p2.x: cursor.x += sign(p2.x - cursor.x)
			else: cursor.y += sign(p2.y - cursor.y)
			if not grid_map.has(cursor): _add_grid_room(rooms, grid_map, cursor, "Hallway")
			_connect_grid_neighbors(rooms, {cursor: grid_map[cursor]}, 1.0)
	return RegionGenerator.keep_largest_island(rooms)
	
static func generate_target(p: Dictionary):
	var rings = int(p.get("rows", 3)); var gate_density = p.get("conn_density", 0.5)
	var rooms = {}; var grid_map = {}; var prev_ring_nodes = [] # Array of IDs
	
	# Add center
	prev_ring_nodes.append(_add_grid_room(rooms, grid_map, Vector2i(0,0), "Bullseye"))
	
	for r in range(1, rings + 1):
		var current_ring_nodes = [] # Array of IDs
		var radius = r * 3
		for a_deg in range(0, 360, 20):
			var pos_f = Vector2.RIGHT.rotated(deg_to_rad(a_deg)) * radius
			var pos_i = Vector2i(pos_f.round())
			if not grid_map.has(pos_i):
				current_ring_nodes.append(_add_grid_room(rooms, grid_map, pos_i, "Ring %d" % r))
		
		# Link within ring
		for i in range(len(current_ring_nodes)):
			var id_a = current_ring_nodes[i]
			var id_b = current_ring_nodes[(i+1)%len(current_ring_nodes)]
			var p1 = Vector2(rooms[id_a]._editor_pos[0], rooms[id_a]._editor_pos[1])
			var p2 = Vector2(rooms[id_b]._editor_pos[0], rooms[id_b]._editor_pos[1])
			_link_rooms(rooms, id_a, id_b, (p2 - p1).normalized())

		# Create bridges to previous ring
		for i in range(1 + int(gate_density * 4)):
			var outer_id = current_ring_nodes.pick_random()
			var inner_id = prev_ring_nodes.pick_random()
			var outer_node = rooms[outer_id]
			var inner_node = rooms[inner_id]
			
			var p1 = Vector2(outer_node._editor_pos[0], outer_node._editor_pos[1])
			var p2 = Vector2(inner_node._editor_pos[0], inner_node._editor_pos[1])
			var diff = (p2 - p1).normalized() * RegionGenerator.CELL_SIZE
			
			var cursor = p1 + diff
			var last_id = outer_id # Start from valid ID
			
			while cursor.distance_to(p2) > RegionGenerator.CELL_SIZE.x:
				var pos_i = Vector2i( (cursor / RegionGenerator.CELL_SIZE).round() )
				# Only add if empty, else use existing
				var bridge_id = ""
				if not grid_map.has(pos_i):
					bridge_id = _add_grid_room(rooms, grid_map, pos_i, "Bridge")
				else:
					bridge_id = grid_map[pos_i]
					
				var bridge_node = rooms[bridge_id]
				var bridge_pos = Vector2(bridge_node._editor_pos[0], bridge_node._editor_pos[1])
				var last_node = rooms[last_id]
				var last_pos = Vector2(last_node._editor_pos[0], last_node._editor_pos[1])
				
				_link_rooms(rooms, last_id, bridge_id, (bridge_pos - last_pos).normalized())
				last_id = bridge_id
				cursor += diff
			
			# Final link to inner ring
			_link_rooms(rooms, last_id, inner_id, diff.normalized())
			
		prev_ring_nodes = current_ring_nodes
	return rooms

# --- HELPER METHODS (duplicated for encapsulation) ---
static func _add_grid_room(rooms, grid_map, pos, prefix): return RegionGenerator.add_grid_room(rooms, grid_map, pos, prefix)
static func _connect_grid_neighbors(rooms, grid_map, density): RegionGenerator.connect_grid_neighbors(rooms, grid_map, density)
static func _link_rooms(rooms, id_a, id_b, vec): RegionGenerator.link_rooms(rooms, id_a, id_b, vec)
# scripts/generators/PathBasedGenerators.gd
class_name PathBasedGenerators
extends RefCounted

# Contains procedural generation algorithms that create paths or linear structures.

static func generate_highway(p: Dictionary):
	var length = int(p.get("rows", 20)); var rotation = int(p.get("cols", 0)); var town_freq = p.get("room_density", 0.3); var winding = p.get("conn_density", 0.5)
	var rooms = {}; var grid_map = {}
	var dir_vec = Vector2.RIGHT.rotated(deg_to_rad(rotation)); var cursor_float = Vector2.ZERO
	var all_neighbors = [Vector2i(-1,0), Vector2i(1,0), Vector2i(0,-1), Vector2i(0,1), Vector2i(-1,-1), Vector2i(1,1), Vector2i(-1,1), Vector2i(1,-1)]
	
	for i in range(length):
		var pos_i = Vector2i(cursor_float.round())
		_add_grid_room(rooms, grid_map, pos_i, "Highway")
		for n in all_neighbors:
			if grid_map.has(pos_i + n):
				_link_rooms(rooms, grid_map[pos_i], grid_map[pos_i + n], Vector2(n))

		if randf() < town_freq:
			for t in range(randi_range(3, 7)):
				var t_pos = pos_i + Vector2i(randi_range(-2, 2), randi_range(-2, 2))
				if not grid_map.has(t_pos):
					_add_grid_room(rooms, grid_map, t_pos, "Settlement")
					_connect_grid_neighbors(rooms, {t_pos: grid_map[t_pos]}, 1.0)
					
		cursor_float += dir_vec
		if randf() < winding:
			cursor_float += dir_vec.rotated(PI/2) * (randf() * 2.0 - 1.0)
			
	return RegionGenerator.keep_largest_island(rooms)

static func generate_river(p: Dictionary):
	var length = int(p.get("rows", 20)); var width = int(p.get("cols", 6)); var weaving = p.get("conn_density", 0.5)
	var rooms = {}; var grid_map = {}; var heads = []
	for y in range(width):
		var pos = Vector2i(0, y); heads.append(_add_grid_room(rooms, grid_map, pos, "Source"))
	for x in range(1, length):
		var new_heads = []
		for h_id in heads:
			var h_pos = Vector2i( (Vector2(rooms[h_id]._editor_pos[0], rooms[h_id]._editor_pos[1]) / RegionGenerator.CELL_SIZE).round() )
			var moves = [Vector2i(1,0)]
			if randf() < weaving: moves.append(Vector2i(1, -1)); moves.append(Vector2i(1, 1))
			for m in moves:
				var next = h_pos + m
				if next.y >= 0 and next.y < (width * 1.5):
					var id = _add_grid_room(rooms, grid_map, next, "Stream")
					_link_rooms(rooms, h_id, id, Vector2(m))
					if not new_heads.has(id): new_heads.append(id)
		heads = new_heads
	return RegionGenerator.keep_largest_island(rooms)

static func generate_spiral(p: Dictionary):
	var max_len = int(p.get("rows", 50)); var direction = 1.0 if p.get("room_density", 0.0) < 0.5 else -1.0
	var shortcuts = p.get("conn_density", 0.0); var b = 0.5 / PI; var rooms = {}; var grid_map = {}
	var cursor = Vector2i(0,0); var parent_id = _add_grid_room(rooms, grid_map, cursor, "Spiral Center")
	
	var theta = 0.0; var count = 1
	while count < max_len:
		theta += 0.5 / max(1.0, b * theta)
		var target_f = Vector2(cos(theta * direction), sin(theta * direction)) * (b * theta * 5.0) 
		var target_i = Vector2i(target_f.round())
		if not grid_map.has(target_i):
			var id = _add_grid_room(rooms, grid_map, target_i, "Spiral")
			_link_rooms(rooms, parent_id, id, Vector2(target_i - cursor))
			if shortcuts > 0 and randf() < shortcuts:
				_connect_grid_neighbors(rooms, {target_i: id}, 0.5)
			parent_id = id; cursor = target_i; count += 1
			
	return RegionGenerator.keep_largest_island(rooms)

# --- HELPER METHODS ---
static func _add_grid_room(rooms, grid_map, pos, prefix): return RegionGenerator.add_grid_room(rooms, grid_map, pos, prefix)
static func _connect_grid_neighbors(rooms, grid_map, density): RegionGenerator.connect_grid_neighbors(rooms, grid_map, density)
static func _link_rooms(rooms, id_a, id_b, vec): RegionGenerator.link_rooms(rooms, id_a, id_b, vec)
class_name CameraController
extends RefCounted

var camera: Camera2D
var ui_mgr: EditorUIManager
var is_panning: bool = false

func setup(_camera: Camera2D, _ui_mgr: EditorUIManager):
	camera = _camera
	ui_mgr = _ui_mgr

func handle_input(event: InputEvent) -> bool:
	if event is InputEventMouseButton:
		if event.button_index == MOUSE_BUTTON_WHEEL_UP: 
			zoom(1.1)
			return true
		elif event.button_index == MOUSE_BUTTON_WHEEL_DOWN: 
			zoom(1.0 / 1.1)
			return true
		elif event.button_index == MOUSE_BUTTON_LEFT:
			is_panning = event.pressed
	
	if event is InputEventMouseMotion and is_panning:
		camera.position -= event.relative / camera.zoom
		return true
		
	return false

func zoom(factor: float):
	camera.zoom = (camera.zoom * factor).clamp(Vector2(0.1,0.1), Vector2(5,5))
	ui_mgr.update_status_zoom(camera.zoom)

func focus_on(target_pos: Vector2, force: bool = false):
	var vp_rect = camera.get_viewport_rect()
	var visible_size = vp_rect.size / camera.zoom
	if force:
		_tween_to(target_pos)
	else:
		var margin = visible_size * 0.25 
		var diff = target_pos - camera.position
		if abs(diff.x) > margin.x or abs(diff.y) > margin.y:
			_tween_to(target_pos)

func center_on_nodes(nodes: Dictionary):
	if nodes.is_empty(): return
	var avg = Vector2.ZERO
	for id in nodes: avg += nodes[id].position
	if nodes.size() > 0: avg /= nodes.size()
	camera.position = avg

func _tween_to(pos: Vector2):
	var tween = camera.create_tween()
	tween.tween_property(camera, "position", pos, 0.4).set_trans(Tween.TRANS_QUART).set_ease(Tween.EASE_OUT)
# scripts/controllers/GraphController.gd
class_name GraphController
extends RefCounted

# Signals
signal node_selected(id)
signal node_drag_started(id)
signal node_dragging(id, current_pos)
signal node_dragged(id, final_pos)
signal node_right_clicked(id)
signal connection_drag_started(id)
signal creation_drag_started(id, pos)
signal request_region_edit(region_id)
signal region_moved(region_id, old_pos, new_pos)
signal world_region_selected(region_id)

enum ViewMode { LOCAL, WORLD, QUEST }
var current_mode = ViewMode.LOCAL

# Child nodes
var container: Node2D
var connection_layer: Node2D

# View Builders
var local_view_builder: LocalViewBuilder
var world_view_builder: WorldViewBuilder
var quest_view_builder: QuestViewBuilder

# State
var editor_state: EditorState
var region_data: Dictionary
var world_data: Dictionary
var world_positions: Dictionary
var current_region_filename: String
var current_quest_data: Dictionary = {}

var selection_box: Rect2 = Rect2()
var is_box_selecting: bool = false

const LOCAL_VIEW_BUILDER = preload("res://scripts/controllers/view_builders/LocalViewBuilder.gd")
const WORLD_VIEW_BUILDER = preload("res://scripts/controllers/view_builders/WorldViewBuilder.gd")
const QUEST_VIEW_BUILDER = preload("res://scripts/controllers/view_builders/QuestViewBuilder.gd")

func setup(_container: Node2D, _conn_layer: Node2D, p_state: EditorState):
	container = _container
	connection_layer = _conn_layer
	editor_state = p_state
	
	connection_layer.z_index = 10
	connection_layer.draw.connect(_on_draw_connections)
	
	local_view_builder = LOCAL_VIEW_BUILDER.new(container)
	world_view_builder = WORLD_VIEW_BUILDER.new(container)
	quest_view_builder = QUEST_VIEW_BUILDER.new(container)
	
	_forward_builder_signals()

func _forward_builder_signals():
	local_view_builder.node_selected.connect(func(id): node_selected.emit(id))
	local_view_builder.node_drag_started.connect(func(id): node_drag_started.emit(id))
	local_view_builder.node_dragging.connect(func(id, pos): node_dragging.emit(id, pos); queue_redraw())
	local_view_builder.node_dragged.connect(func(id, pos): node_dragged.emit(id, pos))
	local_view_builder.node_right_clicked.connect(func(id): node_right_clicked.emit(id))
	local_view_builder.connection_drag_started.connect(func(id): connection_drag_started.emit(id))
	local_view_builder.creation_drag_started.connect(func(id, pos): creation_drag_started.emit(id, pos))
	
	world_view_builder.region_node_selected.connect(func(id): world_region_selected.emit(id))
	world_view_builder.region_moved.connect(func(id, old, new): region_moved.emit(id, old, new))
	world_view_builder.request_region_edit.connect(func(id): request_region_edit.emit(id))
	world_view_builder.region_dragged.connect(func(): queue_redraw())
	
	quest_view_builder.node_selected.connect(func(idx): node_selected.emit(idx))
	quest_view_builder.node_moved.connect(func(idx, pos): 
		if current_quest_data.has("stages") and idx < current_quest_data.stages.size():
			current_quest_data.stages[idx]["_editor_pos"] = [pos.x, pos.y]
		queue_redraw()
	)

func rebuild(p_region_data: Dictionary, p_world_data: Dictionary, p_world_pos: Dictionary, p_current_file: String):
	region_data = p_region_data
	world_data = p_world_data
	world_positions = p_world_pos
	current_region_filename = p_current_file
	
	current_mode = ViewMode.WORLD if editor_state.is_world_view else ViewMode.LOCAL
	
	if current_mode == ViewMode.WORLD:
		world_view_builder.build(world_data, world_positions, region_data, current_region_filename)
	else:
		local_view_builder.build(region_data, editor_state.snap_enabled)
	
	update_selection_visuals(editor_state.selected_ids)
	queue_redraw()

func load_quest_graph(quest_id: String, q_data: Dictionary):
	current_mode = ViewMode.QUEST
	current_quest_data = q_data
	quest_view_builder.build(q_data)
	queue_redraw()

func queue_redraw():
	if editor_state == null: return
	connection_layer.queue_redraw()
	if current_mode == ViewMode.WORLD:
		for node in world_view_builder.world_region_nodes.values():
			if is_instance_valid(node): node.queue_redraw()

func update_highlight_visuals():
	if current_mode == ViewMode.LOCAL:
		for id in local_view_builder.room_nodes:
			var node = local_view_builder.room_nodes[id]
			if is_instance_valid(node):
				node.set_highlighted(id == editor_state.highlighted_target_id)

func update_specific_node(id: String, p_region_data: Dictionary):
	if current_mode == ViewMode.LOCAL and local_view_builder.room_nodes.has(id):
		var node = local_view_builder.room_nodes[id]
		if p_region_data.get("rooms", {}).has(id):
			var data = p_region_data.rooms[id]
			node.position = Vector2(data._editor_pos[0], data._editor_pos[1])
			node.set_info(data.get("name", "Unnamed"), id)
			local_view_builder.update_node_visuals(node, data)
		elif p_region_data.get("_proxy_positions", {}).has(id):
			var pos_data = p_region_data._proxy_positions[id]
			node.position = Vector2(pos_data[0], pos_data[1])
		queue_redraw()

func set_node_position(id: String, pos: Vector2):
	if current_mode == ViewMode.LOCAL and local_view_builder.room_nodes.has(id):
		local_view_builder.room_nodes[id].position = pos

func update_selection_visuals(selected_ids: Array):
	if current_mode == ViewMode.WORLD:
		for rid in world_view_builder.world_region_nodes:
			var node = world_view_builder.world_region_nodes[rid]
			if is_instance_valid(node): node.set_selected(rid in selected_ids)
	elif current_mode == ViewMode.LOCAL:
		for rid in local_view_builder.room_nodes:
			var node = local_view_builder.room_nodes[rid]
			if is_instance_valid(node): node.set_selected(rid in selected_ids)
	elif current_mode == ViewMode.QUEST:
		for idx in quest_view_builder.quest_nodes:
			var node = quest_view_builder.quest_nodes[idx]
			# Quest selection logic would need indices, effectively unsupported for multi-select right now
			pass

func set_snap(enabled: bool):
	if current_mode == ViewMode.LOCAL:
		for node in local_view_builder.room_nodes.values():
			node.snap_step = 32 if enabled else 0

func get_node_position(id: String) -> Vector2:
	if current_mode == ViewMode.LOCAL and local_view_builder.room_nodes.has(id):
		return local_view_builder.room_nodes[id].position
	return Vector2.ZERO

func get_room_under_mouse(global_pos: Vector2) -> String:
	if current_mode != ViewMode.LOCAL: return ""
	for id in local_view_builder.room_nodes:
		var node = local_view_builder.room_nodes[id]
		var rect = node.get_node("VisualPanel").get_global_rect()
		if rect.has_point(global_pos): return id
	return ""

func get_nodes_in_rect(global_rect: Rect2) -> Array:
	var result = []
	if current_mode == ViewMode.LOCAL:
		for id in local_view_builder.room_nodes:
			if global_rect.has_point(local_view_builder.room_nodes[id].global_position):
				result.append(id)
	return result

func update_selection_box(rect: Rect2, active: bool):
	selection_box = rect; is_box_selecting = active; queue_redraw()

func get_active_nodes() -> Dictionary:
	if current_mode == ViewMode.WORLD: return world_view_builder.world_region_nodes
	if current_mode == ViewMode.QUEST: return quest_view_builder.quest_nodes
	return local_view_builder.room_nodes

# --- DRAWING ---

func _on_draw_connections():
	if editor_state == null: return

	if current_mode == ViewMode.QUEST:
		quest_view_builder.draw_connections(connection_layer, current_quest_data)
		return

	if current_mode == ViewMode.WORLD:
		_draw_world_connections()
	else:
		_draw_local_connections()

func _draw_local_connections():
	# ... (Existing local draw logic unchanged, copy from previous if needed, but keeping succinct)
	if editor_state.connection_preview.get("active", false):
		var src_id = editor_state.connection_preview.source_id
		var tgt_id = editor_state.connection_preview.target_id
		if local_view_builder.room_nodes.has(src_id) and local_view_builder.room_nodes.has(tgt_id):
			var p1 = local_view_builder.room_nodes[src_id].position
			var p2 = local_view_builder.room_nodes[tgt_id].position
			connection_layer.draw_dashed_line(p1, p2, Color.MAGENTA, 3.0, 10.0)
	
	if editor_state.creating_conn.get("active", false):
		connection_layer.draw_line(editor_state.creating_conn.start_pos, editor_state.creating_conn.end_pos, Color.LIME_GREEN, 3.0)
	
	if editor_state.dragging_conn.get("active", false):
		editor_state.dragging_conn.end = connection_layer.get_global_mouse_position()
	
	GraphRenderer.draw_graph(connection_layer, local_view_builder.room_nodes, region_data, editor_state.selected_ids[0] if editor_state.selected_ids.size() == 1 else "", editor_state.dragging_conn)
	
	if is_box_selecting:
		var col = Color(0.2, 0.6, 1.0, 0.3); var border = Color(0.4, 0.8, 1.0, 0.8)
		var local_rect = Rect2(connection_layer.to_local(selection_box.position), selection_box.size)
		connection_layer.draw_rect(local_rect, col, true); connection_layer.draw_rect(local_rect, border, false, 1.0)

func _draw_world_connections():
	# ... (Existing world draw logic unchanged)
	var drawn_pairs = {}
	var cam = connection_layer.get_viewport().get_camera_2d()
	var zoom = cam.zoom.x if cam else 1.0
	var scale_factor = clamp(1.0 / sqrt(zoom), 1.0, 3.0)
	var base_line_width = 0.5
	var selected_region_id = editor_state.selected_ids[0] if not editor_state.selected_ids.is_empty() else ""
	
	for src_rid in world_data:
		for src_room_id in world_data[src_rid].get("rooms", {}):
			for dir in world_data[src_rid].rooms[src_room_id].get("exits", {}):
				var target_raw = world_data[src_rid].rooms[src_room_id].exits[dir]
				if ":" in target_raw:
					var parts = target_raw.split(":"); var tgt_rid = parts[0]; var tgt_room_id = parts[1]
					if tgt_rid != src_rid and world_view_builder.world_region_nodes.has(src_rid) and world_view_builder.world_region_nodes.has(tgt_rid):
						var is_highlighted = (src_rid == selected_region_id or tgt_rid == selected_region_id)
						var is_bi = world_data.get(tgt_rid, {}).get("rooms", {}).get(tgt_room_id, {}).get("exits", {}).values().has(src_rid + ":" + src_room_id)
						if is_bi:
							var k = [src_rid, tgt_rid]; k.sort()
							var key = k[0] + k[1]
							if drawn_pairs.has(key): continue
							drawn_pairs[key] = true
						
						var n_src = world_view_builder.world_region_nodes[src_rid]
						var n_tgt = world_view_builder.world_region_nodes[tgt_rid]
						var p1 = n_src.global_position + (n_src.get_room_local_center(src_room_id) * n_src.scale)
						var p2 = n_tgt.global_position + (n_tgt.get_room_local_center(tgt_room_id) * n_tgt.scale)
						var line_width = (base_line_width * 2 if is_bi else base_line_width) * scale_factor
						var line_color = Color.GOLD if is_highlighted else (Color.WHITE if is_bi else Color(0.8, 0.8, 0.8, 0.5))
						
						if is_bi or is_highlighted: connection_layer.draw_line(p1, p2, line_color, line_width * (2.0 if is_highlighted else 1.0))
						else: connection_layer.draw_dashed_line(p1, p2, line_color, line_width, 4.0 * scale_factor)
# scripts/controllers/view_builders/LocalViewBuilder.gd
class_name LocalViewBuilder
extends RefCounted

# Handles the creation and management of nodes for the local region view.

const ROOM_SCENE = preload("res://scenes/RoomScene.tscn")

var container: Node2D
var room_nodes: Dictionary = {}

# Signals forwarded from nodes
signal node_selected(id)
signal node_drag_started(id)
signal node_dragging(id, current_pos)
signal node_dragged(id, final_pos)
signal node_right_clicked(id)
signal connection_drag_started(id)
signal creation_drag_started(id, pos)

func _init(p_container: Node2D):
	container = p_container

func build(region_data: Dictionary, snap_enabled: bool):
	clear()
	var rooms = region_data.get("rooms", {})
	if rooms.is_empty(): return
	
	for rid in rooms:
		var r_data = rooms[rid]
		var ep = r_data.get("_editor_pos", [0, 0])
		var pos = Vector2(ep[0], ep[1])
		_spawn_room_node(rid, pos, r_data, snap_enabled)
	
	var external_links = {} 
	var stored_proxies = region_data.get("_proxy_positions", {})
	
	for rid in rooms:
		var r_exits = rooms[rid].get("exits", {})
		for dir in r_exits:
			var target = r_exits[dir]
			if ":" in target and not external_links.has(target):
				if stored_proxies.has(target):
					var p = stored_proxies[target]
					external_links[target] = Vector2(p[0], p[1])
				else:
					var src_pos = room_nodes[rid].position
					var vec = Constants.DIR_VECTORS.get(dir.to_lower(), Vector2(1,0))
					external_links[target] = src_pos + (vec * 250.0)

	for ext_id in external_links:
		_create_proxy_node(ext_id, external_links[ext_id], snap_enabled)

func clear():
	for c in container.get_children(): c.queue_free()
	room_nodes.clear()

func _spawn_room_node(id, pos, data, snap_enabled):
	var node = ROOM_SCENE.instantiate()
	node.position = pos
	node.snap_step = 32 if snap_enabled else 0
	
	node.set_info(data.get("name", "Unnamed"), id)
	
	update_node_visuals(node, data)
	_connect_node_signals(node, id)
	
	container.add_child(node)
	room_nodes[id] = node

func _create_proxy_node(full_id, pos, snap_enabled):
	var parts = full_id.split(":")
	var node = ROOM_SCENE.instantiate()
	node.position = pos
	node.snap_step = 32 if snap_enabled else 0
	
	node.set_info(parts[0].capitalize(), full_id)
	node.set_as_proxy(true)
	
	_connect_node_signals(node, full_id)
	container.add_child(node)
	room_nodes[full_id] = node

func _connect_node_signals(node: Node, id: String):
	node.room_selected.connect(func(_i): node_selected.emit(id))
	node.drag_started.connect(func(): node_drag_started.emit(id))
	node.right_clicked.connect(func(): node_right_clicked.emit(id))
	node.connection_drag_started.connect(func(_i): connection_drag_started.emit(id))
	node.creation_drag_started.connect(func(_i, pos): creation_drag_started.emit(id, pos))
	node.dragged.connect(func(pos): node_dragging.emit(id, pos))
	node.drag_ended.connect(func(): node_dragged.emit(id, node.position))

func update_node_visuals(node, data):
	var props = data.get("properties", {})
	var has_npcs = data.has("initial_npcs") and data.initial_npcs.size() > 0
	var has_items = data.has("items") and data.items.size() > 0
	var is_start = props.get("is_start_node", false)
	var custom_icon_id = props.get("icon", "")
	
	# Pass props dictionary for dynamic icon drawing
	node.update_icons(has_npcs, has_items, is_start, custom_icon_id, props)
	node.set_node_color(_get_room_color(props))

func _get_room_color(p): 
	if p.get("dark", false): return Color(0.15, 0.05, 0.25)
	if p.get("safe_zone", false): return Color(0.15, 0.35, 0.15)
	if p.get("outdoors", false): return Color(0.3, 0.25, 0.2)
	return Color(0.2, 0.2, 0.2)
# scripts/controllers/view_builders/WorldViewBuilder.gd
class_name WorldViewBuilder
extends RefCounted

const REGION_SCENE_SCRIPT = preload("res://scripts/scenes/RegionScene.gd")
const WORLD_SCALE = 0.1

var container: Node2D
var world_region_nodes: Dictionary = {}

signal region_node_selected(region_id)
signal region_moved(region_id, old_pos, new_pos)
signal request_region_edit(region_id)
signal region_dragged

func _init(p_container: Node2D):
	container = p_container

func build(all_world_data: Dictionary, positions: Dictionary, current_region_data: Dictionary, current_region_filename: String):
	clear()
	
	var working_data = all_world_data.duplicate(true)
	if current_region_filename != "":
		var live_rid = current_region_data.get("region_id", "")
		if live_rid != "" and working_data.has(live_rid):
			working_data[live_rid] = current_region_data
			
	var default_offset_x = 0.0
	for rid in working_data:
		var region_pos = Vector2.ZERO
		if positions.has(rid):
			region_pos = Vector2(positions[rid][0], positions[rid][1]) * WORLD_SCALE
		else:
			region_pos = Vector2(default_offset_x, 0) * WORLD_SCALE
			default_offset_x += 1200 
		
		var r_node = REGION_SCENE_SCRIPT.new()
		r_node.position = region_pos
		r_node.scale = Vector2(WORLD_SCALE, WORLD_SCALE)
		r_node.setup(rid, working_data[rid], _get_region_color(rid))
		
		# Connect signals
		r_node.region_selected.connect(func(id): region_node_selected.emit(id))
		r_node.region_moved_committed.connect(func(old, new): region_moved.emit(rid, old / WORLD_SCALE, new / WORLD_SCALE))
		r_node.request_edit.connect(func(id): request_region_edit.emit(id))
		# When a region node is dragged, forward a signal so Main knows an object drag is happening.
		r_node.region_dragged.connect(func(_pos): region_dragged.emit())
		
		container.add_child(r_node)
		world_region_nodes[rid] = r_node

func clear():
	for c in container.get_children(): c.queue_free()
	world_region_nodes.clear()

func _get_region_color(rid: String) -> Color:
	var hash = rid.hash()
	var h = float(hash % 1000) / 1000.0
	return Color.from_hsv(h, 0.4, 0.3)
# scripts/controllers/view_builders/QuestViewBuilder.gd
class_name QuestViewBuilder
extends RefCounted

const QUEST_NODE_SCRIPT = preload("res://scripts/scenes/QuestNode.gd")

var container: Node2D
var quest_nodes: Dictionary = {} # stage_idx -> Node

signal node_selected(idx)
signal node_moved(idx, pos)
signal node_dragged

func _init(c: Node2D):
	container = c

func build(quest_data: Dictionary):
	clear()
	if not quest_data.has("stages"): return
	
	var stages = quest_data.stages
	
	# Auto-layout if positions missing
	for i in range(stages.size()):
		var s = stages[i]
		if not s.has("_editor_pos"):
			s["_editor_pos"] = [i * 250, 0] # Default linear layout
			
		var pos = Vector2(s._editor_pos[0], s._editor_pos[1])
		_spawn_node(i, s, pos)

	# Queue redraw for connections handled by GraphController or local draw
	container.queue_redraw()

func _spawn_node(idx, data, pos):
	var node = Control.new()
	node.set_script(QUEST_NODE_SCRIPT)
	node.setup(idx, data)
	node.position = pos
	
	node.selected.connect(func(i): node_selected.emit(i))
	node.dragged.connect(func(p): node_moved.emit(idx, p); container.queue_redraw())
	node.drag_ended.connect(func(): node_dragged.emit())
	
	container.add_child(node)
	quest_nodes[idx] = node

func clear():
	for c in container.get_children(): c.queue_free()
	quest_nodes.clear()

func draw_connections(canvas: Node2D, quest_data: Dictionary):
	if not quest_data.has("stages"): return
	var stages = quest_data.stages
	
	for i in range(stages.size()):
		var s = stages[i]
		var next_id = s.get("next", "")
		
		# Find target index by ID
		var target_idx = -1
		if next_id != "":
			for j in range(stages.size()):
				if stages[j].get("id", "") == next_id:
					target_idx = j
					break
		# Default next
		elif i < stages.size() - 1:
			target_idx = i + 1
			
		if target_idx != -1 and quest_nodes.has(i) and quest_nodes.has(target_idx):
			var n1 = quest_nodes[i]
			var n2 = quest_nodes[target_idx]
			var p1 = n1.position + n1.custom_minimum_size / 2
			var p2 = n2.position + n2.custom_minimum_size / 2
			
			canvas.draw_line(p1, p2, Color.WHITE, 2.0)
			# Draw Arrow
			var dir = (p2 - p1).normalized()
			var tip = p2 - (dir * 40)
			var a1 = tip - dir.rotated(0.5) * 10
			var a2 = tip - dir.rotated(-0.5) * 10
			canvas.draw_colored_polygon(PackedVector2Array([tip, a1, a2]), Color.WHITE)
# scripts/data/RegionManager.gd
class_name RegionManager
extends RefCounted

const REGIONS_DIR = "res://data/regions/"

var data: Dictionary = {}
var current_filename: String = ""

# --- DIRTY STATE TRACKING ---
var is_region_dirty: bool = false
var dirty_room_ids: Dictionary = {} 

func load_region(filename: String) -> bool:
	is_region_dirty = false
	dirty_room_ids.clear()

	current_filename = filename
	var full_path = REGIONS_DIR + filename
	if not FileAccess.file_exists(full_path):
		# Don't error on blank load
		if filename != "": push_error("Region file not found: " + full_path)
		return false
	
	var file = FileAccess.open(full_path, FileAccess.READ)
	if file:
		var json = JSON.new()
		var err = json.parse(file.get_as_text())
		if err == OK:
			data = json.get_data()
			if not data.has("rooms"): data["rooms"] = {}
			if not data.has("region_id"): data["region_id"] = filename.replace(".json", "")
			return true
		else:
			push_error("JSON Parse Error: " + json.get_error_message())
			
	data = {"region_id": filename.replace(".json",""), "rooms": {}}
	return false

func save_region():
	if current_filename == "": return
	var file = FileAccess.open(REGIONS_DIR + current_filename, FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(data, "\t"))

# --- MUTATION METHODS ---

func add_room_data(id: String, room_data: Dictionary):
	if not data.has("rooms"): data["rooms"] = {}
	data["rooms"][id] = room_data

func remove_room_data(id: String):
	if data.get("rooms", {}).has(id):
		data["rooms"].erase(id)

func set_room_pos(id: String, pos: Vector2):
	if data.get("rooms", {}).has(id):
		data["rooms"][id]["_editor_pos"] = [pos.x, pos.y]
	else:
		# Handle Proxy/External Nodes
		if not data.has("_proxy_positions"): data["_proxy_positions"] = {}
		data["_proxy_positions"][id] = [pos.x, pos.y]

func add_exit(src: String, dir: String, target: String):
	if data["rooms"].has(src):
		if not data["rooms"][src].has("exits"): data["rooms"][src]["exits"] = {}
		data["rooms"][src]["exits"][dir] = target

func remove_exit(src: String, dir: String):
	if data["rooms"].has(src) and data["rooms"][src].has("exits"):
		data["rooms"][src]["exits"].erase(dir)

# Renamed to avoid conflict with Object.get_incoming_connections()
func find_incoming_connections(target_id: String) -> Array:
	var links = []
	if not data.has("rooms"): return links
	for room_id in data.rooms:
		var r = data.rooms[room_id]
		if r.has("exits"):
			for dir in r.exits:
				if r.exits[dir] == target_id:
					links.append({"source": room_id, "dir": dir})
	return links

func rename_room(old_id: String, new_id: String) -> bool:
	if not data["rooms"].has(old_id) or data["rooms"].has(new_id): return false
	
	if dirty_room_ids.has(old_id):
		dirty_room_ids.erase(old_id)
		dirty_room_ids[new_id] = true

	var r = data["rooms"][old_id]
	data["rooms"][new_id] = r
	data["rooms"].erase(old_id)
	
	for rid in data["rooms"]:
		var exits = data["rooms"][rid].get("exits", {})
		for dir in exits:
			if exits[dir] == old_id: 
				exits[dir] = new_id
			elif ":" in exits[dir]:
				var parts = exits[dir].split(":")
				if parts[0] == data["region_id"] and parts[1] == old_id:
					exits[dir] = parts[0] + ":" + new_id

	is_region_dirty = true
	_patch_external_references(data["region_id"], old_id, new_id)
	return true

func _patch_external_references(target_region: String, old_room: String, new_room: String):
	var dir = DirAccess.open(REGIONS_DIR)
	if dir:
		dir.list_dir_begin()
		var fname = dir.get_next()
		while fname != "":
			if fname.ends_with(".json") and fname != current_filename:
				var content = FileAccess.get_file_as_string(REGIONS_DIR + fname)
				var search_str = target_region + ":" + old_room
				if content.contains(search_str):
					var f_read = FileAccess.open(REGIONS_DIR + fname, FileAccess.READ)
					var json = JSON.new()
					if json.parse(f_read.get_as_text()) == OK:
						var d = json.get_data()
						var dirty = false
						for rid in d.get("rooms", {}):
							var exits = d["rooms"][rid].get("exits", {})
							for dir_key in exits:
								if exits[dir_key] == search_str:
									exits[dir_key] = target_region + ":" + new_room
									dirty = true
						if dirty:
							var f_write = FileAccess.open(REGIONS_DIR + fname, FileAccess.WRITE)
							f_write.store_string(JSON.stringify(d, "\t"))
			fname = dir.get_next()

func mark_room_dirty(room_id: String):
	if room_id != "": dirty_room_ids[room_id] = true
	is_region_dirty = true

func mark_clean():
	is_region_dirty = false
	dirty_room_ids.clear()
# scripts/data/DatabaseManager.gd
class_name DatabaseManager
extends RefCounted

const NPC_DIR = "res://data/npcs/"
const ITEM_DIR = "res://data/items/"
const MAGIC_DIR = "res://data/magic/"
const QUEST_DIR = "res://data/quests/"
const TEMPLATE_DIR = "res://data/templates/"

# Data stores
var npcs: Dictionary = {}
var items: Dictionary = {}
var magic: Dictionary = {}
var quests: Dictionary = {}
var templates: Dictionary = {}

func _init():
	_ensure_dir(NPC_DIR)
	_ensure_dir(ITEM_DIR)
	_ensure_dir(MAGIC_DIR)
	_ensure_dir(QUEST_DIR)
	_ensure_dir(TEMPLATE_DIR)
	load_all()

func _ensure_dir(path):
	if not DirAccess.dir_exists_absolute(path): DirAccess.make_dir_recursive_absolute(path)

func load_all():
	npcs.clear(); items.clear(); magic.clear(); quests.clear(); templates.clear()
	_load_recursive(NPC_DIR, "", npcs)
	_load_recursive(ITEM_DIR, "", items)
	_load_recursive(MAGIC_DIR, "", magic)
	_load_recursive(QUEST_DIR, "", quests)
	_load_recursive(TEMPLATE_DIR, "", templates)

func _load_recursive(root_dir: String, current_subdir: String, target_dict: Dictionary):
	var full_current_path = root_dir.path_join(current_subdir)
	var dir = DirAccess.open(full_current_path)
	if dir:
		dir.list_dir_begin()
		var file_name = dir.get_next()
		while file_name != "":
			if dir.current_is_dir():
				if file_name != "." and file_name != "..":
					_load_recursive(root_dir, current_subdir.path_join(file_name), target_dict)
			elif file_name.ends_with(".json"):
				_load_file(full_current_path.path_join(file_name), current_subdir.path_join(file_name), target_dict)
			file_name = dir.get_next()

func _load_file(full_path: String, relative_path: String, target_dict: Dictionary):
	var f = FileAccess.open(full_path, FileAccess.READ)
	if f:
		var json = JSON.new()
		var parse_err = json.parse(f.get_as_text())
		if parse_err == OK:
			var data = json.get_data()
			if typeof(data) == TYPE_DICTIONARY:
				if data.is_empty(): return

				# --- ROBUST HEURISTIC ---
				# 1. Does it look like a Single Object? (Has identifying fields at root)
				var is_likely_single = data.has("name") and data.has("type") and typeof(data.get("name")) == TYPE_STRING
				
				# 2. Does it look like a Library? (Values are Dictionaries)
				var dict_value_count = 0
				var total_keys = 0
				for k in data:
					total_keys += 1
					if typeof(data[k]) == TYPE_DICTIONARY:
						dict_value_count += 1
				
				var is_likely_library = dict_value_count > 0
				
				# DECISION:
				# If it looks like a Single Object, treat it as such.
				# Otherwise, if it has dictionary values, treat it as a Library.
				# We prioritize Single Object detection to avoid splitting a complex item into pieces.
				
				if is_likely_single and not (is_likely_library and total_keys > 5 and not data.has("id")):
					# Treat as Single Entity
					var id = data.get("id", relative_path.get_file().replace(".json", ""))
					target_dict[id] = data
					target_dict[id]["_filename"] = relative_path
				elif is_likely_library:
					# Treat as Library
					for id in data:
						# Only load values that are Dictionaries (skips metadata like "_version": "1.0")
						if typeof(data[id]) == TYPE_DICTIONARY:
							target_dict[id] = data[id]
							target_dict[id]["_filename"] = relative_path
				else:
					# Fallback: If we can't decide, defaulting to Single is safer for preservation,
					# but might create a junk entry. For this specific data set (RPGs), Library is the safer default for non-singles.
					print("Warning: Could not determine format of %s. Loading contents as items." % relative_path)
					for id in data:
						if typeof(data[id]) == TYPE_DICTIONARY:
							target_dict[id] = data[id]
							target_dict[id]["_filename"] = relative_path
		else:
			print("Error parsing JSON in %s: %s" % [relative_path, json.get_error_message()])

# Saves ALL changes to disk, grouping by filename to ensure library integrity
func save_all():
	_save_category(npcs, NPC_DIR)
	_save_category(items, ITEM_DIR)
	_save_category(magic, MAGIC_DIR)
	_save_category(quests, QUEST_DIR)
	_save_category(templates, TEMPLATE_DIR)

func _save_category(cache: Dictionary, root_dir: String):
	# Group data by filename
	var files_content = {}
	
	for id in cache:
		var data = cache[id]
		var fname = data.get("_filename", "custom.json")
		
		if not files_content.has(fname):
			files_content[fname] = {}
			
		var save_copy = data.duplicate(true)
		save_copy.erase("_filename")
		files_content[fname][id] = save_copy
	
	# Write files
	for fname in files_content:
		var full_path = root_dir.path_join(fname)
		# Ensure subdirectory exists
		var base_dir = full_path.get_base_dir()
		if not DirAccess.dir_exists_absolute(base_dir):
			DirAccess.make_dir_recursive_absolute(base_dir)
			
		var f = FileAccess.open(full_path, FileAccess.WRITE)
		if f:
			f.store_string(JSON.stringify(files_content[fname], "\t"))

# Individual create helper (updates memory only)
func add_npc(id: String, data: Dictionary): _add_entry(id, data, npcs)
func add_item(id: String, data: Dictionary): _add_entry(id, data, items)
func add_magic(id: String, data: Dictionary): _add_entry(id, data, magic)
func add_quest(id: String, data: Dictionary): _add_entry(id, data, quests)
func save_template(id: String, data: Dictionary): _add_entry(id, data, templates)

func _add_entry(id: String, data: Dictionary, cache: Dictionary):
	if not data.has("_filename"):
		data["_filename"] = "custom.json" 
	cache[id] = data

func delete_entry(type: String, id: String):
	var target_dict
	match type:
		"npc": target_dict = npcs
		"item": target_dict = items
		"magic": target_dict = magic
		"quest": target_dict = quests
		"template": target_dict = templates
	
	if target_dict.has(id):
		target_dict.erase(id)

func get_ids(type: String) -> Array:
	var d
	match type:
		"npc": d = npcs
		"item": d = items
		"magic": d = magic
		"quest": d = quests
		"template": d = templates
	var k = d.keys()
	k.sort()
	return k

func get_npc_ids() -> Array: return get_ids("npc")
func get_item_ids() -> Array: return get_ids("item")
func get_template_ids() -> Array: return get_ids("template")
