"""
game_object.py
Base class for all game objects with common functionality.
"""
from typing import Dict, Any, List, Optional, Tuple
import uuid
from core.config import EFFECT_DEFAULT_TICK_INTERVAL 

class GameObject:
    def __init__(self, obj_id: str = None, name: str = "Unknown", 
                 description: str = "No description"):
        self.obj_id = obj_id if obj_id else f"{self.__class__.__name__.lower()}_{uuid.uuid4().hex[:8]}"
        self.name = name
        self.description = description
        self.properties: Dict[str, Any] = {}
        self.active_effects: List[Dict[str, Any]] = [] 
        self.is_alive: bool = True # Assume objects start alive

    def get_description(self) -> str:
        return f"{self.name}\n\n{self.description}"
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "type": self.__class__.__name__,
            "id": self.obj_id,
            "name": self.name,
            "description": self.description,
            "properties": self.properties,
            "is_alive": self.is_alive 
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'GameObject':
        obj = cls(
            obj_id=data.get("obj_id") or data.get("id"),
            name=data.get("name", "Unknown"),
            description=data.get("description", "No description")
        )
        obj.properties = data.get("properties", {})
        obj.is_alive = data.get("is_alive", True) 
        return obj
    
    def update_property(self, key: str, value: Any) -> None:
        self.properties[key] = value
    
    def get_property(self, key: str, default: Any = None) -> Any:
        return self.properties.get(key, default)

    def apply_effect(self, effect_data: Dict[str, Any], current_time: float) -> Tuple[bool, str]:
        if not self.is_alive: return False, f"{self.name} cannot be affected."

        effect_name = effect_data.get("name", "Unknown Effect")
        # print(f"[DEBUG {self.__class__.__name__}.apply_effect] Received attempt to apply effect: '{effect_name}' to {self.name}")

        existing_effect_index = -1
        for i, existing in enumerate(self.active_effects):
            if existing.get("name") == effect_name:
                existing_effect_index = i
                break

        new_effect_instance = effect_data.copy()
        new_effect_instance["id"] = f"effect_{uuid.uuid4().hex[:8]}"
        new_effect_instance["duration_remaining"] = new_effect_instance.get("base_duration", 10.0)
        new_effect_instance["last_tick_time"] = current_time 
        new_effect_instance["last_processed_time"] = current_time

        if existing_effect_index != -1:
            self.active_effects[existing_effect_index] = new_effect_instance
            # print(f"[DEBUG {self.__class__.__name__}.apply_effect] Refreshed effect '{effect_name}' on {self.name}.")
        else:
            self.active_effects.append(new_effect_instance)
            # print(f"[DEBUG {self.__class__.__name__}.apply_effect] Added new effect '{effect_name}' to {self.name}.")
        
        # print(f"[DEBUG {self.__class__.__name__}.apply_effect] Active effects on {self.name} count: {len(self.active_effects)}")
        return True, ""

    def remove_effect(self, effect_name: str) -> bool:
        original_count = len(self.active_effects)
        self.active_effects = [eff for eff in self.active_effects if eff.get("name") != effect_name]
        return len(self.active_effects) < original_count

    def process_active_effects(self, current_time: float, time_delta: float) -> List[str]:
        """
        Processes active status effects, applying ticks and handling expirations.
        Args:
            current_time: The current absolute game time.
            time_delta: The time elapsed since the last update tick for effects.
        Returns:
            A list of simple, factual messages generated by effects.
        """
        if not self.is_alive: # If object died between updates, clear effects.
            if self.active_effects:
                self.active_effects.clear()
                # print(f"[DEBUG {self.name}] Effects cleared due to death prior to processing.")
            return []

        effects_processed_this_tick = []
        expired_effects_indices = []
        tick_messages = []

        for i in range(len(self.active_effects) - 1, -1, -1):
            effect = self.active_effects[i]
            effect_id = effect.get("id")
            if not effect_id or effect_id in effects_processed_this_tick: continue
            effects_processed_this_tick.append(effect_id)

            # 1. Update Duration
            # Use the provided time_delta which should be accurate for this processing cycle.
            effect["duration_remaining"] -= time_delta
            effect["last_processed_time"] = current_time # Update last processed to current

            # 2. Check Expiration
            if effect["duration_remaining"] <= 0:
                expired_effects_indices.append(i)
                tick_messages.append(f"The {effect.get('name', 'effect')} on {self.name} wears off.")
                continue

            # 3. Process Ticks (for DoTs)
            if effect.get("type") == "dot":
                tick_interval = effect.get("tick_interval", EFFECT_DEFAULT_TICK_INTERVAL)
                last_tick = effect.get("last_tick_time", current_time - tick_interval) # Ensure first tick can happen

                # Check how many ticks should have occurred
                time_since_last_tick = current_time - last_tick
                num_ticks_due = int(time_since_last_tick // tick_interval)

                for _ in range(num_ticks_due):
                    if not self.is_alive: break # Stop ticking if DoT killed it

                    damage = effect.get("damage_per_tick", 0)
                    dmg_type = effect.get("damage_type", "unknown")
                    if damage > 0 and hasattr(self, 'take_damage'):
                        damage_taken = self.take_damage(damage, dmg_type)
                        effect["last_tick_time"] += tick_interval # Advance last_tick_time by one interval
                        
                        if damage_taken > 0:
                            tick_messages.append(f"{self.name} takes {damage_taken} {dmg_type} damage from {effect.get('name', 'effect')}.")
                        # else: # Optional: message if resisted
                        #     tick_messages.append(f"{self.name} resists the {dmg_type} damage from {effect.get('name', 'effect')}.")

                        if not self.is_alive: # Check death *after* take_damage
                            tick_messages.append(f"{self.name} succumbs to the {effect.get('name', 'effect')}!")
                            break # Exit the tick loop for this effect if dead
                    elif not hasattr(self, 'take_damage'):
                        print(f"Warning: {self.name} has a DoT but no take_damage method.")
                        break # Cannot process DoT further

            if not self.is_alive: # If a DoT killed the object, stop processing other effects
                break
        
        # Remove expired effects safely
        for index in sorted(expired_effects_indices, reverse=True):
            if 0 <= index < len(self.active_effects):
                del self.active_effects[index]
        
        # If object died during effect processing, ensure all effects are cleared
        if not self.is_alive and self.active_effects:
            # print(f"[DEBUG {self.name}] Effects cleared because object died during processing.")
            self.active_effects.clear()

        return tick_messages
